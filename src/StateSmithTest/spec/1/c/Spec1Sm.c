// Autogenerated with StateSmith
#include "Spec1Sm.h"
#include "../../lang-helpers/c/helper.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

static void ROOT_enter(Spec1Sm* self);
static void ROOT_exit(Spec1Sm* self);

static void S_enter(Spec1Sm* self);
static void S_exit(Spec1Sm* self);

static void S1_enter(Spec1Sm* self);
static void S1_exit(Spec1Sm* self);

static void S11_enter(Spec1Sm* self);
static void S11_exit(Spec1Sm* self);
static void S11_ev1(Spec1Sm* self);

static void T1_enter(Spec1Sm* self);
static void T1_exit(Spec1Sm* self);

static void T11_enter(Spec1Sm* self);
static void T11_exit(Spec1Sm* self);
static void T11_ev2(Spec1Sm* self);

static void T111_enter(Spec1Sm* self);
static void T111_exit(Spec1Sm* self);

static void exit_up_to_state_handler(Spec1Sm* self, const Spec1Sm_Func desired_state_exit_handler);


void Spec1Sm_ctor(Spec1Sm* self)
{
    memset(self, 0, sizeof(*self));
}

static void exit_up_to_state_handler(Spec1Sm* self, const Spec1Sm_Func desired_state_exit_handler)
{
    while (self->current_state_exit_handler != desired_state_exit_handler)
    {
        self->current_state_exit_handler(self);
    }
}

void Spec1Sm_start(Spec1Sm* self)
{
    ROOT_enter(self);
    // ROOT behavior
    // uml transition target: ROOT.InitialState
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be ROOT or one of its sub states.
        exit_up_to_state_handler(self, ROOT_exit);  // Exit until we reach ROOT state.
        
        // Enter towards target
        // ROOT.InitialState behavior
        // uml action: trace("Transition action `` for ROOT.InitialState to S.");
        // uml transition target: S
        if (true)
        {
            trace("Transition action `` for ROOT.InitialState to S.");
            
            // Enter towards target
            S_enter(self);
            // S.InitialState behavior
            // uml action: trace("Transition action `` for S.InitialState to S1.");
            // uml transition target: S1
            if (true)
            {
                trace("Transition action `` for S.InitialState to S1.");
                
                // Enter towards target
                S1_enter(self);
                // S1.InitialState behavior
                // uml action: trace("Transition action `` for S1.InitialState to S11.");
                // uml transition target: S11
                if (true)
                {
                    trace("Transition action `` for S1.InitialState to S11.");
                    
                    // Enter towards target
                    S11_enter(self);
                    
                    // update state_id
                    self->state_id = Spec1Sm_StateId_S11;
                    self->ancestor_event_handler = NULL;
                    return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
                } // end of behavior
            } // end of behavior
        } // end of behavior
    } // end of behavior
}

void Spec1Sm_dispatch_event(Spec1Sm* self, enum Spec1Sm_EventId event_id)
{
    Spec1Sm_Func behavior_func = self->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        self->ancestor_event_handler = NULL;
        behavior_func(self);
        behavior_func = self->ancestor_event_handler;
    }
}

const char* Spec1Sm_state_id_to_string(const enum Spec1Sm_StateId id)
{
    switch (id)
    {
        case Spec1Sm_StateId_ROOT: return "ROOT";
        case Spec1Sm_StateId_S: return "S";
        case Spec1Sm_StateId_S1: return "S1";
        case Spec1Sm_StateId_S11: return "S11";
        case Spec1Sm_StateId_T1: return "T1";
        case Spec1Sm_StateId_T11: return "T11";
        case Spec1Sm_StateId_T111: return "T111";
        default: return "?";
    }
}

////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(Spec1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = ROOT_exit;
    
    // ROOT behavior
    // uml action: trace("Enter Spec1Sm.");
    if (true)
    {
        trace("Enter Spec1Sm.");
    } // end of behavior code
}

static void ROOT_exit(Spec1Sm* self)
{
    // ROOT behavior
    // uml action: trace("Exit Spec1Sm.");
    if (true)
    {
        trace("Exit Spec1Sm.");
    } // end of behavior code
    // State machine root is a special case. It cannot be exited.
    (void)self;  // nothing to see here compiler. move along!
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state S
////////////////////////////////////////////////////////////////////////////////

static void S_enter(Spec1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = S_exit;
    
    // S behavior
    // uml action: trace("Enter S.");
    if (true)
    {
        trace("Enter S.");
    } // end of behavior code
}

static void S_exit(Spec1Sm* self)
{
    // S behavior
    // uml action: trace("Exit S.");
    if (true)
    {
        trace("Exit S.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state S1
////////////////////////////////////////////////////////////////////////////////

static void S1_enter(Spec1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = S1_exit;
    
    // S1 behavior
    // uml action: trace("Enter S1.");
    if (true)
    {
        trace("Enter S1.");
    } // end of behavior code
}

static void S1_exit(Spec1Sm* self)
{
    // S1 behavior
    // uml action: trace("Exit S1.");
    if (true)
    {
        trace("Exit S1.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = S_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state S11
////////////////////////////////////////////////////////////////////////////////

static void S11_enter(Spec1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = S11_exit;
    self->current_event_handlers[Spec1Sm_EventId_EV1] = S11_ev1;
    
    // S11 behavior
    // uml action: trace("Enter S11.");
    if (true)
    {
        trace("Enter S11.");
    } // end of behavior code
}

static void S11_exit(Spec1Sm* self)
{
    // S11 behavior
    // uml action: trace("Exit S11.");
    if (true)
    {
        trace("Exit S11.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = S1_exit;
    self->current_event_handlers[Spec1Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void S11_ev1(Spec1Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // S11 behavior
    // uml guard: trace_guard("State S11: check behavior `EV1 TransitionTo(S1.ExitPoint(1))`.", true)
    // uml action: trace("Transition action `` for S11 to S1.ExitPoint(1).");
    // uml transition target: S1.ExitPoint(1)
    if (trace_guard("State S11: check behavior `EV1 TransitionTo(S1.ExitPoint(1))`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Optimize away while-exit-loop because we know that the active leaf state is S11 and it is exiting directly to its parent S1.
        S11_exit(self);
        trace("Transition action `` for S11 to S1.ExitPoint(1).");
        
        // Enter towards target
        // S1.ExitPoint(1) behavior
        // uml action: trace("Transition action `` for S1.ExitPoint(1) to T11.EntryPoint(1).");
        // uml transition target: T11.EntryPoint(1)
        if (true)
        {
            // Optimize away while-exit-loop because we know that the active leaf state is S1 and it is exiting directly to its parent S.
            S1_exit(self);
            trace("Transition action `` for S1.ExitPoint(1) to T11.EntryPoint(1).");
            
            // Enter towards target
            T1_enter(self);
            T11_enter(self);
            // T11.EntryPoint(1) behavior
            // uml action: trace("Transition action `` for T11.EntryPoint(1) to T111.");
            // uml transition target: T111
            if (true)
            {
                trace("Transition action `` for T11.EntryPoint(1) to T111.");
                
                // Enter towards target
                T111_enter(self);
                
                // update state_id
                self->state_id = Spec1Sm_StateId_T111;
                self->ancestor_event_handler = NULL;
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior
        } // end of behavior
    } // end of behavior
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state T1
////////////////////////////////////////////////////////////////////////////////

static void T1_enter(Spec1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = T1_exit;
    
    // T1 behavior
    // uml action: trace("Enter T1.");
    if (true)
    {
        trace("Enter T1.");
    } // end of behavior code
}

static void T1_exit(Spec1Sm* self)
{
    // T1 behavior
    // uml action: trace("Exit T1.");
    if (true)
    {
        trace("Exit T1.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = S_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state T11
////////////////////////////////////////////////////////////////////////////////

static void T11_enter(Spec1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = T11_exit;
    self->current_event_handlers[Spec1Sm_EventId_EV2] = T11_ev2;
    
    // T11 behavior
    // uml action: trace("Enter T11.");
    if (true)
    {
        trace("Enter T11.");
    } // end of behavior code
}

static void T11_exit(Spec1Sm* self)
{
    // T11 behavior
    // uml action: trace("Exit T11.");
    if (true)
    {
        trace("Exit T11.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = T1_exit;
    self->current_event_handlers[Spec1Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
}

static void T11_ev2(Spec1Sm* self)
{
    // No ancestor state handles `EV2` event.
    
    // T11 behavior
    // uml guard: trace_guard("State T11: check behavior `EV2 TransitionTo(S1)`.", true)
    // uml action: trace("Transition action `` for T11 to S1.");
    // uml transition target: S1
    if (trace_guard("State T11: check behavior `EV2 TransitionTo(S1)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be T11 or one of its sub states.
        exit_up_to_state_handler(self, S_exit);  // Exit until we reach S state.
        trace("Transition action `` for T11 to S1.");
        
        // Enter towards target
        S1_enter(self);
        // S1.InitialState behavior
        // uml action: trace("Transition action `` for S1.InitialState to S11.");
        // uml transition target: S11
        if (true)
        {
            trace("Transition action `` for S1.InitialState to S11.");
            
            // Enter towards target
            S11_enter(self);
            
            // update state_id
            self->state_id = Spec1Sm_StateId_S11;
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior
    } // end of behavior
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state T111
////////////////////////////////////////////////////////////////////////////////

static void T111_enter(Spec1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = T111_exit;
    
    // T111 behavior
    // uml action: trace("Enter T111.");
    if (true)
    {
        trace("Enter T111.");
    } // end of behavior code
}

static void T111_exit(Spec1Sm* self)
{
    // T111 behavior
    // uml action: trace("Exit T111.");
    if (true)
    {
        trace("Exit T111.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = T11_exit;
}


