// Autogenerated with StateSmith
#include "Spec2Sm.h"
#include "../../lang-helpers/c/helper.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

static void ROOT_enter(Spec2Sm* self);
static void ROOT_exit(Spec2Sm* self);

static void DECIDE_enter(Spec2Sm* self);
static void DECIDE_exit(Spec2Sm* self);
static void DECIDE_ev1(Spec2Sm* self);
static void DECIDE_ev2(Spec2Sm* self);
static void DECIDE_ev3(Spec2Sm* self);
static void DECIDE_ev4(Spec2Sm* self);
static void DECIDE_ev5(Spec2Sm* self);
static void DECIDE_ev6(Spec2Sm* self);

static void TEST1_DO_EVENT_TESTING_enter(Spec2Sm* self);
static void TEST1_DO_EVENT_TESTING_exit(Spec2Sm* self);

static void TEST1_ROOT_enter(Spec2Sm* self);
static void TEST1_ROOT_exit(Spec2Sm* self);
static void TEST1_ROOT_do(Spec2Sm* self);

static void TEST1_S1_enter(Spec2Sm* self);
static void TEST1_S1_exit(Spec2Sm* self);

static void TEST1_S1_1_enter(Spec2Sm* self);
static void TEST1_S1_1_exit(Spec2Sm* self);
static void TEST1_S1_1_do(Spec2Sm* self);
static void TEST1_S1_1_ev1(Spec2Sm* self);

static void TEST1_S2_enter(Spec2Sm* self);
static void TEST1_S2_exit(Spec2Sm* self);
static void TEST1_S2_do(Spec2Sm* self);

static void TEST2_REGULAR_EVENT_TESTING_enter(Spec2Sm* self);
static void TEST2_REGULAR_EVENT_TESTING_exit(Spec2Sm* self);

static void TEST2_ROOT_enter(Spec2Sm* self);
static void TEST2_ROOT_exit(Spec2Sm* self);
static void TEST2_ROOT_do(Spec2Sm* self);
static void TEST2_ROOT_ev1(Spec2Sm* self);
static void TEST2_ROOT_ev2(Spec2Sm* self);

static void TEST2_S1_enter(Spec2Sm* self);
static void TEST2_S1_exit(Spec2Sm* self);

static void TEST2_S1_1_enter(Spec2Sm* self);
static void TEST2_S1_1_exit(Spec2Sm* self);
static void TEST2_S1_1_do(Spec2Sm* self);
static void TEST2_S1_1_ev1(Spec2Sm* self);

static void TEST2_S2_enter(Spec2Sm* self);
static void TEST2_S2_exit(Spec2Sm* self);
static void TEST2_S2_ev1(Spec2Sm* self);
static void TEST2_S2_ev2(Spec2Sm* self);

static void TEST3_BEHAVIOR_ORDERING_enter(Spec2Sm* self);
static void TEST3_BEHAVIOR_ORDERING_exit(Spec2Sm* self);

static void TEST3_ROOT_enter(Spec2Sm* self);
static void TEST3_ROOT_exit(Spec2Sm* self);
static void TEST3_ROOT_ev1(Spec2Sm* self);

static void TEST3_S1_enter(Spec2Sm* self);
static void TEST3_S1_exit(Spec2Sm* self);
static void TEST3_S1_ev1(Spec2Sm* self);

static void TEST3_S2_enter(Spec2Sm* self);
static void TEST3_S2_exit(Spec2Sm* self);
static void TEST3_S2_ev1(Spec2Sm* self);

static void TEST3_S3_enter(Spec2Sm* self);
static void TEST3_S3_exit(Spec2Sm* self);

static void TEST4_PARENT_CHILD_TRANSITIONS_enter(Spec2Sm* self);
static void TEST4_PARENT_CHILD_TRANSITIONS_exit(Spec2Sm* self);

static void TEST4_ROOT_enter(Spec2Sm* self);
static void TEST4_ROOT_exit(Spec2Sm* self);
static void TEST4_ROOT_ev2(Spec2Sm* self);
static void TEST4_ROOT_ev3(Spec2Sm* self);
static void TEST4_ROOT_ev4(Spec2Sm* self);

static void TEST4_S1_enter(Spec2Sm* self);
static void TEST4_S1_exit(Spec2Sm* self);
static void TEST4_S1_ev1(Spec2Sm* self);

static void TEST4_S10_enter(Spec2Sm* self);
static void TEST4_S10_exit(Spec2Sm* self);
static void TEST4_S10_ev4(Spec2Sm* self);

static void TEST4_S10_1_enter(Spec2Sm* self);
static void TEST4_S10_1_exit(Spec2Sm* self);

static void TEST4_S2_enter(Spec2Sm* self);
static void TEST4_S2_exit(Spec2Sm* self);
static void TEST4_S2_ev1(Spec2Sm* self);

static void TEST4_S20_enter(Spec2Sm* self);
static void TEST4_S20_exit(Spec2Sm* self);
static void TEST4_S20_ev4(Spec2Sm* self);

static void TEST4_S20_1_enter(Spec2Sm* self);
static void TEST4_S20_1_exit(Spec2Sm* self);

static void TEST4_S3_enter(Spec2Sm* self);
static void TEST4_S3_exit(Spec2Sm* self);
static void TEST4_S3_ev1(Spec2Sm* self);

static void TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_enter(Spec2Sm* self);
static void TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_exit(Spec2Sm* self);

static void TEST5_ROOT_enter(Spec2Sm* self);
static void TEST5_ROOT_exit(Spec2Sm* self);
static void TEST5_ROOT_ev2(Spec2Sm* self);

static void TEST5_S1_enter(Spec2Sm* self);
static void TEST5_S1_exit(Spec2Sm* self);
static void TEST5_S1_ev1(Spec2Sm* self);

static void TEST5_S2_enter(Spec2Sm* self);
static void TEST5_S2_exit(Spec2Sm* self);
static void TEST5_S2_ev1(Spec2Sm* self);

static void TEST5_S3_enter(Spec2Sm* self);
static void TEST5_S3_exit(Spec2Sm* self);
static void TEST5_S3_ev1(Spec2Sm* self);

static void TEST6_VARIABLES_enter(Spec2Sm* self);
static void TEST6_VARIABLES_exit(Spec2Sm* self);

static void TEST6_ROOT_enter(Spec2Sm* self);
static void TEST6_ROOT_exit(Spec2Sm* self);

static void TEST6_S1_enter(Spec2Sm* self);
static void TEST6_S1_exit(Spec2Sm* self);
static void TEST6_S1_ev1(Spec2Sm* self);

static void TEST6_S2_enter(Spec2Sm* self);
static void TEST6_S2_exit(Spec2Sm* self);

static void exit_up_to_state_handler(Spec2Sm* self, const Spec2Sm_Func desired_state_exit_handler);


void Spec2Sm_ctor(Spec2Sm* self)
{
    memset(self, 0, sizeof(*self));
}

static void exit_up_to_state_handler(Spec2Sm* self, const Spec2Sm_Func desired_state_exit_handler)
{
    while (self->current_state_exit_handler != desired_state_exit_handler)
    {
        self->current_state_exit_handler(self);
    }
}

void Spec2Sm_start(Spec2Sm* self)
{
    ROOT_enter(self);
    // ROOT behavior
    // uml transition target: ROOT.InitialState
    if (true)
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be ROOT or one of its sub states.
        exit_up_to_state_handler(self, ROOT_exit);  // Exit until we reach ROOT state.
        
        // Enter towards target
        // ROOT.InitialState behavior
        // uml action: trace("Transition action `` for ROOT.InitialState to DECIDE.");
        // uml transition target: DECIDE
        if (true)
        {
            trace("Transition action `` for ROOT.InitialState to DECIDE.");
            
            // Enter towards target
            DECIDE_enter(self);
            
            // update state_id
            self->state_id = Spec2Sm_StateId_DECIDE;
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ROOT.InitialState
    } // end of behavior for ROOT
}

void Spec2Sm_dispatch_event(Spec2Sm* self, enum Spec2Sm_EventId event_id)
{
    Spec2Sm_Func behavior_func = self->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        self->ancestor_event_handler = NULL;
        behavior_func(self);
        behavior_func = self->ancestor_event_handler;
    }
}

const char* Spec2Sm_state_id_to_string(const enum Spec2Sm_StateId id)
{
    switch (id)
    {
        case Spec2Sm_StateId_ROOT: return "ROOT";
        case Spec2Sm_StateId_DECIDE: return "DECIDE";
        case Spec2Sm_StateId_TEST1_DO_EVENT_TESTING: return "TEST1_DO_EVENT_TESTING";
        case Spec2Sm_StateId_TEST1_ROOT: return "TEST1_ROOT";
        case Spec2Sm_StateId_TEST1_S1: return "TEST1_S1";
        case Spec2Sm_StateId_TEST1_S1_1: return "TEST1_S1_1";
        case Spec2Sm_StateId_TEST1_S2: return "TEST1_S2";
        case Spec2Sm_StateId_TEST2_REGULAR_EVENT_TESTING: return "TEST2_REGULAR_EVENT_TESTING";
        case Spec2Sm_StateId_TEST2_ROOT: return "TEST2_ROOT";
        case Spec2Sm_StateId_TEST2_S1: return "TEST2_S1";
        case Spec2Sm_StateId_TEST2_S1_1: return "TEST2_S1_1";
        case Spec2Sm_StateId_TEST2_S2: return "TEST2_S2";
        case Spec2Sm_StateId_TEST3_BEHAVIOR_ORDERING: return "TEST3_BEHAVIOR_ORDERING";
        case Spec2Sm_StateId_TEST3_ROOT: return "TEST3_ROOT";
        case Spec2Sm_StateId_TEST3_S1: return "TEST3_S1";
        case Spec2Sm_StateId_TEST3_S2: return "TEST3_S2";
        case Spec2Sm_StateId_TEST3_S3: return "TEST3_S3";
        case Spec2Sm_StateId_TEST4_PARENT_CHILD_TRANSITIONS: return "TEST4_PARENT_CHILD_TRANSITIONS";
        case Spec2Sm_StateId_TEST4_ROOT: return "TEST4_ROOT";
        case Spec2Sm_StateId_TEST4_S1: return "TEST4_S1";
        case Spec2Sm_StateId_TEST4_S10: return "TEST4_S10";
        case Spec2Sm_StateId_TEST4_S10_1: return "TEST4_S10_1";
        case Spec2Sm_StateId_TEST4_S2: return "TEST4_S2";
        case Spec2Sm_StateId_TEST4_S20: return "TEST4_S20";
        case Spec2Sm_StateId_TEST4_S20_1: return "TEST4_S20_1";
        case Spec2Sm_StateId_TEST4_S3: return "TEST4_S3";
        case Spec2Sm_StateId_TEST5_PARENT_CHILD_TRANSITIONS_ALIAS: return "TEST5_PARENT_CHILD_TRANSITIONS_ALIAS";
        case Spec2Sm_StateId_TEST5_ROOT: return "TEST5_ROOT";
        case Spec2Sm_StateId_TEST5_S1: return "TEST5_S1";
        case Spec2Sm_StateId_TEST5_S2: return "TEST5_S2";
        case Spec2Sm_StateId_TEST5_S3: return "TEST5_S3";
        case Spec2Sm_StateId_TEST6_VARIABLES: return "TEST6_VARIABLES";
        case Spec2Sm_StateId_TEST6_ROOT: return "TEST6_ROOT";
        case Spec2Sm_StateId_TEST6_S1: return "TEST6_S1";
        case Spec2Sm_StateId_TEST6_S2: return "TEST6_S2";
        default: return "?";
    }
}

////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = ROOT_exit;
    
    // ROOT behavior
    // uml action: trace("Enter Spec2Sm.");
    if (true)
    {
        trace("Enter Spec2Sm.");
    } // end of behavior for ROOT
}

static void ROOT_exit(Spec2Sm* self)
{
    // ROOT behavior
    // uml action: trace("Exit Spec2Sm.");
    if (true)
    {
        trace("Exit Spec2Sm.");
    } // end of behavior for ROOT
    
    // State machine root is a special case. It cannot be exited.
    (void)self;  // nothing to see here compiler. move along!
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state DECIDE
////////////////////////////////////////////////////////////////////////////////

static void DECIDE_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = DECIDE_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = DECIDE_ev1;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = DECIDE_ev2;
    self->current_event_handlers[Spec2Sm_EventId_EV3] = DECIDE_ev3;
    self->current_event_handlers[Spec2Sm_EventId_EV4] = DECIDE_ev4;
    self->current_event_handlers[Spec2Sm_EventId_EV5] = DECIDE_ev5;
    self->current_event_handlers[Spec2Sm_EventId_EV6] = DECIDE_ev6;
    
    // DECIDE behavior
    // uml action: trace("Enter DECIDE.");
    if (true)
    {
        trace("Enter DECIDE.");
    } // end of behavior for DECIDE
}

static void DECIDE_exit(Spec2Sm* self)
{
    // DECIDE behavior
    // uml action: trace("Exit DECIDE.");
    if (true)
    {
        trace("Exit DECIDE.");
    } // end of behavior for DECIDE
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV3] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV4] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV5] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV6] = NULL;  // no ancestor listens to this event
}

static void DECIDE_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // DECIDE behavior
    // uml guard: trace_guard("State DECIDE: check behavior `EV1 TransitionTo(TEST1_DO_EVENT_TESTING)`.", true)
    // uml action: trace("Transition action `` for DECIDE to TEST1_DO_EVENT_TESTING.");
    // uml transition target: TEST1_DO_EVENT_TESTING
    if (trace_guard("State DECIDE: check behavior `EV1 TransitionTo(TEST1_DO_EVENT_TESTING)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Optimize away while-exit-loop because we know that the active leaf state is DECIDE and it is exiting directly to its parent ROOT.
        DECIDE_exit(self);
        trace("Transition action `` for DECIDE to TEST1_DO_EVENT_TESTING.");
        
        // Enter towards target
        TEST1_DO_EVENT_TESTING_enter(self);
        // TEST1_DO_EVENT_TESTING.InitialState behavior
        // uml action: trace("Transition action `` for TEST1_DO_EVENT_TESTING.InitialState to TEST1_ROOT.");
        // uml transition target: TEST1_ROOT
        if (true)
        {
            trace("Transition action `` for TEST1_DO_EVENT_TESTING.InitialState to TEST1_ROOT.");
            
            // Enter towards target
            TEST1_ROOT_enter(self);
            // TEST1_ROOT.InitialState behavior
            // uml action: trace("Transition action `` for TEST1_ROOT.InitialState to TEST1_S1_1.");
            // uml transition target: TEST1_S1_1
            if (true)
            {
                trace("Transition action `` for TEST1_ROOT.InitialState to TEST1_S1_1.");
                
                // Enter towards target
                TEST1_S1_enter(self);
                TEST1_S1_1_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST1_S1_1;
                self->ancestor_event_handler = NULL;
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for TEST1_ROOT.InitialState
        } // end of behavior for TEST1_DO_EVENT_TESTING.InitialState
    } // end of behavior for DECIDE
}

static void DECIDE_ev2(Spec2Sm* self)
{
    // No ancestor state handles `EV2` event.
    
    // DECIDE behavior
    // uml guard: trace_guard("State DECIDE: check behavior `EV2 TransitionTo(TEST2_REGULAR_EVENT_TESTING)`.", true)
    // uml action: trace("Transition action `` for DECIDE to TEST2_REGULAR_EVENT_TESTING.");
    // uml transition target: TEST2_REGULAR_EVENT_TESTING
    if (trace_guard("State DECIDE: check behavior `EV2 TransitionTo(TEST2_REGULAR_EVENT_TESTING)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Optimize away while-exit-loop because we know that the active leaf state is DECIDE and it is exiting directly to its parent ROOT.
        DECIDE_exit(self);
        trace("Transition action `` for DECIDE to TEST2_REGULAR_EVENT_TESTING.");
        
        // Enter towards target
        TEST2_REGULAR_EVENT_TESTING_enter(self);
        // TEST2_REGULAR_EVENT_TESTING.InitialState behavior
        // uml action: trace("Transition action `` for TEST2_REGULAR_EVENT_TESTING.InitialState to TEST2_ROOT.");
        // uml transition target: TEST2_ROOT
        if (true)
        {
            trace("Transition action `` for TEST2_REGULAR_EVENT_TESTING.InitialState to TEST2_ROOT.");
            
            // Enter towards target
            TEST2_ROOT_enter(self);
            // TEST2_ROOT.InitialState behavior
            // uml action: trace("Transition action `` for TEST2_ROOT.InitialState to TEST2_S1_1.");
            // uml transition target: TEST2_S1_1
            if (true)
            {
                trace("Transition action `` for TEST2_ROOT.InitialState to TEST2_S1_1.");
                
                // Enter towards target
                TEST2_S1_enter(self);
                TEST2_S1_1_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST2_S1_1;
                self->ancestor_event_handler = NULL;
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for TEST2_ROOT.InitialState
        } // end of behavior for TEST2_REGULAR_EVENT_TESTING.InitialState
    } // end of behavior for DECIDE
}

static void DECIDE_ev3(Spec2Sm* self)
{
    // No ancestor state handles `EV3` event.
    
    // DECIDE behavior
    // uml guard: trace_guard("State DECIDE: check behavior `EV3 TransitionTo(TEST3_BEHAVIOR_ORDERING)`.", true)
    // uml action: trace("Transition action `` for DECIDE to TEST3_BEHAVIOR_ORDERING.");
    // uml transition target: TEST3_BEHAVIOR_ORDERING
    if (trace_guard("State DECIDE: check behavior `EV3 TransitionTo(TEST3_BEHAVIOR_ORDERING)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Optimize away while-exit-loop because we know that the active leaf state is DECIDE and it is exiting directly to its parent ROOT.
        DECIDE_exit(self);
        trace("Transition action `` for DECIDE to TEST3_BEHAVIOR_ORDERING.");
        
        // Enter towards target
        TEST3_BEHAVIOR_ORDERING_enter(self);
        // TEST3_BEHAVIOR_ORDERING.InitialState behavior
        // uml action: trace("Transition action `` for TEST3_BEHAVIOR_ORDERING.InitialState to TEST3_ROOT.");
        // uml transition target: TEST3_ROOT
        if (true)
        {
            trace("Transition action `` for TEST3_BEHAVIOR_ORDERING.InitialState to TEST3_ROOT.");
            
            // Enter towards target
            TEST3_ROOT_enter(self);
            // TEST3_ROOT.InitialState behavior
            // uml action: trace("Transition action `` for TEST3_ROOT.InitialState to TEST3_S1.");
            // uml transition target: TEST3_S1
            if (true)
            {
                trace("Transition action `` for TEST3_ROOT.InitialState to TEST3_S1.");
                
                // Enter towards target
                TEST3_S1_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST3_S1;
                self->ancestor_event_handler = NULL;
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for TEST3_ROOT.InitialState
        } // end of behavior for TEST3_BEHAVIOR_ORDERING.InitialState
    } // end of behavior for DECIDE
}

static void DECIDE_ev4(Spec2Sm* self)
{
    // No ancestor state handles `EV4` event.
    
    // DECIDE behavior
    // uml guard: trace_guard("State DECIDE: check behavior `EV4 TransitionTo(TEST4_PARENT_CHILD_TRANSITIONS)`.", true)
    // uml action: trace("Transition action `` for DECIDE to TEST4_PARENT_CHILD_TRANSITIONS.");
    // uml transition target: TEST4_PARENT_CHILD_TRANSITIONS
    if (trace_guard("State DECIDE: check behavior `EV4 TransitionTo(TEST4_PARENT_CHILD_TRANSITIONS)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Optimize away while-exit-loop because we know that the active leaf state is DECIDE and it is exiting directly to its parent ROOT.
        DECIDE_exit(self);
        trace("Transition action `` for DECIDE to TEST4_PARENT_CHILD_TRANSITIONS.");
        
        // Enter towards target
        TEST4_PARENT_CHILD_TRANSITIONS_enter(self);
        // TEST4_PARENT_CHILD_TRANSITIONS.InitialState behavior
        // uml action: trace("Transition action `` for TEST4_PARENT_CHILD_TRANSITIONS.InitialState to TEST4_ROOT.");
        // uml transition target: TEST4_ROOT
        if (true)
        {
            trace("Transition action `` for TEST4_PARENT_CHILD_TRANSITIONS.InitialState to TEST4_ROOT.");
            
            // Enter towards target
            TEST4_ROOT_enter(self);
            
            // update state_id
            self->state_id = Spec2Sm_StateId_TEST4_ROOT;
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for TEST4_PARENT_CHILD_TRANSITIONS.InitialState
    } // end of behavior for DECIDE
}

static void DECIDE_ev5(Spec2Sm* self)
{
    // No ancestor state handles `EV5` event.
    
    // DECIDE behavior
    // uml guard: trace_guard("State DECIDE: check behavior `EV5 TransitionTo(TEST5_PARENT_CHILD_TRANSITIONS_ALIAS)`.", true)
    // uml action: trace("Transition action `` for DECIDE to TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.");
    // uml transition target: TEST5_PARENT_CHILD_TRANSITIONS_ALIAS
    if (trace_guard("State DECIDE: check behavior `EV5 TransitionTo(TEST5_PARENT_CHILD_TRANSITIONS_ALIAS)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Optimize away while-exit-loop because we know that the active leaf state is DECIDE and it is exiting directly to its parent ROOT.
        DECIDE_exit(self);
        trace("Transition action `` for DECIDE to TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.");
        
        // Enter towards target
        TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_enter(self);
        // TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.InitialState behavior
        // uml action: trace("Transition action `` for TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.InitialState to TEST5_ROOT.");
        // uml transition target: TEST5_ROOT
        if (true)
        {
            trace("Transition action `` for TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.InitialState to TEST5_ROOT.");
            
            // Enter towards target
            TEST5_ROOT_enter(self);
            
            // update state_id
            self->state_id = Spec2Sm_StateId_TEST5_ROOT;
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.InitialState
    } // end of behavior for DECIDE
}

static void DECIDE_ev6(Spec2Sm* self)
{
    // No ancestor state handles `EV6` event.
    
    // DECIDE behavior
    // uml guard: trace_guard("State DECIDE: check behavior `EV6 TransitionTo(TEST6_VARIABLES)`.", true)
    // uml action: trace("Transition action `` for DECIDE to TEST6_VARIABLES.");
    // uml transition target: TEST6_VARIABLES
    if (trace_guard("State DECIDE: check behavior `EV6 TransitionTo(TEST6_VARIABLES)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Optimize away while-exit-loop because we know that the active leaf state is DECIDE and it is exiting directly to its parent ROOT.
        DECIDE_exit(self);
        trace("Transition action `` for DECIDE to TEST6_VARIABLES.");
        
        // Enter towards target
        TEST6_VARIABLES_enter(self);
        // TEST6_VARIABLES.InitialState behavior
        // uml action: trace("Transition action `` for TEST6_VARIABLES.InitialState to TEST6_ROOT.");
        // uml transition target: TEST6_ROOT
        if (true)
        {
            trace("Transition action `` for TEST6_VARIABLES.InitialState to TEST6_ROOT.");
            
            // Enter towards target
            TEST6_ROOT_enter(self);
            // TEST6_ROOT.InitialState behavior
            // uml action: trace("Transition action `` for TEST6_ROOT.InitialState to TEST6_S1.");
            // uml transition target: TEST6_S1
            if (true)
            {
                trace("Transition action `` for TEST6_ROOT.InitialState to TEST6_S1.");
                
                // Enter towards target
                TEST6_S1_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST6_S1;
                self->ancestor_event_handler = NULL;
                return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
            } // end of behavior for TEST6_ROOT.InitialState
        } // end of behavior for TEST6_VARIABLES.InitialState
    } // end of behavior for DECIDE
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_DO_EVENT_TESTING
////////////////////////////////////////////////////////////////////////////////

static void TEST1_DO_EVENT_TESTING_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_DO_EVENT_TESTING_exit;
    
    // TEST1_DO_EVENT_TESTING behavior
    // uml action: trace("Enter TEST1_DO_EVENT_TESTING.");
    if (true)
    {
        trace("Enter TEST1_DO_EVENT_TESTING.");
    } // end of behavior for TEST1_DO_EVENT_TESTING
}

static void TEST1_DO_EVENT_TESTING_exit(Spec2Sm* self)
{
    // TEST1_DO_EVENT_TESTING behavior
    // uml action: trace("Exit TEST1_DO_EVENT_TESTING.");
    if (true)
    {
        trace("Exit TEST1_DO_EVENT_TESTING.");
    } // end of behavior for TEST1_DO_EVENT_TESTING
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST1_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_ROOT_do;
    
    // TEST1_ROOT behavior
    // uml action: trace("Enter TEST1_ROOT.");
    if (true)
    {
        trace("Enter TEST1_ROOT.");
    } // end of behavior for TEST1_ROOT
}

static void TEST1_ROOT_exit(Spec2Sm* self)
{
    // TEST1_ROOT behavior
    // uml action: trace("Exit TEST1_ROOT.");
    if (true)
    {
        trace("Exit TEST1_ROOT.");
    } // end of behavior for TEST1_ROOT
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST1_DO_EVENT_TESTING_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void TEST1_ROOT_do(Spec2Sm* self)
{
    // No ancestor state handles `do` event.
    
    // TEST1_ROOT behavior
    // uml guard: trace_guard("State TEST1_ROOT: check behavior `do`.", true)
    if (trace_guard("State TEST1_ROOT: check behavior `do`.", true))
    {
        bool consume_event = false; // the `do` event is special in that it normally is not consumed.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        
        
        // No ancestor handles event. Ignore `consume_event` flag.
    } // end of behavior for TEST1_ROOT
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST1_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_S1_exit;
    
    // TEST1_S1 behavior
    // uml action: trace("Enter TEST1_S1.");
    if (true)
    {
        trace("Enter TEST1_S1.");
    } // end of behavior for TEST1_S1
}

static void TEST1_S1_exit(Spec2Sm* self)
{
    // TEST1_S1 behavior
    // uml action: trace("Exit TEST1_S1.");
    if (true)
    {
        trace("Exit TEST1_S1.");
    } // end of behavior for TEST1_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST1_ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_S1_1
////////////////////////////////////////////////////////////////////////////////

static void TEST1_S1_1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_S1_1_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_S1_1_do;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST1_S1_1_ev1;
    
    // TEST1_S1_1 behavior
    // uml action: trace("Enter TEST1_S1_1.");
    if (true)
    {
        trace("Enter TEST1_S1_1.");
    } // end of behavior for TEST1_S1_1
    
    // TEST1_S1_1 behavior
    // uml guard: trace_guard("State TEST1_S1_1: check behavior `enter / { clear_output(); }`.", true)
    // uml action: clear_output();
    if (trace_guard("State TEST1_S1_1: check behavior `enter / { clear_output(); }`.", true))
    {
        trace("IGNORE_OUTPUT_BEFORE_THIS");;
    } // end of behavior for TEST1_S1_1
}

static void TEST1_S1_1_exit(Spec2Sm* self)
{
    // TEST1_S1_1 behavior
    // uml action: trace("Exit TEST1_S1_1.");
    if (true)
    {
        trace("Exit TEST1_S1_1.");
    } // end of behavior for TEST1_S1_1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST1_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_ROOT_do;  // the next ancestor that handles this event is TEST1_ROOT
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST1_S1_1_do(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `do` event.
    self->ancestor_event_handler = TEST1_ROOT_do;
    
    // TEST1_S1_1 behavior
    // uml guard: trace_guard("State TEST1_S1_1: check behavior `do`.", true)
    if (trace_guard("State TEST1_S1_1: check behavior `do`.", true))
    {
        bool consume_event = false; // the `do` event is special in that it normally is not consumed.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        
        if (consume_event)
        {
            // Mark event as handled.
            self->ancestor_event_handler = NULL;
        }
    } // end of behavior for TEST1_S1_1
}

static void TEST1_S1_1_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST1_S1_1 behavior
    // uml guard: trace_guard("State TEST1_S1_1: check behavior `EV1 TransitionTo(TEST1_S2)`.", true)
    // uml action: trace("Transition action `` for TEST1_S1_1 to TEST1_S2.");
    // uml transition target: TEST1_S2
    if (trace_guard("State TEST1_S1_1: check behavior `EV1 TransitionTo(TEST1_S2)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be TEST1_S1_1 or one of its sub states.
        exit_up_to_state_handler(self, TEST1_ROOT_exit);  // Exit until we reach TEST1_ROOT state.
        trace("Transition action `` for TEST1_S1_1 to TEST1_S2.");
        
        // Enter towards target
        TEST1_S2_enter(self);
        
        // update state_id
        self->state_id = Spec2Sm_StateId_TEST1_S2;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST1_S1_1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST1_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_S2_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_S2_do;
    
    // TEST1_S2 behavior
    // uml action: trace("Enter TEST1_S2.");
    if (true)
    {
        trace("Enter TEST1_S2.");
    } // end of behavior for TEST1_S2
}

static void TEST1_S2_exit(Spec2Sm* self)
{
    // TEST1_S2 behavior
    // uml action: trace("Exit TEST1_S2.");
    if (true)
    {
        trace("Exit TEST1_S2.");
    } // end of behavior for TEST1_S2
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST1_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_ROOT_do;  // the next ancestor that handles this event is TEST1_ROOT
}

static void TEST1_S2_do(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `do` event.
    self->ancestor_event_handler = TEST1_ROOT_do;
    
    // TEST1_S2 behavior
    // uml guard: trace_guard("State TEST1_S2: check behavior `do / { consume_event = true; }`.", true)
    // uml action: consume_event = true;
    if (trace_guard("State TEST1_S2: check behavior `do / { consume_event = true; }`.", true))
    {
        bool consume_event = false; // the `do` event is special in that it normally is not consumed.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        consume_event = true;
        
        if (consume_event)
        {
            // Mark event as handled.
            self->ancestor_event_handler = NULL;
        }
    } // end of behavior for TEST1_S2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_REGULAR_EVENT_TESTING
////////////////////////////////////////////////////////////////////////////////

static void TEST2_REGULAR_EVENT_TESTING_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_REGULAR_EVENT_TESTING_exit;
    
    // TEST2_REGULAR_EVENT_TESTING behavior
    // uml action: trace("Enter TEST2_REGULAR_EVENT_TESTING.");
    if (true)
    {
        trace("Enter TEST2_REGULAR_EVENT_TESTING.");
    } // end of behavior for TEST2_REGULAR_EVENT_TESTING
}

static void TEST2_REGULAR_EVENT_TESTING_exit(Spec2Sm* self)
{
    // TEST2_REGULAR_EVENT_TESTING behavior
    // uml action: trace("Exit TEST2_REGULAR_EVENT_TESTING.");
    if (true)
    {
        trace("Exit TEST2_REGULAR_EVENT_TESTING.");
    } // end of behavior for TEST2_REGULAR_EVENT_TESTING
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST2_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST2_ROOT_do;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_ROOT_ev1;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST2_ROOT_ev2;
    
    // TEST2_ROOT behavior
    // uml action: trace("Enter TEST2_ROOT.");
    if (true)
    {
        trace("Enter TEST2_ROOT.");
    } // end of behavior for TEST2_ROOT
}

static void TEST2_ROOT_exit(Spec2Sm* self)
{
    // TEST2_ROOT behavior
    // uml action: trace("Exit TEST2_ROOT.");
    if (true)
    {
        trace("Exit TEST2_ROOT.");
    } // end of behavior for TEST2_ROOT
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST2_REGULAR_EVENT_TESTING_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
}

static void TEST2_ROOT_do(Spec2Sm* self)
{
    // No ancestor state handles `do` event.
    
    // TEST2_ROOT behavior
    // uml guard: trace_guard("State TEST2_ROOT: check behavior `do`.", true)
    if (trace_guard("State TEST2_ROOT: check behavior `do`.", true))
    {
        bool consume_event = false; // the `do` event is special in that it normally is not consumed.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        
        
        // No ancestor handles event. Ignore `consume_event` flag.
    } // end of behavior for TEST2_ROOT
}

static void TEST2_ROOT_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST2_ROOT behavior
    // uml guard: trace_guard("State TEST2_ROOT: check behavior `EV1`.", true)
    if (trace_guard("State TEST2_ROOT: check behavior `EV1`.", true))
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        
        
        // No ancestor handles event. Ignore `consume_event` flag.
    } // end of behavior for TEST2_ROOT
}

static void TEST2_ROOT_ev2(Spec2Sm* self)
{
    // No ancestor state handles `EV2` event.
    
    // TEST2_ROOT behavior
    // uml guard: trace_guard("State TEST2_ROOT: check behavior `EV2`.", true)
    if (trace_guard("State TEST2_ROOT: check behavior `EV2`.", true))
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        
        
        // No ancestor handles event. Ignore `consume_event` flag.
    } // end of behavior for TEST2_ROOT
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST2_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_S1_exit;
    
    // TEST2_S1 behavior
    // uml action: trace("Enter TEST2_S1.");
    if (true)
    {
        trace("Enter TEST2_S1.");
    } // end of behavior for TEST2_S1
}

static void TEST2_S1_exit(Spec2Sm* self)
{
    // TEST2_S1 behavior
    // uml action: trace("Exit TEST2_S1.");
    if (true)
    {
        trace("Exit TEST2_S1.");
    } // end of behavior for TEST2_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST2_ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_S1_1
////////////////////////////////////////////////////////////////////////////////

static void TEST2_S1_1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_S1_1_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST2_S1_1_do;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_S1_1_ev1;
    
    // TEST2_S1_1 behavior
    // uml action: trace("Enter TEST2_S1_1.");
    if (true)
    {
        trace("Enter TEST2_S1_1.");
    } // end of behavior for TEST2_S1_1
    
    // TEST2_S1_1 behavior
    // uml guard: trace_guard("State TEST2_S1_1: check behavior `enter / { clear_output(); }`.", true)
    // uml action: clear_output();
    if (trace_guard("State TEST2_S1_1: check behavior `enter / { clear_output(); }`.", true))
    {
        trace("IGNORE_OUTPUT_BEFORE_THIS");;
    } // end of behavior for TEST2_S1_1
}

static void TEST2_S1_1_exit(Spec2Sm* self)
{
    // TEST2_S1_1 behavior
    // uml action: trace("Exit TEST2_S1_1.");
    if (true)
    {
        trace("Exit TEST2_S1_1.");
    } // end of behavior for TEST2_S1_1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST2_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST2_ROOT_do;  // the next ancestor that handles this event is TEST2_ROOT
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_ROOT_ev1;  // the next ancestor that handles this event is TEST2_ROOT
}

static void TEST2_S1_1_do(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `do` event.
    self->ancestor_event_handler = TEST2_ROOT_do;
    
    // TEST2_S1_1 behavior
    // uml guard: trace_guard("State TEST2_S1_1: check behavior `do TransitionTo(TEST2_S2)`.", true)
    // uml action: trace("Transition action `` for TEST2_S1_1 to TEST2_S2.");
    // uml transition target: TEST2_S2
    if (trace_guard("State TEST2_S1_1: check behavior `do TransitionTo(TEST2_S2)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be TEST2_S1_1 or one of its sub states.
        exit_up_to_state_handler(self, TEST2_ROOT_exit);  // Exit until we reach TEST2_ROOT state.
        trace("Transition action `` for TEST2_S1_1 to TEST2_S2.");
        
        // Enter towards target
        TEST2_S2_enter(self);
        
        // update state_id
        self->state_id = Spec2Sm_StateId_TEST2_S2;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST2_S1_1
}

static void TEST2_S1_1_ev1(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `EV1` event.
    self->ancestor_event_handler = TEST2_ROOT_ev1;
    
    // TEST2_S1_1 behavior
    // uml guard: trace_guard("State TEST2_S1_1: check behavior `EV1`.", true)
    if (trace_guard("State TEST2_S1_1: check behavior `EV1`.", true))
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        
        if (consume_event)
        {
            // Mark event as handled.
            self->ancestor_event_handler = NULL;
        }
    } // end of behavior for TEST2_S1_1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST2_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_S2_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_S2_ev1;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST2_S2_ev2;
    
    // TEST2_S2 behavior
    // uml action: trace("Enter TEST2_S2.");
    if (true)
    {
        trace("Enter TEST2_S2.");
    } // end of behavior for TEST2_S2
}

static void TEST2_S2_exit(Spec2Sm* self)
{
    // TEST2_S2 behavior
    // uml action: trace("Exit TEST2_S2.");
    if (true)
    {
        trace("Exit TEST2_S2.");
    } // end of behavior for TEST2_S2
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST2_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_ROOT_ev1;  // the next ancestor that handles this event is TEST2_ROOT
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST2_ROOT_ev2;  // the next ancestor that handles this event is TEST2_ROOT
}

static void TEST2_S2_ev1(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `EV1` event.
    self->ancestor_event_handler = TEST2_ROOT_ev1;
    
    // TEST2_S2 behavior
    // uml guard: trace_guard("State TEST2_S2: check behavior `EV1 / { consume_event = false; }`.", true)
    // uml action: consume_event = false;
    if (trace_guard("State TEST2_S2: check behavior `EV1 / { consume_event = false; }`.", true))
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        consume_event = false;
        
        if (consume_event)
        {
            // Mark event as handled.
            self->ancestor_event_handler = NULL;
        }
    } // end of behavior for TEST2_S2
}

static void TEST2_S2_ev2(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `EV2` event.
    self->ancestor_event_handler = TEST2_ROOT_ev2;
    
    // TEST2_S2 behavior
    // uml guard: trace_guard("State TEST2_S2: check behavior `EV2 TransitionTo(TEST2_S2)`.", true)
    // uml action: trace("Transition action `` for TEST2_S2 to TEST2_S2.");
    // uml transition target: TEST2_S2
    if (trace_guard("State TEST2_S2: check behavior `EV2 TransitionTo(TEST2_S2)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Optimize away while-exit-loop because we know that the active leaf state is TEST2_S2 and it is exiting directly to its parent TEST2_ROOT.
        TEST2_S2_exit(self);
        trace("Transition action `` for TEST2_S2 to TEST2_S2.");
        
        // Enter towards target
        TEST2_S2_enter(self);
        
        // update state_id
        self->state_id = Spec2Sm_StateId_TEST2_S2;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST2_S2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_BEHAVIOR_ORDERING
////////////////////////////////////////////////////////////////////////////////

static void TEST3_BEHAVIOR_ORDERING_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_BEHAVIOR_ORDERING_exit;
    
    // TEST3_BEHAVIOR_ORDERING behavior
    // uml action: trace("Enter TEST3_BEHAVIOR_ORDERING.");
    if (true)
    {
        trace("Enter TEST3_BEHAVIOR_ORDERING.");
    } // end of behavior for TEST3_BEHAVIOR_ORDERING
}

static void TEST3_BEHAVIOR_ORDERING_exit(Spec2Sm* self)
{
    // TEST3_BEHAVIOR_ORDERING behavior
    // uml action: trace("Exit TEST3_BEHAVIOR_ORDERING.");
    if (true)
    {
        trace("Exit TEST3_BEHAVIOR_ORDERING.");
    } // end of behavior for TEST3_BEHAVIOR_ORDERING
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST3_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_ROOT_ev1;
    
    // TEST3_ROOT behavior
    // uml action: trace("Enter TEST3_ROOT.");
    if (true)
    {
        trace("Enter TEST3_ROOT.");
    } // end of behavior for TEST3_ROOT
}

static void TEST3_ROOT_exit(Spec2Sm* self)
{
    // TEST3_ROOT behavior
    // uml action: trace("Exit TEST3_ROOT.");
    if (true)
    {
        trace("Exit TEST3_ROOT.");
    } // end of behavior for TEST3_ROOT
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST3_BEHAVIOR_ORDERING_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST3_ROOT_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST3_ROOT behavior
    // uml guard: trace_guard("State TEST3_ROOT: check behavior `EV1`.", true)
    if (trace_guard("State TEST3_ROOT: check behavior `EV1`.", true))
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        
        
        // No ancestor handles event. Ignore `consume_event` flag.
    } // end of behavior for TEST3_ROOT
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST3_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_S1_ev1;
    
    // TEST3_S1 behavior
    // uml action: trace("Enter TEST3_S1.");
    if (true)
    {
        trace("Enter TEST3_S1.");
    } // end of behavior for TEST3_S1
    
    // TEST3_S1 behavior
    // uml guard: trace_guard("State TEST3_S1: check behavior `enter / { clear_output(); }`.", true)
    // uml action: clear_output();
    if (trace_guard("State TEST3_S1: check behavior `enter / { clear_output(); }`.", true))
    {
        trace("IGNORE_OUTPUT_BEFORE_THIS");;
    } // end of behavior for TEST3_S1
}

static void TEST3_S1_exit(Spec2Sm* self)
{
    // TEST3_S1 behavior
    // uml action: trace("Exit TEST3_S1.");
    if (true)
    {
        trace("Exit TEST3_S1.");
    } // end of behavior for TEST3_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST3_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_ROOT_ev1;  // the next ancestor that handles this event is TEST3_ROOT
}

static void TEST3_S1_ev1(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `EV1` event.
    self->ancestor_event_handler = TEST3_ROOT_ev1;
    
    // TEST3_S1 behavior
    // uml guard: trace_guard("State TEST3_S1: check behavior `1. EV1 TransitionTo(TEST3_S2)`.", true)
    // uml action: trace("Transition action `` for TEST3_S1 to TEST3_S2.");
    // uml transition target: TEST3_S2
    if (trace_guard("State TEST3_S1: check behavior `1. EV1 TransitionTo(TEST3_S2)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Optimize away while-exit-loop because we know that the active leaf state is TEST3_S1 and it is exiting directly to its parent TEST3_ROOT.
        TEST3_S1_exit(self);
        trace("Transition action `` for TEST3_S1 to TEST3_S2.");
        
        // Enter towards target
        TEST3_S2_enter(self);
        
        // update state_id
        self->state_id = Spec2Sm_StateId_TEST3_S2;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST3_S1
    
    // TEST3_S1 behavior
    // uml guard: trace_guard("State TEST3_S1: check behavior `2. EV1 / { trace(\"failed\"); }`.", true)
    // uml action: trace("failed");
    if (trace_guard("State TEST3_S1: check behavior `2. EV1 / { trace(\"failed\"); }`.", true))
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        trace("failed");
        
        if (consume_event)
        {
            // Mark event as handled.
            self->ancestor_event_handler = NULL;
        }
    } // end of behavior for TEST3_S1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST3_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_S2_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_S2_ev1;
    
    // TEST3_S2 behavior
    // uml action: trace("Enter TEST3_S2.");
    if (true)
    {
        trace("Enter TEST3_S2.");
    } // end of behavior for TEST3_S2
}

static void TEST3_S2_exit(Spec2Sm* self)
{
    // TEST3_S2 behavior
    // uml action: trace("Exit TEST3_S2.");
    if (true)
    {
        trace("Exit TEST3_S2.");
    } // end of behavior for TEST3_S2
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST3_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_ROOT_ev1;  // the next ancestor that handles this event is TEST3_ROOT
}

static void TEST3_S2_ev1(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `EV1` event.
    self->ancestor_event_handler = TEST3_ROOT_ev1;
    
    // TEST3_S2 behavior
    // uml guard: trace_guard("State TEST3_S2: check behavior `1. EV1 / { trace(\"1 woot!\"); }`.", true)
    // uml action: trace("1 woot!");
    if (trace_guard("State TEST3_S2: check behavior `1. EV1 / { trace(\"1 woot!\"); }`.", true))
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        trace("1 woot!");
        
        if (consume_event)
        {
            // Mark event as handled.
            self->ancestor_event_handler = NULL;
        }
    } // end of behavior for TEST3_S2
    
    // TEST3_S2 behavior
    // uml guard: trace_guard("State TEST3_S2: check behavior `1.1. EV1 / { trace(\"2 woot!\"); }`.", true)
    // uml action: trace("2 woot!");
    if (trace_guard("State TEST3_S2: check behavior `1.1. EV1 / { trace(\"2 woot!\"); }`.", true))
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        trace("2 woot!");
        
        if (consume_event)
        {
            // Mark event as handled.
            self->ancestor_event_handler = NULL;
        }
    } // end of behavior for TEST3_S2
    
    // TEST3_S2 behavior
    // uml guard: trace_guard("State TEST3_S2: check behavior `2. EV1 / { trace(\"3 woot!\"); } TransitionTo(TEST3_S3)`.", true)
    // uml action: trace("Transition action `trace(\"3 woot!\");` for TEST3_S2 to TEST3_S3.");
    //             trace("3 woot!");
    // uml transition target: TEST3_S3
    if (trace_guard("State TEST3_S2: check behavior `2. EV1 / { trace(\"3 woot!\"); } TransitionTo(TEST3_S3)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Optimize away while-exit-loop because we know that the active leaf state is TEST3_S2 and it is exiting directly to its parent TEST3_ROOT.
        TEST3_S2_exit(self);
        trace("Transition action `trace(\"3 woot!\");` for TEST3_S2 to TEST3_S3.");
        trace("3 woot!");
        
        // Enter towards target
        TEST3_S3_enter(self);
        
        // update state_id
        self->state_id = Spec2Sm_StateId_TEST3_S3;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST3_S2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_S3
////////////////////////////////////////////////////////////////////////////////

static void TEST3_S3_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_S3_exit;
    
    // TEST3_S3 behavior
    // uml action: trace("Enter TEST3_S3.");
    if (true)
    {
        trace("Enter TEST3_S3.");
    } // end of behavior for TEST3_S3
}

static void TEST3_S3_exit(Spec2Sm* self)
{
    // TEST3_S3 behavior
    // uml action: trace("Exit TEST3_S3.");
    if (true)
    {
        trace("Exit TEST3_S3.");
    } // end of behavior for TEST3_S3
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST3_ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_PARENT_CHILD_TRANSITIONS
////////////////////////////////////////////////////////////////////////////////

static void TEST4_PARENT_CHILD_TRANSITIONS_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_PARENT_CHILD_TRANSITIONS_exit;
    
    // TEST4_PARENT_CHILD_TRANSITIONS behavior
    // uml action: trace("Enter TEST4_PARENT_CHILD_TRANSITIONS.");
    if (true)
    {
        trace("Enter TEST4_PARENT_CHILD_TRANSITIONS.");
    } // end of behavior for TEST4_PARENT_CHILD_TRANSITIONS
}

static void TEST4_PARENT_CHILD_TRANSITIONS_exit(Spec2Sm* self)
{
    // TEST4_PARENT_CHILD_TRANSITIONS behavior
    // uml action: trace("Exit TEST4_PARENT_CHILD_TRANSITIONS.");
    if (true)
    {
        trace("Exit TEST4_PARENT_CHILD_TRANSITIONS.");
    } // end of behavior for TEST4_PARENT_CHILD_TRANSITIONS
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST4_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST4_ROOT_ev2;
    self->current_event_handlers[Spec2Sm_EventId_EV3] = TEST4_ROOT_ev3;
    self->current_event_handlers[Spec2Sm_EventId_EV4] = TEST4_ROOT_ev4;
    
    // TEST4_ROOT behavior
    // uml action: trace("Enter TEST4_ROOT.");
    if (true)
    {
        trace("Enter TEST4_ROOT.");
    } // end of behavior for TEST4_ROOT
    
    // TEST4_ROOT behavior
    // uml guard: trace_guard("State TEST4_ROOT: check behavior `enter / { clear_output(); }`.", true)
    // uml action: clear_output();
    if (trace_guard("State TEST4_ROOT: check behavior `enter / { clear_output(); }`.", true))
    {
        trace("IGNORE_OUTPUT_BEFORE_THIS");;
    } // end of behavior for TEST4_ROOT
}

static void TEST4_ROOT_exit(Spec2Sm* self)
{
    // TEST4_ROOT behavior
    // uml action: trace("Exit TEST4_ROOT.");
    if (true)
    {
        trace("Exit TEST4_ROOT.");
    } // end of behavior for TEST4_ROOT
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_PARENT_CHILD_TRANSITIONS_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV3] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV4] = NULL;  // no ancestor listens to this event
}

static void TEST4_ROOT_ev2(Spec2Sm* self)
{
    // No ancestor state handles `EV2` event.
    
    // TEST4_ROOT behavior
    // uml guard: trace_guard("State TEST4_ROOT: check behavior `EV2 TransitionTo(TEST4_S1)`.", true)
    // uml action: trace("Transition action `` for TEST4_ROOT to TEST4_S1.");
    // uml transition target: TEST4_S1
    if (trace_guard("State TEST4_ROOT: check behavior `EV2 TransitionTo(TEST4_S1)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be TEST4_ROOT or one of its sub states.
        exit_up_to_state_handler(self, TEST4_ROOT_exit);  // Exit until we reach TEST4_ROOT state.
        trace("Transition action `` for TEST4_ROOT to TEST4_S1.");
        
        // Enter towards target
        TEST4_S1_enter(self);
        
        // update state_id
        self->state_id = Spec2Sm_StateId_TEST4_S1;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST4_ROOT
}

static void TEST4_ROOT_ev3(Spec2Sm* self)
{
    // No ancestor state handles `EV3` event.
    
    // TEST4_ROOT behavior
    // uml guard: trace_guard("State TEST4_ROOT: check behavior `EV3 TransitionTo(TEST4_S10_1)`.", true)
    // uml action: trace("Transition action `` for TEST4_ROOT to TEST4_S10_1.");
    // uml transition target: TEST4_S10_1
    if (trace_guard("State TEST4_ROOT: check behavior `EV3 TransitionTo(TEST4_S10_1)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be TEST4_ROOT or one of its sub states.
        exit_up_to_state_handler(self, TEST4_ROOT_exit);  // Exit until we reach TEST4_ROOT state.
        trace("Transition action `` for TEST4_ROOT to TEST4_S10_1.");
        
        // Enter towards target
        TEST4_S10_enter(self);
        TEST4_S10_1_enter(self);
        
        // update state_id
        self->state_id = Spec2Sm_StateId_TEST4_S10_1;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST4_ROOT
}

static void TEST4_ROOT_ev4(Spec2Sm* self)
{
    // No ancestor state handles `EV4` event.
    
    // TEST4_ROOT behavior
    // uml guard: trace_guard("State TEST4_ROOT: check behavior `EV4 TransitionTo(TEST4_S20)`.", true)
    // uml action: trace("Transition action `` for TEST4_ROOT to TEST4_S20.");
    // uml transition target: TEST4_S20
    if (trace_guard("State TEST4_ROOT: check behavior `EV4 TransitionTo(TEST4_S20)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be TEST4_ROOT or one of its sub states.
        exit_up_to_state_handler(self, TEST4_ROOT_exit);  // Exit until we reach TEST4_ROOT state.
        trace("Transition action `` for TEST4_ROOT to TEST4_S20.");
        
        // Enter towards target
        TEST4_S20_enter(self);
        // TEST4_S20.InitialState behavior
        // uml action: trace("Transition action `` for TEST4_S20.InitialState to TEST4_S20_1.");
        // uml transition target: TEST4_S20_1
        if (true)
        {
            trace("Transition action `` for TEST4_S20.InitialState to TEST4_S20_1.");
            
            // Enter towards target
            TEST4_S20_1_enter(self);
            
            // update state_id
            self->state_id = Spec2Sm_StateId_TEST4_S20_1;
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for TEST4_S20.InitialState
    } // end of behavior for TEST4_ROOT
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST4_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST4_S1_ev1;
    
    // TEST4_S1 behavior
    // uml action: trace("Enter TEST4_S1.");
    if (true)
    {
        trace("Enter TEST4_S1.");
    } // end of behavior for TEST4_S1
}

static void TEST4_S1_exit(Spec2Sm* self)
{
    // TEST4_S1 behavior
    // uml action: trace("Exit TEST4_S1.");
    if (true)
    {
        trace("Exit TEST4_S1.");
    } // end of behavior for TEST4_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST4_S1_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST4_S1 behavior
    // uml guard: trace_guard("State TEST4_S1: check behavior `EV1 TransitionTo(TEST4_S2)`.", true)
    // uml action: trace("Transition action `` for TEST4_S1 to TEST4_S2.");
    // uml transition target: TEST4_S2
    if (trace_guard("State TEST4_S1: check behavior `EV1 TransitionTo(TEST4_S2)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Optimize away while-exit-loop because we know that the active leaf state is TEST4_S1 and it is exiting directly to its parent TEST4_ROOT.
        TEST4_S1_exit(self);
        trace("Transition action `` for TEST4_S1 to TEST4_S2.");
        
        // Enter towards target
        TEST4_S2_enter(self);
        
        // update state_id
        self->state_id = Spec2Sm_StateId_TEST4_S2;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST4_S1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_S10
////////////////////////////////////////////////////////////////////////////////

static void TEST4_S10_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_S10_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV4] = TEST4_S10_ev4;
    
    // TEST4_S10 behavior
    // uml action: trace("Enter TEST4_S10.");
    if (true)
    {
        trace("Enter TEST4_S10.");
    } // end of behavior for TEST4_S10
}

static void TEST4_S10_exit(Spec2Sm* self)
{
    // TEST4_S10 behavior
    // uml action: trace("Exit TEST4_S10.");
    if (true)
    {
        trace("Exit TEST4_S10.");
    } // end of behavior for TEST4_S10
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV4] = TEST4_ROOT_ev4;  // the next ancestor that handles this event is TEST4_ROOT
}

static void TEST4_S10_ev4(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `EV4` event.
    self->ancestor_event_handler = TEST4_ROOT_ev4;
    
    // TEST4_S10 behavior
    // uml guard: trace_guard("State TEST4_S10: check behavior `EV4 TransitionTo(TEST4_S10)`.", true)
    // uml action: trace("Transition action `` for TEST4_S10 to TEST4_S10.");
    // uml transition target: TEST4_S10
    if (trace_guard("State TEST4_S10: check behavior `EV4 TransitionTo(TEST4_S10)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be TEST4_S10 or one of its sub states.
        exit_up_to_state_handler(self, TEST4_ROOT_exit);  // Exit until we reach TEST4_ROOT state.
        trace("Transition action `` for TEST4_S10 to TEST4_S10.");
        
        // Enter towards target
        TEST4_S10_enter(self);
        
        // update state_id
        self->state_id = Spec2Sm_StateId_TEST4_S10;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST4_S10
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_S10_1
////////////////////////////////////////////////////////////////////////////////

static void TEST4_S10_1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_S10_1_exit;
    
    // TEST4_S10_1 behavior
    // uml action: trace("Enter TEST4_S10_1.");
    if (true)
    {
        trace("Enter TEST4_S10_1.");
    } // end of behavior for TEST4_S10_1
}

static void TEST4_S10_1_exit(Spec2Sm* self)
{
    // TEST4_S10_1 behavior
    // uml action: trace("Exit TEST4_S10_1.");
    if (true)
    {
        trace("Exit TEST4_S10_1.");
    } // end of behavior for TEST4_S10_1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_S10_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST4_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_S2_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST4_S2_ev1;
    
    // TEST4_S2 behavior
    // uml action: trace("Enter TEST4_S2.");
    if (true)
    {
        trace("Enter TEST4_S2.");
    } // end of behavior for TEST4_S2
}

static void TEST4_S2_exit(Spec2Sm* self)
{
    // TEST4_S2 behavior
    // uml action: trace("Exit TEST4_S2.");
    if (true)
    {
        trace("Exit TEST4_S2.");
    } // end of behavior for TEST4_S2
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST4_S2_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST4_S2 behavior
    // uml guard: trace_guard("State TEST4_S2: check behavior `EV1 TransitionTo(TEST4_S3)`.", true)
    // uml action: trace("Transition action `` for TEST4_S2 to TEST4_S3.");
    // uml transition target: TEST4_S3
    if (trace_guard("State TEST4_S2: check behavior `EV1 TransitionTo(TEST4_S3)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Optimize away while-exit-loop because we know that the active leaf state is TEST4_S2 and it is exiting directly to its parent TEST4_ROOT.
        TEST4_S2_exit(self);
        trace("Transition action `` for TEST4_S2 to TEST4_S3.");
        
        // Enter towards target
        TEST4_S3_enter(self);
        
        // update state_id
        self->state_id = Spec2Sm_StateId_TEST4_S3;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST4_S2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_S20
////////////////////////////////////////////////////////////////////////////////

static void TEST4_S20_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_S20_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV4] = TEST4_S20_ev4;
    
    // TEST4_S20 behavior
    // uml action: trace("Enter TEST4_S20.");
    if (true)
    {
        trace("Enter TEST4_S20.");
    } // end of behavior for TEST4_S20
}

static void TEST4_S20_exit(Spec2Sm* self)
{
    // TEST4_S20 behavior
    // uml action: trace("Exit TEST4_S20.");
    if (true)
    {
        trace("Exit TEST4_S20.");
    } // end of behavior for TEST4_S20
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV4] = TEST4_ROOT_ev4;  // the next ancestor that handles this event is TEST4_ROOT
}

static void TEST4_S20_ev4(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `EV4` event.
    self->ancestor_event_handler = TEST4_ROOT_ev4;
    
    // TEST4_S20 behavior
    // uml guard: trace_guard("State TEST4_S20: check behavior `EV4 TransitionTo(TEST4_S20)`.", true)
    // uml action: trace("Transition action `` for TEST4_S20 to TEST4_S20.");
    // uml transition target: TEST4_S20
    if (trace_guard("State TEST4_S20: check behavior `EV4 TransitionTo(TEST4_S20)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be TEST4_S20 or one of its sub states.
        exit_up_to_state_handler(self, TEST4_ROOT_exit);  // Exit until we reach TEST4_ROOT state.
        trace("Transition action `` for TEST4_S20 to TEST4_S20.");
        
        // Enter towards target
        TEST4_S20_enter(self);
        // TEST4_S20.InitialState behavior
        // uml action: trace("Transition action `` for TEST4_S20.InitialState to TEST4_S20_1.");
        // uml transition target: TEST4_S20_1
        if (true)
        {
            trace("Transition action `` for TEST4_S20.InitialState to TEST4_S20_1.");
            
            // Enter towards target
            TEST4_S20_1_enter(self);
            
            // update state_id
            self->state_id = Spec2Sm_StateId_TEST4_S20_1;
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for TEST4_S20.InitialState
    } // end of behavior for TEST4_S20
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_S20_1
////////////////////////////////////////////////////////////////////////////////

static void TEST4_S20_1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_S20_1_exit;
    
    // TEST4_S20_1 behavior
    // uml action: trace("Enter TEST4_S20_1.");
    if (true)
    {
        trace("Enter TEST4_S20_1.");
    } // end of behavior for TEST4_S20_1
}

static void TEST4_S20_1_exit(Spec2Sm* self)
{
    // TEST4_S20_1 behavior
    // uml action: trace("Exit TEST4_S20_1.");
    if (true)
    {
        trace("Exit TEST4_S20_1.");
    } // end of behavior for TEST4_S20_1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_S20_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_S3
////////////////////////////////////////////////////////////////////////////////

static void TEST4_S3_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_S3_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST4_S3_ev1;
    
    // TEST4_S3 behavior
    // uml action: trace("Enter TEST4_S3.");
    if (true)
    {
        trace("Enter TEST4_S3.");
    } // end of behavior for TEST4_S3
}

static void TEST4_S3_exit(Spec2Sm* self)
{
    // TEST4_S3 behavior
    // uml action: trace("Exit TEST4_S3.");
    if (true)
    {
        trace("Exit TEST4_S3.");
    } // end of behavior for TEST4_S3
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST4_S3_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST4_S3 behavior
    // uml guard: trace_guard("State TEST4_S3: check behavior `EV1 TransitionTo(TEST4_ROOT)`.", true)
    // uml action: trace("Transition action `` for TEST4_S3 to TEST4_ROOT.");
    // uml transition target: TEST4_ROOT
    if (trace_guard("State TEST4_S3: check behavior `EV1 TransitionTo(TEST4_ROOT)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Optimize away while-exit-loop because we know that the active leaf state is TEST4_S3 and it is exiting directly to its parent TEST4_ROOT.
        TEST4_S3_exit(self);
        trace("Transition action `` for TEST4_S3 to TEST4_ROOT.");
        
        // Enter towards target
        
        // update state_id
        self->state_id = Spec2Sm_StateId_TEST4_ROOT;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST4_S3
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST5_PARENT_CHILD_TRANSITIONS_ALIAS
////////////////////////////////////////////////////////////////////////////////

static void TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_exit;
    
    // TEST5_PARENT_CHILD_TRANSITIONS_ALIAS behavior
    // uml action: trace("Enter TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.");
    if (true)
    {
        trace("Enter TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.");
    } // end of behavior for TEST5_PARENT_CHILD_TRANSITIONS_ALIAS
}

static void TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_exit(Spec2Sm* self)
{
    // TEST5_PARENT_CHILD_TRANSITIONS_ALIAS behavior
    // uml action: trace("Exit TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.");
    if (true)
    {
        trace("Exit TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.");
    } // end of behavior for TEST5_PARENT_CHILD_TRANSITIONS_ALIAS
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST5_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST5_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST5_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST5_ROOT_ev2;
    
    // TEST5_ROOT behavior
    // uml action: trace("Enter TEST5_ROOT.");
    if (true)
    {
        trace("Enter TEST5_ROOT.");
    } // end of behavior for TEST5_ROOT
    
    // TEST5_ROOT behavior
    // uml guard: trace_guard("State TEST5_ROOT: check behavior `enter / { clear_output(); }`.", true)
    // uml action: clear_output();
    if (trace_guard("State TEST5_ROOT: check behavior `enter / { clear_output(); }`.", true))
    {
        trace("IGNORE_OUTPUT_BEFORE_THIS");;
    } // end of behavior for TEST5_ROOT
}

static void TEST5_ROOT_exit(Spec2Sm* self)
{
    // TEST5_ROOT behavior
    // uml action: trace("Exit TEST5_ROOT.");
    if (true)
    {
        trace("Exit TEST5_ROOT.");
    } // end of behavior for TEST5_ROOT
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
}

static void TEST5_ROOT_ev2(Spec2Sm* self)
{
    // No ancestor state handles `EV2` event.
    
    // TEST5_ROOT behavior
    // uml guard: trace_guard("State TEST5_ROOT: check behavior `EV2 TransitionTo(TEST5_S1)`.", true)
    // uml action: trace("Transition action `` for TEST5_ROOT to TEST5_S1.");
    // uml transition target: TEST5_S1
    if (trace_guard("State TEST5_ROOT: check behavior `EV2 TransitionTo(TEST5_S1)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // At this point, StateSmith doesn't know what the active leaf state is. It could be TEST5_ROOT or one of its sub states.
        exit_up_to_state_handler(self, TEST5_ROOT_exit);  // Exit until we reach TEST5_ROOT state.
        trace("Transition action `` for TEST5_ROOT to TEST5_S1.");
        
        // Enter towards target
        TEST5_S1_enter(self);
        
        // update state_id
        self->state_id = Spec2Sm_StateId_TEST5_S1;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST5_ROOT
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST5_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST5_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST5_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST5_S1_ev1;
    
    // TEST5_S1 behavior
    // uml action: trace("Enter TEST5_S1.");
    if (true)
    {
        trace("Enter TEST5_S1.");
    } // end of behavior for TEST5_S1
}

static void TEST5_S1_exit(Spec2Sm* self)
{
    // TEST5_S1 behavior
    // uml action: trace("Exit TEST5_S1.");
    if (true)
    {
        trace("Exit TEST5_S1.");
    } // end of behavior for TEST5_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST5_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST5_S1_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST5_S1 behavior
    // uml guard: trace_guard("State TEST5_S1: check behavior `EV1 TransitionTo(TEST5_S2)`.", true)
    // uml action: trace("Transition action `` for TEST5_S1 to TEST5_S2.");
    // uml transition target: TEST5_S2
    if (trace_guard("State TEST5_S1: check behavior `EV1 TransitionTo(TEST5_S2)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Optimize away while-exit-loop because we know that the active leaf state is TEST5_S1 and it is exiting directly to its parent TEST5_ROOT.
        TEST5_S1_exit(self);
        trace("Transition action `` for TEST5_S1 to TEST5_S2.");
        
        // Enter towards target
        TEST5_S2_enter(self);
        
        // update state_id
        self->state_id = Spec2Sm_StateId_TEST5_S2;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST5_S1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST5_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST5_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST5_S2_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST5_S2_ev1;
    
    // TEST5_S2 behavior
    // uml action: trace("Enter TEST5_S2.");
    if (true)
    {
        trace("Enter TEST5_S2.");
    } // end of behavior for TEST5_S2
}

static void TEST5_S2_exit(Spec2Sm* self)
{
    // TEST5_S2 behavior
    // uml action: trace("Exit TEST5_S2.");
    if (true)
    {
        trace("Exit TEST5_S2.");
    } // end of behavior for TEST5_S2
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST5_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST5_S2_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST5_S2 behavior
    // uml guard: trace_guard("State TEST5_S2: check behavior `EV1 TransitionTo(TEST5_S3)`.", true)
    // uml action: trace("Transition action `` for TEST5_S2 to TEST5_S3.");
    // uml transition target: TEST5_S3
    if (trace_guard("State TEST5_S2: check behavior `EV1 TransitionTo(TEST5_S3)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Optimize away while-exit-loop because we know that the active leaf state is TEST5_S2 and it is exiting directly to its parent TEST5_ROOT.
        TEST5_S2_exit(self);
        trace("Transition action `` for TEST5_S2 to TEST5_S3.");
        
        // Enter towards target
        TEST5_S3_enter(self);
        
        // update state_id
        self->state_id = Spec2Sm_StateId_TEST5_S3;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST5_S2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST5_S3
////////////////////////////////////////////////////////////////////////////////

static void TEST5_S3_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST5_S3_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST5_S3_ev1;
    
    // TEST5_S3 behavior
    // uml action: trace("Enter TEST5_S3.");
    if (true)
    {
        trace("Enter TEST5_S3.");
    } // end of behavior for TEST5_S3
}

static void TEST5_S3_exit(Spec2Sm* self)
{
    // TEST5_S3 behavior
    // uml action: trace("Exit TEST5_S3.");
    if (true)
    {
        trace("Exit TEST5_S3.");
    } // end of behavior for TEST5_S3
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST5_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST5_S3_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST5_S3 behavior
    // uml guard: trace_guard("State TEST5_S3: check behavior `EV1 TransitionTo(TEST5_ROOT)`.", true)
    // uml action: trace("Transition action `` for TEST5_S3 to TEST5_ROOT.");
    // uml transition target: TEST5_ROOT
    if (trace_guard("State TEST5_S3: check behavior `EV1 TransitionTo(TEST5_ROOT)`.", true))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Optimize away while-exit-loop because we know that the active leaf state is TEST5_S3 and it is exiting directly to its parent TEST5_ROOT.
        TEST5_S3_exit(self);
        trace("Transition action `` for TEST5_S3 to TEST5_ROOT.");
        
        // Enter towards target
        
        // update state_id
        self->state_id = Spec2Sm_StateId_TEST5_ROOT;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST5_S3
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST6_VARIABLES
////////////////////////////////////////////////////////////////////////////////

static void TEST6_VARIABLES_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST6_VARIABLES_exit;
    
    // TEST6_VARIABLES behavior
    // uml action: trace("Enter TEST6_VARIABLES.");
    if (true)
    {
        trace("Enter TEST6_VARIABLES.");
    } // end of behavior for TEST6_VARIABLES
}

static void TEST6_VARIABLES_exit(Spec2Sm* self)
{
    // TEST6_VARIABLES behavior
    // uml action: trace("Exit TEST6_VARIABLES.");
    if (true)
    {
        trace("Exit TEST6_VARIABLES.");
    } // end of behavior for TEST6_VARIABLES
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST6_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST6_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST6_ROOT_exit;
    
    // TEST6_ROOT behavior
    // uml action: trace("Enter TEST6_ROOT.");
    if (true)
    {
        trace("Enter TEST6_ROOT.");
    } // end of behavior for TEST6_ROOT
}

static void TEST6_ROOT_exit(Spec2Sm* self)
{
    // TEST6_ROOT behavior
    // uml action: trace("Exit TEST6_ROOT.");
    if (true)
    {
        trace("Exit TEST6_ROOT.");
    } // end of behavior for TEST6_ROOT
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST6_VARIABLES_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST6_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST6_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST6_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST6_S1_ev1;
    
    // TEST6_S1 behavior
    // uml action: trace("Enter TEST6_S1.");
    if (true)
    {
        trace("Enter TEST6_S1.");
    } // end of behavior for TEST6_S1
    
    // TEST6_S1 behavior
    // uml guard: trace_guard("State TEST6_S1: check behavior `enter / { clear_output(); }`.", true)
    // uml action: clear_output();
    if (trace_guard("State TEST6_S1: check behavior `enter / { clear_output(); }`.", true))
    {
        trace("IGNORE_OUTPUT_BEFORE_THIS");;
    } // end of behavior for TEST6_S1
}

static void TEST6_S1_exit(Spec2Sm* self)
{
    // TEST6_S1 behavior
    // uml action: trace("Exit TEST6_S1.");
    if (true)
    {
        trace("Exit TEST6_S1.");
    } // end of behavior for TEST6_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST6_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST6_S1_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST6_S1 behavior
    // uml guard: trace_guard("State TEST6_S1: check behavior `1. EV1 / { count++; }`.", true)
    // uml action: count++;
    if (trace_guard("State TEST6_S1: check behavior `1. EV1 / { count++; }`.", true))
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        
        self->vars.count++;
        
        // No ancestor handles event. Ignore `consume_event` flag.
    } // end of behavior for TEST6_S1
    
    // TEST6_S1 behavior
    // uml guard: trace_guard("State TEST6_S1: check behavior `2. EV1 [count >= 2] TransitionTo(TEST6_S2)`.", count >= 2)
    // uml action: trace("Transition action `` for TEST6_S1 to TEST6_S2.");
    // uml transition target: TEST6_S2
    if (trace_guard("State TEST6_S1: check behavior `2. EV1 [count >= 2] TransitionTo(TEST6_S2)`.", self->vars.count >= 2))
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // Optimize away while-exit-loop because we know that the active leaf state is TEST6_S1 and it is exiting directly to its parent TEST6_ROOT.
        TEST6_S1_exit(self);
        trace("Transition action `` for TEST6_S1 to TEST6_S2.");
        
        // Enter towards target
        TEST6_S2_enter(self);
        
        // update state_id
        self->state_id = Spec2Sm_StateId_TEST6_S2;
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST6_S1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST6_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST6_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST6_S2_exit;
    
    // TEST6_S2 behavior
    // uml action: trace("Enter TEST6_S2.");
    if (true)
    {
        trace("Enter TEST6_S2.");
    } // end of behavior for TEST6_S2
}

static void TEST6_S2_exit(Spec2Sm* self)
{
    // TEST6_S2 behavior
    // uml action: trace("Exit TEST6_S2.");
    if (true)
    {
        trace("Exit TEST6_S2.");
    } // end of behavior for TEST6_S2
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST6_ROOT_exit;
}


