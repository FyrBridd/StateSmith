// Autogenerated with StateSmith
#include "Spec2Sm.h"
#include "../../lang-helpers/c/helper.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

static void ROOT_enter(Spec2Sm* self);
static void ROOT_exit(Spec2Sm* self);

static void DECIDE_enter(Spec2Sm* self);
static void DECIDE_exit(Spec2Sm* self);
static void DECIDE_ev1(Spec2Sm* self);
static void DECIDE_ev2(Spec2Sm* self);
static void DECIDE_ev3(Spec2Sm* self);
static void DECIDE_ev4(Spec2Sm* self);
static void DECIDE_ev5(Spec2Sm* self);
static void DECIDE_ev6(Spec2Sm* self);

static void TEST1_DO_EVENT_TESTING_enter(Spec2Sm* self);
static void TEST1_DO_EVENT_TESTING_exit(Spec2Sm* self);

static void TEST1_ROOT_enter(Spec2Sm* self);
static void TEST1_ROOT_exit(Spec2Sm* self);
static void TEST1_ROOT_do(Spec2Sm* self);

static void TEST1_S1_enter(Spec2Sm* self);
static void TEST1_S1_exit(Spec2Sm* self);

static void TEST1_S1_1_enter(Spec2Sm* self);
static void TEST1_S1_1_exit(Spec2Sm* self);
static void TEST1_S1_1_do(Spec2Sm* self);
static void TEST1_S1_1_ev1(Spec2Sm* self);

static void TEST1_S2_enter(Spec2Sm* self);
static void TEST1_S2_exit(Spec2Sm* self);
static void TEST1_S2_do(Spec2Sm* self);

static void TEST2_REGULAR_EVENT_TESTING_enter(Spec2Sm* self);
static void TEST2_REGULAR_EVENT_TESTING_exit(Spec2Sm* self);

static void TEST2_ROOT_enter(Spec2Sm* self);
static void TEST2_ROOT_exit(Spec2Sm* self);
static void TEST2_ROOT_do(Spec2Sm* self);
static void TEST2_ROOT_ev1(Spec2Sm* self);
static void TEST2_ROOT_ev2(Spec2Sm* self);

static void TEST2_S1_enter(Spec2Sm* self);
static void TEST2_S1_exit(Spec2Sm* self);

static void TEST2_S1_1_enter(Spec2Sm* self);
static void TEST2_S1_1_exit(Spec2Sm* self);
static void TEST2_S1_1_do(Spec2Sm* self);
static void TEST2_S1_1_ev1(Spec2Sm* self);

static void TEST2_S2_enter(Spec2Sm* self);
static void TEST2_S2_exit(Spec2Sm* self);
static void TEST2_S2_ev1(Spec2Sm* self);
static void TEST2_S2_ev2(Spec2Sm* self);

static void TEST3_BEHAVIOR_ORDERING_enter(Spec2Sm* self);
static void TEST3_BEHAVIOR_ORDERING_exit(Spec2Sm* self);

static void TEST3_ROOT_enter(Spec2Sm* self);
static void TEST3_ROOT_exit(Spec2Sm* self);
static void TEST3_ROOT_ev1(Spec2Sm* self);

static void TEST3_S1_enter(Spec2Sm* self);
static void TEST3_S1_exit(Spec2Sm* self);
static void TEST3_S1_ev1(Spec2Sm* self);

static void TEST3_S2_enter(Spec2Sm* self);
static void TEST3_S2_exit(Spec2Sm* self);
static void TEST3_S2_ev1(Spec2Sm* self);

static void TEST3_S3_enter(Spec2Sm* self);
static void TEST3_S3_exit(Spec2Sm* self);

static void TEST4_PARENT_CHILD_TRANSITIONS_enter(Spec2Sm* self);
static void TEST4_PARENT_CHILD_TRANSITIONS_exit(Spec2Sm* self);

static void TEST4_ROOT_enter(Spec2Sm* self);
static void TEST4_ROOT_exit(Spec2Sm* self);
static void TEST4_ROOT_ev2(Spec2Sm* self);
static void TEST4_ROOT_ev3(Spec2Sm* self);

static void TEST4_S1_enter(Spec2Sm* self);
static void TEST4_S1_exit(Spec2Sm* self);
static void TEST4_S1_ev1(Spec2Sm* self);

static void TEST4_S10_enter(Spec2Sm* self);
static void TEST4_S10_exit(Spec2Sm* self);
static void TEST4_S10_ev4(Spec2Sm* self);

static void TEST4_S10_1_enter(Spec2Sm* self);
static void TEST4_S10_1_exit(Spec2Sm* self);

static void TEST4_S2_enter(Spec2Sm* self);
static void TEST4_S2_exit(Spec2Sm* self);
static void TEST4_S2_ev1(Spec2Sm* self);

static void TEST4_S3_enter(Spec2Sm* self);
static void TEST4_S3_exit(Spec2Sm* self);
static void TEST4_S3_ev1(Spec2Sm* self);

static void TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_enter(Spec2Sm* self);
static void TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_exit(Spec2Sm* self);

static void TEST5_ROOT_enter(Spec2Sm* self);
static void TEST5_ROOT_exit(Spec2Sm* self);
static void TEST5_ROOT_ev2(Spec2Sm* self);

static void TEST5_S1_enter(Spec2Sm* self);
static void TEST5_S1_exit(Spec2Sm* self);
static void TEST5_S1_ev1(Spec2Sm* self);

static void TEST5_S2_enter(Spec2Sm* self);
static void TEST5_S2_exit(Spec2Sm* self);
static void TEST5_S2_ev1(Spec2Sm* self);

static void TEST5_S3_enter(Spec2Sm* self);
static void TEST5_S3_exit(Spec2Sm* self);
static void TEST5_S3_ev1(Spec2Sm* self);

static void TEST6_VARIABLES_enter(Spec2Sm* self);
static void TEST6_VARIABLES_exit(Spec2Sm* self);

static void TEST6_ROOT_enter(Spec2Sm* self);
static void TEST6_ROOT_exit(Spec2Sm* self);

static void TEST6_S1_enter(Spec2Sm* self);
static void TEST6_S1_exit(Spec2Sm* self);
static void TEST6_S1_ev1(Spec2Sm* self);

static void TEST6_S2_enter(Spec2Sm* self);
static void TEST6_S2_exit(Spec2Sm* self);

void Spec2Sm_ctor(Spec2Sm* self)
{
    memset(self, 0, sizeof(*self));
}

void Spec2Sm_start(Spec2Sm* self)
{
    ROOT_enter(self);
    trace("Transition action `` for Spec2Sm.InitialState to DECIDE.");
    // Transition to target state DECIDE
    {
        // No need exit any states in this handler.
        
        // Enter towards target
        DECIDE_enter(self);
        
        // update state_id
        self->state_id = Spec2Sm_StateId_DECIDE;
    } // end of transition code
}

void Spec2Sm_dispatch_event(Spec2Sm* self, enum Spec2Sm_EventId event_id)
{
    Spec2Sm_Func behavior_func = self->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        self->ancestor_event_handler = NULL;
        behavior_func(self);
        behavior_func = self->ancestor_event_handler;
    }
}

const char* Spec2Sm_state_id_to_string(const enum Spec2Sm_StateId id)
{
    switch (id)
    {
        case Spec2Sm_StateId_ROOT: return "ROOT";
        case Spec2Sm_StateId_DECIDE: return "DECIDE";
        case Spec2Sm_StateId_TEST1_DO_EVENT_TESTING: return "TEST1_DO_EVENT_TESTING";
        case Spec2Sm_StateId_TEST1_ROOT: return "TEST1_ROOT";
        case Spec2Sm_StateId_TEST1_S1: return "TEST1_S1";
        case Spec2Sm_StateId_TEST1_S1_1: return "TEST1_S1_1";
        case Spec2Sm_StateId_TEST1_S2: return "TEST1_S2";
        case Spec2Sm_StateId_TEST2_REGULAR_EVENT_TESTING: return "TEST2_REGULAR_EVENT_TESTING";
        case Spec2Sm_StateId_TEST2_ROOT: return "TEST2_ROOT";
        case Spec2Sm_StateId_TEST2_S1: return "TEST2_S1";
        case Spec2Sm_StateId_TEST2_S1_1: return "TEST2_S1_1";
        case Spec2Sm_StateId_TEST2_S2: return "TEST2_S2";
        case Spec2Sm_StateId_TEST3_BEHAVIOR_ORDERING: return "TEST3_BEHAVIOR_ORDERING";
        case Spec2Sm_StateId_TEST3_ROOT: return "TEST3_ROOT";
        case Spec2Sm_StateId_TEST3_S1: return "TEST3_S1";
        case Spec2Sm_StateId_TEST3_S2: return "TEST3_S2";
        case Spec2Sm_StateId_TEST3_S3: return "TEST3_S3";
        case Spec2Sm_StateId_TEST4_PARENT_CHILD_TRANSITIONS: return "TEST4_PARENT_CHILD_TRANSITIONS";
        case Spec2Sm_StateId_TEST4_ROOT: return "TEST4_ROOT";
        case Spec2Sm_StateId_TEST4_S1: return "TEST4_S1";
        case Spec2Sm_StateId_TEST4_S10: return "TEST4_S10";
        case Spec2Sm_StateId_TEST4_S10_1: return "TEST4_S10_1";
        case Spec2Sm_StateId_TEST4_S2: return "TEST4_S2";
        case Spec2Sm_StateId_TEST4_S3: return "TEST4_S3";
        case Spec2Sm_StateId_TEST5_PARENT_CHILD_TRANSITIONS_ALIAS: return "TEST5_PARENT_CHILD_TRANSITIONS_ALIAS";
        case Spec2Sm_StateId_TEST5_ROOT: return "TEST5_ROOT";
        case Spec2Sm_StateId_TEST5_S1: return "TEST5_S1";
        case Spec2Sm_StateId_TEST5_S2: return "TEST5_S2";
        case Spec2Sm_StateId_TEST5_S3: return "TEST5_S3";
        case Spec2Sm_StateId_TEST6_VARIABLES: return "TEST6_VARIABLES";
        case Spec2Sm_StateId_TEST6_ROOT: return "TEST6_ROOT";
        case Spec2Sm_StateId_TEST6_S1: return "TEST6_S1";
        case Spec2Sm_StateId_TEST6_S2: return "TEST6_S2";
        default: return "?";
    }
}

////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = ROOT_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter Spec2Sm.");
        trace("Enter Spec2Sm.");
    } // end of behavior code
}

static void ROOT_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit Spec2Sm.");
        trace("Exit Spec2Sm.");
    } // end of behavior code
    // State machine root is a special case. It cannot be exited.
    (void)self;  // nothing to see here compiler. move along!
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state DECIDE
////////////////////////////////////////////////////////////////////////////////

static void DECIDE_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = DECIDE_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = DECIDE_ev1;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = DECIDE_ev2;
    self->current_event_handlers[Spec2Sm_EventId_EV3] = DECIDE_ev3;
    self->current_event_handlers[Spec2Sm_EventId_EV4] = DECIDE_ev4;
    self->current_event_handlers[Spec2Sm_EventId_EV5] = DECIDE_ev5;
    self->current_event_handlers[Spec2Sm_EventId_EV6] = DECIDE_ev6;
    
    // state behavior:
    {
        // uml action: trace("Enter DECIDE.");
        trace("Enter DECIDE.");
    } // end of behavior code
}

static void DECIDE_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit DECIDE.");
        trace("Exit DECIDE.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV3] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV4] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV5] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV6] = NULL;  // no ancestor listens to this event
}

static void DECIDE_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV1` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State DECIDE: check behavior `EV1 TransitionTo(TEST1_DO_EVENT_TESTING)`.", true)
        // uml action: trace("Transition action `` for DECIDE to TEST1_DO_EVENT_TESTING.");trace("Transition action `` for TEST1_DO_EVENT_TESTING.InitialState to TEST1_ROOT.");trace("Transition action `` for TEST1_ROOT.InitialState to TEST1_S1_1.");
        // uml transition target: TEST1_S1_1
        if (trace_guard("State DECIDE: check behavior `EV1 TransitionTo(TEST1_DO_EVENT_TESTING)`.", true))
        {
            trace("Transition action `` for DECIDE to TEST1_DO_EVENT_TESTING.");trace("Transition action `` for TEST1_DO_EVENT_TESTING.InitialState to TEST1_ROOT.");trace("Transition action `` for TEST1_ROOT.InitialState to TEST1_S1_1.");
            
            // Transition to target state TEST1_S1_1
            {
                // First, exit up to Least Common Ancestor ROOT.
                while (self->current_state_exit_handler != ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST1_DO_EVENT_TESTING_enter(self);
                TEST1_ROOT_enter(self);
                TEST1_S1_enter(self);
                TEST1_S1_1_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST1_S1_1;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}

static void DECIDE_ev2(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV2` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV2` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State DECIDE: check behavior `EV2 TransitionTo(TEST2_REGULAR_EVENT_TESTING)`.", true)
        // uml action: trace("Transition action `` for DECIDE to TEST2_REGULAR_EVENT_TESTING.");trace("Transition action `` for TEST2_REGULAR_EVENT_TESTING.InitialState to TEST2_ROOT.");trace("Transition action `` for TEST2_ROOT.InitialState to TEST2_S1_1.");
        // uml transition target: TEST2_S1_1
        if (trace_guard("State DECIDE: check behavior `EV2 TransitionTo(TEST2_REGULAR_EVENT_TESTING)`.", true))
        {
            trace("Transition action `` for DECIDE to TEST2_REGULAR_EVENT_TESTING.");trace("Transition action `` for TEST2_REGULAR_EVENT_TESTING.InitialState to TEST2_ROOT.");trace("Transition action `` for TEST2_ROOT.InitialState to TEST2_S1_1.");
            
            // Transition to target state TEST2_S1_1
            {
                // First, exit up to Least Common Ancestor ROOT.
                while (self->current_state_exit_handler != ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST2_REGULAR_EVENT_TESTING_enter(self);
                TEST2_ROOT_enter(self);
                TEST2_S1_enter(self);
                TEST2_S1_1_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST2_S1_1;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}

static void DECIDE_ev3(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV3` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV3` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State DECIDE: check behavior `EV3 TransitionTo(TEST3_BEHAVIOR_ORDERING)`.", true)
        // uml action: trace("Transition action `` for DECIDE to TEST3_BEHAVIOR_ORDERING.");trace("Transition action `` for TEST3_BEHAVIOR_ORDERING.InitialState to TEST3_ROOT.");trace("Transition action `` for TEST3_ROOT.InitialState to TEST3_S1.");
        // uml transition target: TEST3_S1
        if (trace_guard("State DECIDE: check behavior `EV3 TransitionTo(TEST3_BEHAVIOR_ORDERING)`.", true))
        {
            trace("Transition action `` for DECIDE to TEST3_BEHAVIOR_ORDERING.");trace("Transition action `` for TEST3_BEHAVIOR_ORDERING.InitialState to TEST3_ROOT.");trace("Transition action `` for TEST3_ROOT.InitialState to TEST3_S1.");
            
            // Transition to target state TEST3_S1
            {
                // First, exit up to Least Common Ancestor ROOT.
                while (self->current_state_exit_handler != ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST3_BEHAVIOR_ORDERING_enter(self);
                TEST3_ROOT_enter(self);
                TEST3_S1_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST3_S1;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}

static void DECIDE_ev4(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV4` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV4` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State DECIDE: check behavior `EV4 TransitionTo(TEST4_PARENT_CHILD_TRANSITIONS)`.", true)
        // uml action: trace("Transition action `` for DECIDE to TEST4_PARENT_CHILD_TRANSITIONS.");trace("Transition action `` for TEST4_PARENT_CHILD_TRANSITIONS.InitialState to TEST4_ROOT.");
        // uml transition target: TEST4_ROOT
        if (trace_guard("State DECIDE: check behavior `EV4 TransitionTo(TEST4_PARENT_CHILD_TRANSITIONS)`.", true))
        {
            trace("Transition action `` for DECIDE to TEST4_PARENT_CHILD_TRANSITIONS.");trace("Transition action `` for TEST4_PARENT_CHILD_TRANSITIONS.InitialState to TEST4_ROOT.");
            
            // Transition to target state TEST4_ROOT
            {
                // First, exit up to Least Common Ancestor ROOT.
                while (self->current_state_exit_handler != ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST4_PARENT_CHILD_TRANSITIONS_enter(self);
                TEST4_ROOT_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST4_ROOT;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}

static void DECIDE_ev5(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV5` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV5` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State DECIDE: check behavior `EV5 TransitionTo(TEST5_PARENT_CHILD_TRANSITIONS_ALIAS)`.", true)
        // uml action: trace("Transition action `` for DECIDE to TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.");trace("Transition action `` for TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.InitialState to TEST5_ROOT.");
        // uml transition target: TEST5_ROOT
        if (trace_guard("State DECIDE: check behavior `EV5 TransitionTo(TEST5_PARENT_CHILD_TRANSITIONS_ALIAS)`.", true))
        {
            trace("Transition action `` for DECIDE to TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.");trace("Transition action `` for TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.InitialState to TEST5_ROOT.");
            
            // Transition to target state TEST5_ROOT
            {
                // First, exit up to Least Common Ancestor ROOT.
                while (self->current_state_exit_handler != ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_enter(self);
                TEST5_ROOT_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST5_ROOT;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}

static void DECIDE_ev6(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV6` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV6` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State DECIDE: check behavior `EV6 TransitionTo(TEST6_VARIABLES)`.", true)
        // uml action: trace("Transition action `` for DECIDE to TEST6_VARIABLES.");trace("Transition action `` for TEST6_VARIABLES.InitialState to TEST6_ROOT.");trace("Transition action `` for TEST6_ROOT.InitialState to TEST6_S1.");
        // uml transition target: TEST6_S1
        if (trace_guard("State DECIDE: check behavior `EV6 TransitionTo(TEST6_VARIABLES)`.", true))
        {
            trace("Transition action `` for DECIDE to TEST6_VARIABLES.");trace("Transition action `` for TEST6_VARIABLES.InitialState to TEST6_ROOT.");trace("Transition action `` for TEST6_ROOT.InitialState to TEST6_S1.");
            
            // Transition to target state TEST6_S1
            {
                // First, exit up to Least Common Ancestor ROOT.
                while (self->current_state_exit_handler != ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST6_VARIABLES_enter(self);
                TEST6_ROOT_enter(self);
                TEST6_S1_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST6_S1;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_DO_EVENT_TESTING
////////////////////////////////////////////////////////////////////////////////

static void TEST1_DO_EVENT_TESTING_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_DO_EVENT_TESTING_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST1_DO_EVENT_TESTING.");
        trace("Enter TEST1_DO_EVENT_TESTING.");
    } // end of behavior code
}

static void TEST1_DO_EVENT_TESTING_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST1_DO_EVENT_TESTING.");
        trace("Exit TEST1_DO_EVENT_TESTING.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST1_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_ROOT_do;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST1_ROOT.");
        trace("Enter TEST1_ROOT.");
    } // end of behavior code
}

static void TEST1_ROOT_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST1_ROOT.");
        trace("Exit TEST1_ROOT.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST1_DO_EVENT_TESTING_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void TEST1_ROOT_do(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `do` event
    
    // state behavior:
    {
        bool consume_event = false; // the `do` event is special in that it normally is not consumed.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        
        // uml guard: trace_guard("State TEST1_ROOT: check behavior `do`.", true)
        if (trace_guard("State TEST1_ROOT: check behavior `do`.", true))
        {
            
            if (consume_event)
            {
                // Mark event as handled.
                // self->ancestor_event_handler = NULL; // already done at top of function
            }
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST1_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_S1_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST1_S1.");
        trace("Enter TEST1_S1.");
    } // end of behavior code
}

static void TEST1_S1_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST1_S1.");
        trace("Exit TEST1_S1.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST1_ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_S1_1
////////////////////////////////////////////////////////////////////////////////

static void TEST1_S1_1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_S1_1_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_S1_1_do;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST1_S1_1_ev1;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST1_S1_1.");
        trace("Enter TEST1_S1_1.");
    } // end of behavior code
    
    // state behavior:
    {
        // uml guard: trace_guard("State TEST1_S1_1: check behavior `enter / { clear_output(); }`.", true)
        // uml action: clear_output();
        if (trace_guard("State TEST1_S1_1: check behavior `enter / { clear_output(); }`.", true))
        {
            trace("IGNORE_OUTPUT_BEFORE_THIS");;
        } // end of guard code
    } // end of behavior code
}

static void TEST1_S1_1_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST1_S1_1.");
        trace("Exit TEST1_S1_1.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST1_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_ROOT_do;  // the next ancestor that handles this event is TEST1_ROOT
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST1_S1_1_do(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = TEST1_ROOT_do;
    
    // state behavior:
    {
        bool consume_event = false; // the `do` event is special in that it normally is not consumed.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        // uml guard: trace_guard("State TEST1_S1_1: check behavior `do`.", true)
        if (trace_guard("State TEST1_S1_1: check behavior `do`.", true))
        {
            
            if (consume_event)
            {
                // Mark event as handled.
                self->ancestor_event_handler = NULL;
            }
        } // end of guard code
    } // end of behavior code
}

static void TEST1_S1_1_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV1` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST1_S1_1: check behavior `EV1 TransitionTo(TEST1_S2)`.", true)
        // uml action: trace("Transition action `` for TEST1_S1_1 to TEST1_S2.");
        // uml transition target: TEST1_S2
        if (trace_guard("State TEST1_S1_1: check behavior `EV1 TransitionTo(TEST1_S2)`.", true))
        {
            trace("Transition action `` for TEST1_S1_1 to TEST1_S2.");
            
            // Transition to target state TEST1_S2
            {
                // First, exit up to Least Common Ancestor TEST1_ROOT.
                while (self->current_state_exit_handler != TEST1_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST1_S2_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST1_S2;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST1_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_S2_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_S2_do;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST1_S2.");
        trace("Enter TEST1_S2.");
    } // end of behavior code
}

static void TEST1_S2_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST1_S2.");
        trace("Exit TEST1_S2.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST1_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_ROOT_do;  // the next ancestor that handles this event is TEST1_ROOT
}

static void TEST1_S2_do(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = TEST1_ROOT_do;
    
    // state behavior:
    {
        bool consume_event = false; // the `do` event is special in that it normally is not consumed.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        // uml guard: trace_guard("State TEST1_S2: check behavior `do / { consume_event = true; }`.", true)
        // uml action: consume_event = true;
        if (trace_guard("State TEST1_S2: check behavior `do / { consume_event = true; }`.", true))
        {
            consume_event = true;
            
            if (consume_event)
            {
                // Mark event as handled.
                self->ancestor_event_handler = NULL;
            }
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_REGULAR_EVENT_TESTING
////////////////////////////////////////////////////////////////////////////////

static void TEST2_REGULAR_EVENT_TESTING_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_REGULAR_EVENT_TESTING_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST2_REGULAR_EVENT_TESTING.");
        trace("Enter TEST2_REGULAR_EVENT_TESTING.");
    } // end of behavior code
}

static void TEST2_REGULAR_EVENT_TESTING_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST2_REGULAR_EVENT_TESTING.");
        trace("Exit TEST2_REGULAR_EVENT_TESTING.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST2_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST2_ROOT_do;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_ROOT_ev1;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST2_ROOT_ev2;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST2_ROOT.");
        trace("Enter TEST2_ROOT.");
    } // end of behavior code
}

static void TEST2_ROOT_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST2_ROOT.");
        trace("Exit TEST2_ROOT.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST2_REGULAR_EVENT_TESTING_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
}

static void TEST2_ROOT_do(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `do` event
    
    // state behavior:
    {
        bool consume_event = false; // the `do` event is special in that it normally is not consumed.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        
        // uml guard: trace_guard("State TEST2_ROOT: check behavior `do`.", true)
        if (trace_guard("State TEST2_ROOT: check behavior `do`.", true))
        {
            
            if (consume_event)
            {
                // Mark event as handled.
                // self->ancestor_event_handler = NULL; // already done at top of function
            }
        } // end of guard code
    } // end of behavior code
}

static void TEST2_ROOT_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV1` event
    
    // state behavior:
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        
        // uml guard: trace_guard("State TEST2_ROOT: check behavior `EV1`.", true)
        if (trace_guard("State TEST2_ROOT: check behavior `EV1`.", true))
        {
            
            if (consume_event)
            {
                // Mark event as handled.
                // self->ancestor_event_handler = NULL; // already done at top of function
            }
        } // end of guard code
    } // end of behavior code
}

static void TEST2_ROOT_ev2(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV2` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV2` event
    
    // state behavior:
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        
        // uml guard: trace_guard("State TEST2_ROOT: check behavior `EV2`.", true)
        if (trace_guard("State TEST2_ROOT: check behavior `EV2`.", true))
        {
            
            if (consume_event)
            {
                // Mark event as handled.
                // self->ancestor_event_handler = NULL; // already done at top of function
            }
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST2_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_S1_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST2_S1.");
        trace("Enter TEST2_S1.");
    } // end of behavior code
}

static void TEST2_S1_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST2_S1.");
        trace("Exit TEST2_S1.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST2_ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_S1_1
////////////////////////////////////////////////////////////////////////////////

static void TEST2_S1_1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_S1_1_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST2_S1_1_do;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_S1_1_ev1;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST2_S1_1.");
        trace("Enter TEST2_S1_1.");
    } // end of behavior code
    
    // state behavior:
    {
        // uml guard: trace_guard("State TEST2_S1_1: check behavior `enter / { clear_output(); }`.", true)
        // uml action: clear_output();
        if (trace_guard("State TEST2_S1_1: check behavior `enter / { clear_output(); }`.", true))
        {
            trace("IGNORE_OUTPUT_BEFORE_THIS");;
        } // end of guard code
    } // end of behavior code
}

static void TEST2_S1_1_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST2_S1_1.");
        trace("Exit TEST2_S1_1.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST2_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST2_ROOT_do;  // the next ancestor that handles this event is TEST2_ROOT
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_ROOT_ev1;  // the next ancestor that handles this event is TEST2_ROOT
}

static void TEST2_S1_1_do(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = TEST2_ROOT_do;
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST2_S1_1: check behavior `do TransitionTo(TEST2_S2)`.", true)
        // uml action: trace("Transition action `` for TEST2_S1_1 to TEST2_S2.");
        // uml transition target: TEST2_S2
        if (trace_guard("State TEST2_S1_1: check behavior `do TransitionTo(TEST2_S2)`.", true))
        {
            trace("Transition action `` for TEST2_S1_1 to TEST2_S2.");
            
            // Transition to target state TEST2_S2
            {
                // First, exit up to Least Common Ancestor TEST2_ROOT.
                while (self->current_state_exit_handler != TEST2_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST2_S2_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST2_S2;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}

static void TEST2_S1_1_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = TEST2_ROOT_ev1;
    
    // state behavior:
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        // uml guard: trace_guard("State TEST2_S1_1: check behavior `EV1`.", true)
        if (trace_guard("State TEST2_S1_1: check behavior `EV1`.", true))
        {
            
            if (consume_event)
            {
                // Mark event as handled.
                self->ancestor_event_handler = NULL;
            }
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST2_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_S2_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_S2_ev1;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST2_S2_ev2;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST2_S2.");
        trace("Enter TEST2_S2.");
    } // end of behavior code
}

static void TEST2_S2_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST2_S2.");
        trace("Exit TEST2_S2.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST2_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_ROOT_ev1;  // the next ancestor that handles this event is TEST2_ROOT
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST2_ROOT_ev2;  // the next ancestor that handles this event is TEST2_ROOT
}

static void TEST2_S2_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = TEST2_ROOT_ev1;
    
    // state behavior:
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        // uml guard: trace_guard("State TEST2_S2: check behavior `EV1 / { consume_event = false; }`.", true)
        // uml action: consume_event = false;
        if (trace_guard("State TEST2_S2: check behavior `EV1 / { consume_event = false; }`.", true))
        {
            consume_event = false;
            
            if (consume_event)
            {
                // Mark event as handled.
                self->ancestor_event_handler = NULL;
            }
        } // end of guard code
    } // end of behavior code
}

static void TEST2_S2_ev2(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV2` event
    self->ancestor_event_handler = TEST2_ROOT_ev2;
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST2_S2: check behavior `EV2 TransitionTo(TEST2_S2)`.", true)
        // uml action: trace("Transition action `` for TEST2_S2 to TEST2_S2.");
        // uml transition target: TEST2_S2
        if (trace_guard("State TEST2_S2: check behavior `EV2 TransitionTo(TEST2_S2)`.", true))
        {
            trace("Transition action `` for TEST2_S2 to TEST2_S2.");
            
            // self transition
            // Transition to target state TEST2_S2
            {
                // First, exit up to Least Common Ancestor TEST2_ROOT.
                while (self->current_state_exit_handler != TEST2_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST2_S2_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST2_S2;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_BEHAVIOR_ORDERING
////////////////////////////////////////////////////////////////////////////////

static void TEST3_BEHAVIOR_ORDERING_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_BEHAVIOR_ORDERING_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST3_BEHAVIOR_ORDERING.");
        trace("Enter TEST3_BEHAVIOR_ORDERING.");
    } // end of behavior code
}

static void TEST3_BEHAVIOR_ORDERING_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST3_BEHAVIOR_ORDERING.");
        trace("Exit TEST3_BEHAVIOR_ORDERING.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST3_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_ROOT_ev1;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST3_ROOT.");
        trace("Enter TEST3_ROOT.");
    } // end of behavior code
}

static void TEST3_ROOT_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST3_ROOT.");
        trace("Exit TEST3_ROOT.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST3_BEHAVIOR_ORDERING_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST3_ROOT_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV1` event
    
    // state behavior:
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        
        // uml guard: trace_guard("State TEST3_ROOT: check behavior `EV1`.", true)
        if (trace_guard("State TEST3_ROOT: check behavior `EV1`.", true))
        {
            
            if (consume_event)
            {
                // Mark event as handled.
                // self->ancestor_event_handler = NULL; // already done at top of function
            }
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST3_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_S1_ev1;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST3_S1.");
        trace("Enter TEST3_S1.");
    } // end of behavior code
    
    // state behavior:
    {
        // uml guard: trace_guard("State TEST3_S1: check behavior `enter / { clear_output(); }`.", true)
        // uml action: clear_output();
        if (trace_guard("State TEST3_S1: check behavior `enter / { clear_output(); }`.", true))
        {
            trace("IGNORE_OUTPUT_BEFORE_THIS");;
        } // end of guard code
    } // end of behavior code
}

static void TEST3_S1_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST3_S1.");
        trace("Exit TEST3_S1.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST3_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_ROOT_ev1;  // the next ancestor that handles this event is TEST3_ROOT
}

static void TEST3_S1_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = TEST3_ROOT_ev1;
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST3_S1: check behavior `1. EV1 TransitionTo(TEST3_S2)`.", true)
        // uml action: trace("Transition action `` for TEST3_S1 to TEST3_S2.");
        // uml transition target: TEST3_S2
        if (trace_guard("State TEST3_S1: check behavior `1. EV1 TransitionTo(TEST3_S2)`.", true))
        {
            trace("Transition action `` for TEST3_S1 to TEST3_S2.");
            
            // Transition to target state TEST3_S2
            {
                // First, exit up to Least Common Ancestor TEST3_ROOT.
                while (self->current_state_exit_handler != TEST3_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST3_S2_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST3_S2;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
    
    // state behavior:
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        // uml guard: trace_guard("State TEST3_S1: check behavior `2. EV1 / { trace(\"failed\"); }`.", true)
        // uml action: trace("failed");
        if (trace_guard("State TEST3_S1: check behavior `2. EV1 / { trace(\"failed\"); }`.", true))
        {
            trace("failed");
            
            if (consume_event)
            {
                // Mark event as handled.
                self->ancestor_event_handler = NULL;
            }
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST3_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_S2_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_S2_ev1;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST3_S2.");
        trace("Enter TEST3_S2.");
    } // end of behavior code
}

static void TEST3_S2_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST3_S2.");
        trace("Exit TEST3_S2.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST3_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_ROOT_ev1;  // the next ancestor that handles this event is TEST3_ROOT
}

static void TEST3_S2_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = TEST3_ROOT_ev1;
    
    // state behavior:
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        // uml guard: trace_guard("State TEST3_S2: check behavior `1. EV1 / { trace(\"1 woot!\"); }`.", true)
        // uml action: trace("1 woot!");
        if (trace_guard("State TEST3_S2: check behavior `1. EV1 / { trace(\"1 woot!\"); }`.", true))
        {
            trace("1 woot!");
            
            if (consume_event)
            {
                // Mark event as handled.
                self->ancestor_event_handler = NULL;
            }
        } // end of guard code
    } // end of behavior code
    
    // state behavior:
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        // uml guard: trace_guard("State TEST3_S2: check behavior `1.1. EV1 / { trace(\"2 woot!\"); }`.", true)
        // uml action: trace("2 woot!");
        if (trace_guard("State TEST3_S2: check behavior `1.1. EV1 / { trace(\"2 woot!\"); }`.", true))
        {
            trace("2 woot!");
            
            if (consume_event)
            {
                // Mark event as handled.
                self->ancestor_event_handler = NULL;
            }
        } // end of guard code
    } // end of behavior code
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST3_S2: check behavior `2. EV1 / { trace(\"3 woot!\"); } TransitionTo(TEST3_S3)`.", true)
        // uml action: trace("Transition action `trace(\"3 woot!\");` for TEST3_S2 to TEST3_S3.");
        //             trace("3 woot!");
        // uml transition target: TEST3_S3
        if (trace_guard("State TEST3_S2: check behavior `2. EV1 / { trace(\"3 woot!\"); } TransitionTo(TEST3_S3)`.", true))
        {
            trace("Transition action `trace(\"3 woot!\");` for TEST3_S2 to TEST3_S3.");
            trace("3 woot!");
            
            // Transition to target state TEST3_S3
            {
                // First, exit up to Least Common Ancestor TEST3_ROOT.
                while (self->current_state_exit_handler != TEST3_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST3_S3_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST3_S3;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_S3
////////////////////////////////////////////////////////////////////////////////

static void TEST3_S3_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_S3_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST3_S3.");
        trace("Enter TEST3_S3.");
    } // end of behavior code
}

static void TEST3_S3_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST3_S3.");
        trace("Exit TEST3_S3.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST3_ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_PARENT_CHILD_TRANSITIONS
////////////////////////////////////////////////////////////////////////////////

static void TEST4_PARENT_CHILD_TRANSITIONS_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_PARENT_CHILD_TRANSITIONS_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST4_PARENT_CHILD_TRANSITIONS.");
        trace("Enter TEST4_PARENT_CHILD_TRANSITIONS.");
    } // end of behavior code
}

static void TEST4_PARENT_CHILD_TRANSITIONS_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST4_PARENT_CHILD_TRANSITIONS.");
        trace("Exit TEST4_PARENT_CHILD_TRANSITIONS.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST4_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST4_ROOT_ev2;
    self->current_event_handlers[Spec2Sm_EventId_EV3] = TEST4_ROOT_ev3;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST4_ROOT.");
        trace("Enter TEST4_ROOT.");
    } // end of behavior code
    
    // state behavior:
    {
        // uml guard: trace_guard("State TEST4_ROOT: check behavior `enter / { clear_output(); }`.", true)
        // uml action: clear_output();
        if (trace_guard("State TEST4_ROOT: check behavior `enter / { clear_output(); }`.", true))
        {
            trace("IGNORE_OUTPUT_BEFORE_THIS");;
        } // end of guard code
    } // end of behavior code
}

static void TEST4_ROOT_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST4_ROOT.");
        trace("Exit TEST4_ROOT.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_PARENT_CHILD_TRANSITIONS_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV3] = NULL;  // no ancestor listens to this event
}

static void TEST4_ROOT_ev2(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV2` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV2` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST4_ROOT: check behavior `EV2 TransitionTo(TEST4_S1)`.", true)
        // uml action: trace("Transition action `` for TEST4_ROOT to TEST4_S1.");
        // uml transition target: TEST4_S1
        if (trace_guard("State TEST4_ROOT: check behavior `EV2 TransitionTo(TEST4_S1)`.", true))
        {
            trace("Transition action `` for TEST4_ROOT to TEST4_S1.");
            
            // Transition to target state TEST4_S1
            {
                // First, exit up to Least Common Ancestor TEST4_ROOT.
                while (self->current_state_exit_handler != TEST4_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST4_S1_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST4_S1;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}

static void TEST4_ROOT_ev3(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV3` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV3` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST4_ROOT: check behavior `EV3 TransitionTo(TEST4_S10_1)`.", true)
        // uml action: trace("Transition action `` for TEST4_ROOT to TEST4_S10_1.");
        // uml transition target: TEST4_S10_1
        if (trace_guard("State TEST4_ROOT: check behavior `EV3 TransitionTo(TEST4_S10_1)`.", true))
        {
            trace("Transition action `` for TEST4_ROOT to TEST4_S10_1.");
            
            // Transition to target state TEST4_S10_1
            {
                // First, exit up to Least Common Ancestor TEST4_ROOT.
                while (self->current_state_exit_handler != TEST4_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST4_S10_enter(self);
                TEST4_S10_1_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST4_S10_1;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST4_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST4_S1_ev1;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST4_S1.");
        trace("Enter TEST4_S1.");
    } // end of behavior code
}

static void TEST4_S1_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST4_S1.");
        trace("Exit TEST4_S1.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST4_S1_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV1` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST4_S1: check behavior `EV1 TransitionTo(TEST4_S2)`.", true)
        // uml action: trace("Transition action `` for TEST4_S1 to TEST4_S2.");
        // uml transition target: TEST4_S2
        if (trace_guard("State TEST4_S1: check behavior `EV1 TransitionTo(TEST4_S2)`.", true))
        {
            trace("Transition action `` for TEST4_S1 to TEST4_S2.");
            
            // Transition to target state TEST4_S2
            {
                // First, exit up to Least Common Ancestor TEST4_ROOT.
                while (self->current_state_exit_handler != TEST4_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST4_S2_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST4_S2;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_S10
////////////////////////////////////////////////////////////////////////////////

static void TEST4_S10_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_S10_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV4] = TEST4_S10_ev4;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST4_S10.");
        trace("Enter TEST4_S10.");
    } // end of behavior code
}

static void TEST4_S10_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST4_S10.");
        trace("Exit TEST4_S10.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV4] = NULL;  // no ancestor listens to this event
}

static void TEST4_S10_ev4(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV4` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV4` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST4_S10: check behavior `EV4 TransitionTo(TEST4_S10)`.", true)
        // uml action: trace("Transition action `` for TEST4_S10 to TEST4_S10.");
        // uml transition target: TEST4_S10
        if (trace_guard("State TEST4_S10: check behavior `EV4 TransitionTo(TEST4_S10)`.", true))
        {
            trace("Transition action `` for TEST4_S10 to TEST4_S10.");
            
            // self transition
            // Transition to target state TEST4_S10
            {
                // First, exit up to Least Common Ancestor TEST4_ROOT.
                while (self->current_state_exit_handler != TEST4_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST4_S10_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST4_S10;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_S10_1
////////////////////////////////////////////////////////////////////////////////

static void TEST4_S10_1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_S10_1_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST4_S10_1.");
        trace("Enter TEST4_S10_1.");
    } // end of behavior code
}

static void TEST4_S10_1_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST4_S10_1.");
        trace("Exit TEST4_S10_1.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_S10_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST4_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_S2_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST4_S2_ev1;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST4_S2.");
        trace("Enter TEST4_S2.");
    } // end of behavior code
}

static void TEST4_S2_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST4_S2.");
        trace("Exit TEST4_S2.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST4_S2_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV1` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST4_S2: check behavior `EV1 TransitionTo(TEST4_S3)`.", true)
        // uml action: trace("Transition action `` for TEST4_S2 to TEST4_S3.");
        // uml transition target: TEST4_S3
        if (trace_guard("State TEST4_S2: check behavior `EV1 TransitionTo(TEST4_S3)`.", true))
        {
            trace("Transition action `` for TEST4_S2 to TEST4_S3.");
            
            // Transition to target state TEST4_S3
            {
                // First, exit up to Least Common Ancestor TEST4_ROOT.
                while (self->current_state_exit_handler != TEST4_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST4_S3_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST4_S3;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_S3
////////////////////////////////////////////////////////////////////////////////

static void TEST4_S3_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_S3_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST4_S3_ev1;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST4_S3.");
        trace("Enter TEST4_S3.");
    } // end of behavior code
}

static void TEST4_S3_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST4_S3.");
        trace("Exit TEST4_S3.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST4_S3_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV1` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST4_S3: check behavior `EV1 TransitionTo(TEST4_ROOT)`.", true)
        // uml action: trace("Transition action `` for TEST4_S3 to TEST4_ROOT.");
        // uml transition target: TEST4_ROOT
        if (trace_guard("State TEST4_S3: check behavior `EV1 TransitionTo(TEST4_ROOT)`.", true))
        {
            trace("Transition action `` for TEST4_S3 to TEST4_ROOT.");
            
            // Transition to target state TEST4_ROOT
            {
                // First, exit up to Least Common Ancestor TEST4_ROOT.
                while (self->current_state_exit_handler != TEST4_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST4_ROOT;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST5_PARENT_CHILD_TRANSITIONS_ALIAS
////////////////////////////////////////////////////////////////////////////////

static void TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.");
        trace("Enter TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.");
    } // end of behavior code
}

static void TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.");
        trace("Exit TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST5_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST5_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST5_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST5_ROOT_ev2;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST5_ROOT.");
        trace("Enter TEST5_ROOT.");
    } // end of behavior code
    
    // state behavior:
    {
        // uml guard: trace_guard("State TEST5_ROOT: check behavior `enter / { clear_output(); }`.", true)
        // uml action: clear_output();
        if (trace_guard("State TEST5_ROOT: check behavior `enter / { clear_output(); }`.", true))
        {
            trace("IGNORE_OUTPUT_BEFORE_THIS");;
        } // end of guard code
    } // end of behavior code
}

static void TEST5_ROOT_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST5_ROOT.");
        trace("Exit TEST5_ROOT.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
}

static void TEST5_ROOT_ev2(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV2` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV2` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST5_ROOT: check behavior `EV2 TransitionTo(TEST5_S1)`.", true)
        // uml action: trace("Transition action `` for TEST5_ROOT to TEST5_S1.");
        // uml transition target: TEST5_S1
        if (trace_guard("State TEST5_ROOT: check behavior `EV2 TransitionTo(TEST5_S1)`.", true))
        {
            trace("Transition action `` for TEST5_ROOT to TEST5_S1.");
            
            // Transition to target state TEST5_S1
            {
                // First, exit up to Least Common Ancestor TEST5_ROOT.
                while (self->current_state_exit_handler != TEST5_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST5_S1_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST5_S1;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST5_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST5_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST5_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST5_S1_ev1;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST5_S1.");
        trace("Enter TEST5_S1.");
    } // end of behavior code
}

static void TEST5_S1_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST5_S1.");
        trace("Exit TEST5_S1.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST5_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST5_S1_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV1` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST5_S1: check behavior `EV1 TransitionTo(TEST5_S2)`.", true)
        // uml action: trace("Transition action `` for TEST5_S1 to TEST5_S2.");
        // uml transition target: TEST5_S2
        if (trace_guard("State TEST5_S1: check behavior `EV1 TransitionTo(TEST5_S2)`.", true))
        {
            trace("Transition action `` for TEST5_S1 to TEST5_S2.");
            
            // Transition to target state TEST5_S2
            {
                // First, exit up to Least Common Ancestor TEST5_ROOT.
                while (self->current_state_exit_handler != TEST5_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST5_S2_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST5_S2;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST5_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST5_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST5_S2_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST5_S2_ev1;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST5_S2.");
        trace("Enter TEST5_S2.");
    } // end of behavior code
}

static void TEST5_S2_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST5_S2.");
        trace("Exit TEST5_S2.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST5_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST5_S2_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV1` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST5_S2: check behavior `EV1 TransitionTo(TEST5_S3)`.", true)
        // uml action: trace("Transition action `` for TEST5_S2 to TEST5_S3.");
        // uml transition target: TEST5_S3
        if (trace_guard("State TEST5_S2: check behavior `EV1 TransitionTo(TEST5_S3)`.", true))
        {
            trace("Transition action `` for TEST5_S2 to TEST5_S3.");
            
            // Transition to target state TEST5_S3
            {
                // First, exit up to Least Common Ancestor TEST5_ROOT.
                while (self->current_state_exit_handler != TEST5_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST5_S3_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST5_S3;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST5_S3
////////////////////////////////////////////////////////////////////////////////

static void TEST5_S3_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST5_S3_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST5_S3_ev1;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST5_S3.");
        trace("Enter TEST5_S3.");
    } // end of behavior code
}

static void TEST5_S3_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST5_S3.");
        trace("Exit TEST5_S3.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST5_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST5_S3_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV1` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST5_S3: check behavior `EV1 TransitionTo(TEST5_ROOT)`.", true)
        // uml action: trace("Transition action `` for TEST5_S3 to TEST5_ROOT.");
        // uml transition target: TEST5_ROOT
        if (trace_guard("State TEST5_S3: check behavior `EV1 TransitionTo(TEST5_ROOT)`.", true))
        {
            trace("Transition action `` for TEST5_S3 to TEST5_ROOT.");
            
            // Transition to target state TEST5_ROOT
            {
                // First, exit up to Least Common Ancestor TEST5_ROOT.
                while (self->current_state_exit_handler != TEST5_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST5_ROOT;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST6_VARIABLES
////////////////////////////////////////////////////////////////////////////////

static void TEST6_VARIABLES_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST6_VARIABLES_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST6_VARIABLES.");
        trace("Enter TEST6_VARIABLES.");
    } // end of behavior code
}

static void TEST6_VARIABLES_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST6_VARIABLES.");
        trace("Exit TEST6_VARIABLES.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST6_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST6_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST6_ROOT_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST6_ROOT.");
        trace("Enter TEST6_ROOT.");
    } // end of behavior code
}

static void TEST6_ROOT_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST6_ROOT.");
        trace("Exit TEST6_ROOT.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST6_VARIABLES_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST6_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST6_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST6_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST6_S1_ev1;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST6_S1.");
        trace("Enter TEST6_S1.");
    } // end of behavior code
    
    // state behavior:
    {
        // uml guard: trace_guard("State TEST6_S1: check behavior `enter / { clear_output(); }`.", true)
        // uml action: clear_output();
        if (trace_guard("State TEST6_S1: check behavior `enter / { clear_output(); }`.", true))
        {
            trace("IGNORE_OUTPUT_BEFORE_THIS");;
        } // end of guard code
    } // end of behavior code
}

static void TEST6_S1_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST6_S1.");
        trace("Exit TEST6_S1.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST6_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST6_S1_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV1` event
    
    // state behavior:
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        
        // uml guard: trace_guard("State TEST6_S1: check behavior `1. EV1 / { count++; }`.", true)
        // uml action: count++;
        if (trace_guard("State TEST6_S1: check behavior `1. EV1 / { count++; }`.", true))
        {
            self->vars.count++;
            
            if (consume_event)
            {
                // Mark event as handled.
                // self->ancestor_event_handler = NULL; // already done at top of function
            }
        } // end of guard code
    } // end of behavior code
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST6_S1: check behavior `2. EV1 [count >= 2] TransitionTo(TEST6_S2)`.", count >= 2)
        // uml action: trace("Transition action `` for TEST6_S1 to TEST6_S2.");
        // uml transition target: TEST6_S2
        if (trace_guard("State TEST6_S1: check behavior `2. EV1 [count >= 2] TransitionTo(TEST6_S2)`.", self->vars.count >= 2))
        {
            trace("Transition action `` for TEST6_S1 to TEST6_S2.");
            
            // Transition to target state TEST6_S2
            {
                // First, exit up to Least Common Ancestor TEST6_ROOT.
                while (self->current_state_exit_handler != TEST6_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST6_S2_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST6_S2;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST6_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST6_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST6_S2_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST6_S2.");
        trace("Enter TEST6_S2.");
    } // end of behavior code
}

static void TEST6_S2_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST6_S2.");
        trace("Exit TEST6_S2.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST6_ROOT_exit;
}


