// Autogenerated with StateSmith
#include "Spec2Sm.h"
#include "../../lang-helpers/c/helper.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

static void ROOT_enter(Spec2Sm* self);
static void ROOT_exit(Spec2Sm* self);

static void DECIDE_enter(Spec2Sm* self);
static void DECIDE_exit(Spec2Sm* self);
static void DECIDE_ev1(Spec2Sm* self);
static void DECIDE_ev10(Spec2Sm* self);
static void DECIDE_ev2(Spec2Sm* self);
static void DECIDE_ev3(Spec2Sm* self);
static void DECIDE_ev4(Spec2Sm* self);
static void DECIDE_ev5(Spec2Sm* self);
static void DECIDE_ev6(Spec2Sm* self);
static void DECIDE_ev7(Spec2Sm* self);
static void DECIDE_ev8(Spec2Sm* self);
static void DECIDE_ev9(Spec2Sm* self);

static void TEST1_DO_EVENT_TESTING_enter(Spec2Sm* self);
static void TEST1_DO_EVENT_TESTING_exit(Spec2Sm* self);

static void TEST1_ROOT_enter(Spec2Sm* self);
static void TEST1_ROOT_exit(Spec2Sm* self);
static void TEST1_ROOT_do(Spec2Sm* self);

static void TEST1_S1_enter(Spec2Sm* self);
static void TEST1_S1_exit(Spec2Sm* self);

static void TEST1_S1_1_enter(Spec2Sm* self);
static void TEST1_S1_1_exit(Spec2Sm* self);
static void TEST1_S1_1_do(Spec2Sm* self);
static void TEST1_S1_1_ev1(Spec2Sm* self);

static void TEST1_S2_enter(Spec2Sm* self);
static void TEST1_S2_exit(Spec2Sm* self);
static void TEST1_S2_do(Spec2Sm* self);

static void TEST10_CHOICE_POINT_enter(Spec2Sm* self);
static void TEST10_CHOICE_POINT_exit(Spec2Sm* self);

static void TEST10_A_enter(Spec2Sm* self);
static void TEST10_A_exit(Spec2Sm* self);

static void TEST10_A_1_enter(Spec2Sm* self);
static void TEST10_A_1_exit(Spec2Sm* self);

static void TEST10_ROOT_enter(Spec2Sm* self);
static void TEST10_ROOT_exit(Spec2Sm* self);
static void TEST10_ROOT_ev5(Spec2Sm* self);

static void TEST10_G_enter(Spec2Sm* self);
static void TEST10_G_exit(Spec2Sm* self);

static void TEST10_G_S0_enter(Spec2Sm* self);
static void TEST10_G_S0_exit(Spec2Sm* self);

static void TEST10_G_S1_enter(Spec2Sm* self);
static void TEST10_G_S1_exit(Spec2Sm* self);

static void TEST10_G_S2_enter(Spec2Sm* self);
static void TEST10_G_S2_exit(Spec2Sm* self);

static void TEST10_G_S3_enter(Spec2Sm* self);
static void TEST10_G_S3_exit(Spec2Sm* self);

static void TEST10_S1_enter(Spec2Sm* self);
static void TEST10_S1_exit(Spec2Sm* self);
static void TEST10_S1_ev1(Spec2Sm* self);
static void TEST10_S1_ev10(Spec2Sm* self);
static void TEST10_S1_ev2(Spec2Sm* self);
static void TEST10_S1_ev3(Spec2Sm* self);

static void TEST10_S4_enter(Spec2Sm* self);
static void TEST10_S4_exit(Spec2Sm* self);

static void TEST2_REGULAR_EVENT_TESTING_enter(Spec2Sm* self);
static void TEST2_REGULAR_EVENT_TESTING_exit(Spec2Sm* self);

static void TEST2_ROOT_enter(Spec2Sm* self);
static void TEST2_ROOT_exit(Spec2Sm* self);
static void TEST2_ROOT_do(Spec2Sm* self);
static void TEST2_ROOT_ev1(Spec2Sm* self);
static void TEST2_ROOT_ev2(Spec2Sm* self);

static void TEST2_S1_enter(Spec2Sm* self);
static void TEST2_S1_exit(Spec2Sm* self);

static void TEST2_S1_1_enter(Spec2Sm* self);
static void TEST2_S1_1_exit(Spec2Sm* self);
static void TEST2_S1_1_do(Spec2Sm* self);
static void TEST2_S1_1_ev1(Spec2Sm* self);

static void TEST2_S2_enter(Spec2Sm* self);
static void TEST2_S2_exit(Spec2Sm* self);
static void TEST2_S2_ev1(Spec2Sm* self);
static void TEST2_S2_ev2(Spec2Sm* self);

static void TEST3_BEHAVIOR_ORDERING_enter(Spec2Sm* self);
static void TEST3_BEHAVIOR_ORDERING_exit(Spec2Sm* self);

static void TEST3_ROOT_enter(Spec2Sm* self);
static void TEST3_ROOT_exit(Spec2Sm* self);
static void TEST3_ROOT_ev1(Spec2Sm* self);

static void TEST3_S1_enter(Spec2Sm* self);
static void TEST3_S1_exit(Spec2Sm* self);
static void TEST3_S1_ev1(Spec2Sm* self);

static void TEST3_S2_enter(Spec2Sm* self);
static void TEST3_S2_exit(Spec2Sm* self);
static void TEST3_S2_ev1(Spec2Sm* self);

static void TEST3_S3_enter(Spec2Sm* self);
static void TEST3_S3_exit(Spec2Sm* self);

static void TEST4_PARENT_CHILD_TRANSITIONS_enter(Spec2Sm* self);
static void TEST4_PARENT_CHILD_TRANSITIONS_exit(Spec2Sm* self);

static void TEST4_B_AND_OTHERS_enter(Spec2Sm* self);
static void TEST4_B_AND_OTHERS_exit(Spec2Sm* self);

static void TEST4B_LOCAL_enter(Spec2Sm* self);
static void TEST4B_LOCAL_exit(Spec2Sm* self);

static void TEST4B_G_enter(Spec2Sm* self);
static void TEST4B_G_exit(Spec2Sm* self);
static void TEST4B_G_ev1(Spec2Sm* self);

static void TEST4B_G_1_enter(Spec2Sm* self);
static void TEST4B_G_1_exit(Spec2Sm* self);
static void TEST4B_G_1_ev2(Spec2Sm* self);

static void TEST4C_LOCAL_TO_ALIAS_enter(Spec2Sm* self);
static void TEST4C_LOCAL_TO_ALIAS_exit(Spec2Sm* self);

static void TEST4C_G_enter(Spec2Sm* self);
static void TEST4C_G_exit(Spec2Sm* self);
static void TEST4C_G_ev1(Spec2Sm* self);

static void TEST4C_G_1_enter(Spec2Sm* self);
static void TEST4C_G_1_exit(Spec2Sm* self);
static void TEST4C_G_1_ev2(Spec2Sm* self);

static void TEST4D_EXTERNAL_enter(Spec2Sm* self);
static void TEST4D_EXTERNAL_exit(Spec2Sm* self);

static void TEST4D_G_enter(Spec2Sm* self);
static void TEST4D_G_exit(Spec2Sm* self);
static void TEST4D_G_ev1(Spec2Sm* self);

static void TEST4D_G_1_enter(Spec2Sm* self);
static void TEST4D_G_1_exit(Spec2Sm* self);
static void TEST4D_G_1_ev2(Spec2Sm* self);

static void TEST4_DECIDE_enter(Spec2Sm* self);
static void TEST4_DECIDE_exit(Spec2Sm* self);
static void TEST4_DECIDE_ev1(Spec2Sm* self);
static void TEST4_DECIDE_ev2(Spec2Sm* self);
static void TEST4_DECIDE_ev3(Spec2Sm* self);
static void TEST4_DECIDE_ev4(Spec2Sm* self);

static void TEST4_ROOT_enter(Spec2Sm* self);
static void TEST4_ROOT_exit(Spec2Sm* self);
static void TEST4_ROOT_ev2(Spec2Sm* self);
static void TEST4_ROOT_ev3(Spec2Sm* self);
static void TEST4_ROOT_ev4(Spec2Sm* self);

static void TEST4_S1_enter(Spec2Sm* self);
static void TEST4_S1_exit(Spec2Sm* self);
static void TEST4_S1_ev1(Spec2Sm* self);

static void TEST4_S10_enter(Spec2Sm* self);
static void TEST4_S10_exit(Spec2Sm* self);
static void TEST4_S10_ev4(Spec2Sm* self);

static void TEST4_S10_1_enter(Spec2Sm* self);
static void TEST4_S10_1_exit(Spec2Sm* self);

static void TEST4_S2_enter(Spec2Sm* self);
static void TEST4_S2_exit(Spec2Sm* self);
static void TEST4_S2_ev1(Spec2Sm* self);

static void TEST4_S20_enter(Spec2Sm* self);
static void TEST4_S20_exit(Spec2Sm* self);
static void TEST4_S20_ev4(Spec2Sm* self);

static void TEST4_S20_1_enter(Spec2Sm* self);
static void TEST4_S20_1_exit(Spec2Sm* self);

static void TEST4_S3_enter(Spec2Sm* self);
static void TEST4_S3_exit(Spec2Sm* self);
static void TEST4_S3_ev1(Spec2Sm* self);

static void TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_enter(Spec2Sm* self);
static void TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_exit(Spec2Sm* self);

static void TEST5_ROOT_enter(Spec2Sm* self);
static void TEST5_ROOT_exit(Spec2Sm* self);
static void TEST5_ROOT_ev2(Spec2Sm* self);

static void TEST5_S1_enter(Spec2Sm* self);
static void TEST5_S1_exit(Spec2Sm* self);
static void TEST5_S1_ev1(Spec2Sm* self);

static void TEST5_S2_enter(Spec2Sm* self);
static void TEST5_S2_exit(Spec2Sm* self);
static void TEST5_S2_ev1(Spec2Sm* self);

static void TEST5_S3_enter(Spec2Sm* self);
static void TEST5_S3_exit(Spec2Sm* self);
static void TEST5_S3_ev1(Spec2Sm* self);

static void TEST6_VARIABLES_enter(Spec2Sm* self);
static void TEST6_VARIABLES_exit(Spec2Sm* self);

static void TEST6_ROOT_enter(Spec2Sm* self);
static void TEST6_ROOT_exit(Spec2Sm* self);

static void TEST6_S1_enter(Spec2Sm* self);
static void TEST6_S1_exit(Spec2Sm* self);
static void TEST6_S1_ev1(Spec2Sm* self);

static void TEST6_S2_enter(Spec2Sm* self);
static void TEST6_S2_exit(Spec2Sm* self);

static void TEST7_INITIAL_OR_HISTORY_enter(Spec2Sm* self);
static void TEST7_INITIAL_OR_HISTORY_exit(Spec2Sm* self);

static void TEST7_enter(Spec2Sm* self);
static void TEST7_exit(Spec2Sm* self);

static void TEST7__HISTORY1_enter(Spec2Sm* self);
static void TEST7__HISTORY1_exit(Spec2Sm* self);

static void TEST7__HISTORY1__OFF_enter(Spec2Sm* self);
static void TEST7__HISTORY1__OFF_exit(Spec2Sm* self);
static void TEST7__HISTORY1__OFF_ev3(Spec2Sm* self);
static void TEST7__HISTORY1__OFF_ev4(Spec2Sm* self);
static void TEST7__HISTORY1__OFF_ev7(Spec2Sm* self);

static void TEST7__HISTORY1__OFF1_enter(Spec2Sm* self);
static void TEST7__HISTORY1__OFF1_exit(Spec2Sm* self);
static void TEST7__HISTORY1__OFF1_ev1(Spec2Sm* self);

static void TEST7__HISTORY1__OFF2_enter(Spec2Sm* self);
static void TEST7__HISTORY1__OFF2_exit(Spec2Sm* self);
static void TEST7__HISTORY1__OFF2_ev1(Spec2Sm* self);

static void TEST7__HISTORY1__OFF3_enter(Spec2Sm* self);
static void TEST7__HISTORY1__OFF3_exit(Spec2Sm* self);

static void TEST7__HISTORY1__ON_enter(Spec2Sm* self);
static void TEST7__HISTORY1__ON_exit(Spec2Sm* self);
static void TEST7__HISTORY1__ON_ev6(Spec2Sm* self);

static void TEST7__HISTORY1__ON1_enter(Spec2Sm* self);
static void TEST7__HISTORY1__ON1_exit(Spec2Sm* self);
static void TEST7__HISTORY1__ON1_ev1(Spec2Sm* self);

static void TEST7__HISTORY1__ON2_enter(Spec2Sm* self);
static void TEST7__HISTORY1__ON2_exit(Spec2Sm* self);
static void TEST7__HISTORY1__ON2_ev1(Spec2Sm* self);

static void TEST7__HISTORY1__ON3_enter(Spec2Sm* self);
static void TEST7__HISTORY1__ON3_exit(Spec2Sm* self);
static void TEST7__HISTORY1__ON3_ev1(Spec2Sm* self);

static void TEST7__HISTORY2_enter(Spec2Sm* self);
static void TEST7__HISTORY2_exit(Spec2Sm* self);

static void TEST7__HISTORY2__S1_enter(Spec2Sm* self);
static void TEST7__HISTORY2__S1_exit(Spec2Sm* self);

static void TEST7__INITIAL1_enter(Spec2Sm* self);
static void TEST7__INITIAL1_exit(Spec2Sm* self);

static void TEST7__INITIAL1__PARENT_enter(Spec2Sm* self);
static void TEST7__INITIAL1__PARENT_exit(Spec2Sm* self);
static void TEST7__INITIAL1__PARENT_ev5(Spec2Sm* self);

static void TEST7__INITIAL1__G_enter(Spec2Sm* self);
static void TEST7__INITIAL1__G_exit(Spec2Sm* self);
static void TEST7__INITIAL1__G_ev2(Spec2Sm* self);

static void TEST7__INITIAL1__G_S1_enter(Spec2Sm* self);
static void TEST7__INITIAL1__G_S1_exit(Spec2Sm* self);

static void TEST7__INITIAL1__G_S2_enter(Spec2Sm* self);
static void TEST7__INITIAL1__G_S2_exit(Spec2Sm* self);

static void TEST7__INITIAL1__G_S3_enter(Spec2Sm* self);
static void TEST7__INITIAL1__G_S3_exit(Spec2Sm* self);

static void TEST7__INITIAL1__S1_enter(Spec2Sm* self);
static void TEST7__INITIAL1__S1_exit(Spec2Sm* self);
static void TEST7__INITIAL1__S1_ev1(Spec2Sm* self);
static void TEST7__INITIAL1__S1_ev3(Spec2Sm* self);

static void TEST7_DECIDE_enter(Spec2Sm* self);
static void TEST7_DECIDE_exit(Spec2Sm* self);
static void TEST7_DECIDE_ev1(Spec2Sm* self);
static void TEST7_DECIDE_ev2(Spec2Sm* self);
static void TEST7_DECIDE_ev3(Spec2Sm* self);

static void TEST8_ENTRY_CHOICE_enter(Spec2Sm* self);
static void TEST8_ENTRY_CHOICE_exit(Spec2Sm* self);

static void TEST8_ROOT_enter(Spec2Sm* self);
static void TEST8_ROOT_exit(Spec2Sm* self);
static void TEST8_ROOT_ev3(Spec2Sm* self);
static void TEST8_ROOT_ev5(Spec2Sm* self);

static void TEST8_G_enter(Spec2Sm* self);
static void TEST8_G_exit(Spec2Sm* self);
static void TEST8_G_ev2(Spec2Sm* self);

static void TEST8_G_S1_enter(Spec2Sm* self);
static void TEST8_G_S1_exit(Spec2Sm* self);

static void TEST8_G_S2_enter(Spec2Sm* self);
static void TEST8_G_S2_exit(Spec2Sm* self);

static void TEST8_G_S3_enter(Spec2Sm* self);
static void TEST8_G_S3_exit(Spec2Sm* self);

static void TEST8_S1_enter(Spec2Sm* self);
static void TEST8_S1_exit(Spec2Sm* self);
static void TEST8_S1_ev1(Spec2Sm* self);
static void TEST8_S1_ev3(Spec2Sm* self);
static void TEST8_S1_ev6(Spec2Sm* self);

static void TEST9_EXIT_CHOICE_enter(Spec2Sm* self);
static void TEST9_EXIT_CHOICE_exit(Spec2Sm* self);

static void TEST9_DECIDE_enter(Spec2Sm* self);
static void TEST9_DECIDE_exit(Spec2Sm* self);
static void TEST9_DECIDE_ev1(Spec2Sm* self);
static void TEST9_DECIDE_ev2(Spec2Sm* self);

static void TEST9_ROOT_enter(Spec2Sm* self);
static void TEST9_ROOT_exit(Spec2Sm* self);
static void TEST9_ROOT_ev5(Spec2Sm* self);

static void TEST9_G_S1_enter(Spec2Sm* self);
static void TEST9_G_S1_exit(Spec2Sm* self);

static void TEST9_G_S2_enter(Spec2Sm* self);
static void TEST9_G_S2_exit(Spec2Sm* self);

static void TEST9_G_S3_enter(Spec2Sm* self);
static void TEST9_G_S3_exit(Spec2Sm* self);

static void TEST9_G_S4_enter(Spec2Sm* self);
static void TEST9_G_S4_exit(Spec2Sm* self);

static void TEST9_S1_enter(Spec2Sm* self);
static void TEST9_S1_exit(Spec2Sm* self);

static void TEST9_S1_1_enter(Spec2Sm* self);
static void TEST9_S1_1_exit(Spec2Sm* self);
static void TEST9_S1_1_ev1(Spec2Sm* self);

static void TEST9A_ROOT_enter(Spec2Sm* self);
static void TEST9A_ROOT_exit(Spec2Sm* self);

static void TEST9A_S1_enter(Spec2Sm* self);
static void TEST9A_S1_exit(Spec2Sm* self);

static void TEST9A_S1_1_enter(Spec2Sm* self);
static void TEST9A_S1_1_exit(Spec2Sm* self);
static void TEST9A_S1_1_ev1(Spec2Sm* self);

// This function is used when StateSmith doesn't know what the active leaf state is at compile time due to sub states
// or when multiple states need to be exited.
static void exit_up_to_state_handler(Spec2Sm* self, const Spec2Sm_Func desired_state_exit_handler);

static void TEST8_ROOT_EntryPoint_1__transition(Spec2Sm* self);

static void TEST10_A_ChoicePoint__transition(Spec2Sm* self);

static void TEST10_A_ChoicePoint__transition_kid_index3(Spec2Sm* self);

static void TEST10_A_ChoicePoint_a__transition(Spec2Sm* self);

static void TEST10_A_ChoicePoint_a__transition_kid_index7(Spec2Sm* self);

static void TEST4_S20_InitialState_transition(Spec2Sm* self);

static void TEST8_G_EntryPoint_1__transition(Spec2Sm* self);

static void TEST8_G_EntryPoint_3__transition(Spec2Sm* self);

static void TEST9A_S1_InitialState_transition(Spec2Sm* self);

static void TEST10_G_ChoicePoint__transition(Spec2Sm* self);

static void TEST7__HISTORY1__ON_InitialState_transition(Spec2Sm* self);

static void TEST7__HISTORY1__OFF_InitialState_transition(Spec2Sm* self);

static void TEST7__INITIAL1__PARENT_InitialState_transition(Spec2Sm* self);

static void TEST7__INITIAL1__G_InitialState_transition(Spec2Sm* self);


void Spec2Sm_ctor(Spec2Sm* self)
{
    memset(self, 0, sizeof(*self));
}

static void exit_up_to_state_handler(Spec2Sm* self, const Spec2Sm_Func desired_state_exit_handler)
{
    while (self->current_state_exit_handler != desired_state_exit_handler)
    {
        self->current_state_exit_handler(self);
    }
}

void Spec2Sm_start(Spec2Sm* self)
{
    ROOT_enter(self);
    // ROOT behavior
    // uml: TransitionTo(ROOT.InitialState)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, ROOT_exit);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.InitialState`.
        // ROOT.InitialState is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.InitialState behavior
        // uml: / { trace("Transition action `` for ROOT.InitialState to DECIDE."); } TransitionTo(DECIDE)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for ROOT.InitialState to DECIDE.");`.
            trace("Transition action `` for ROOT.InitialState to DECIDE.");
            
            // Step 3: Enter/move towards transition target `DECIDE`.
            DECIDE_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_DECIDE;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for ROOT.InitialState
    } // end of behavior for ROOT
}

void Spec2Sm_dispatch_event(Spec2Sm* self, enum Spec2Sm_EventId event_id)
{
    Spec2Sm_Func behavior_func = self->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        self->ancestor_event_handler = NULL;
        behavior_func(self);
        behavior_func = self->ancestor_event_handler;
    }
}

const char* Spec2Sm_state_id_to_string(const enum Spec2Sm_StateId id)
{
    switch (id)
    {
        case Spec2Sm_StateId_ROOT: return "ROOT";
        case Spec2Sm_StateId_DECIDE: return "DECIDE";
        case Spec2Sm_StateId_TEST1_DO_EVENT_TESTING: return "TEST1_DO_EVENT_TESTING";
        case Spec2Sm_StateId_TEST1_ROOT: return "TEST1_ROOT";
        case Spec2Sm_StateId_TEST1_S1: return "TEST1_S1";
        case Spec2Sm_StateId_TEST1_S1_1: return "TEST1_S1_1";
        case Spec2Sm_StateId_TEST1_S2: return "TEST1_S2";
        case Spec2Sm_StateId_TEST10_CHOICE_POINT: return "TEST10_CHOICE_POINT";
        case Spec2Sm_StateId_TEST10_A: return "TEST10_A";
        case Spec2Sm_StateId_TEST10_A_1: return "TEST10_A_1";
        case Spec2Sm_StateId_TEST10_ROOT: return "TEST10_ROOT";
        case Spec2Sm_StateId_TEST10_G: return "TEST10_G";
        case Spec2Sm_StateId_TEST10_G_S0: return "TEST10_G_S0";
        case Spec2Sm_StateId_TEST10_G_S1: return "TEST10_G_S1";
        case Spec2Sm_StateId_TEST10_G_S2: return "TEST10_G_S2";
        case Spec2Sm_StateId_TEST10_G_S3: return "TEST10_G_S3";
        case Spec2Sm_StateId_TEST10_S1: return "TEST10_S1";
        case Spec2Sm_StateId_TEST10_S4: return "TEST10_S4";
        case Spec2Sm_StateId_TEST2_REGULAR_EVENT_TESTING: return "TEST2_REGULAR_EVENT_TESTING";
        case Spec2Sm_StateId_TEST2_ROOT: return "TEST2_ROOT";
        case Spec2Sm_StateId_TEST2_S1: return "TEST2_S1";
        case Spec2Sm_StateId_TEST2_S1_1: return "TEST2_S1_1";
        case Spec2Sm_StateId_TEST2_S2: return "TEST2_S2";
        case Spec2Sm_StateId_TEST3_BEHAVIOR_ORDERING: return "TEST3_BEHAVIOR_ORDERING";
        case Spec2Sm_StateId_TEST3_ROOT: return "TEST3_ROOT";
        case Spec2Sm_StateId_TEST3_S1: return "TEST3_S1";
        case Spec2Sm_StateId_TEST3_S2: return "TEST3_S2";
        case Spec2Sm_StateId_TEST3_S3: return "TEST3_S3";
        case Spec2Sm_StateId_TEST4_PARENT_CHILD_TRANSITIONS: return "TEST4_PARENT_CHILD_TRANSITIONS";
        case Spec2Sm_StateId_TEST4_B_AND_OTHERS: return "TEST4_B_AND_OTHERS";
        case Spec2Sm_StateId_TEST4B_LOCAL: return "TEST4B_LOCAL";
        case Spec2Sm_StateId_TEST4B_G: return "TEST4B_G";
        case Spec2Sm_StateId_TEST4B_G_1: return "TEST4B_G_1";
        case Spec2Sm_StateId_TEST4C_LOCAL_TO_ALIAS: return "TEST4C_LOCAL_TO_ALIAS";
        case Spec2Sm_StateId_TEST4C_G: return "TEST4C_G";
        case Spec2Sm_StateId_TEST4C_G_1: return "TEST4C_G_1";
        case Spec2Sm_StateId_TEST4D_EXTERNAL: return "TEST4D_EXTERNAL";
        case Spec2Sm_StateId_TEST4D_G: return "TEST4D_G";
        case Spec2Sm_StateId_TEST4D_G_1: return "TEST4D_G_1";
        case Spec2Sm_StateId_TEST4_DECIDE: return "TEST4_DECIDE";
        case Spec2Sm_StateId_TEST4_ROOT: return "TEST4_ROOT";
        case Spec2Sm_StateId_TEST4_S1: return "TEST4_S1";
        case Spec2Sm_StateId_TEST4_S10: return "TEST4_S10";
        case Spec2Sm_StateId_TEST4_S10_1: return "TEST4_S10_1";
        case Spec2Sm_StateId_TEST4_S2: return "TEST4_S2";
        case Spec2Sm_StateId_TEST4_S20: return "TEST4_S20";
        case Spec2Sm_StateId_TEST4_S20_1: return "TEST4_S20_1";
        case Spec2Sm_StateId_TEST4_S3: return "TEST4_S3";
        case Spec2Sm_StateId_TEST5_PARENT_CHILD_TRANSITIONS_ALIAS: return "TEST5_PARENT_CHILD_TRANSITIONS_ALIAS";
        case Spec2Sm_StateId_TEST5_ROOT: return "TEST5_ROOT";
        case Spec2Sm_StateId_TEST5_S1: return "TEST5_S1";
        case Spec2Sm_StateId_TEST5_S2: return "TEST5_S2";
        case Spec2Sm_StateId_TEST5_S3: return "TEST5_S3";
        case Spec2Sm_StateId_TEST6_VARIABLES: return "TEST6_VARIABLES";
        case Spec2Sm_StateId_TEST6_ROOT: return "TEST6_ROOT";
        case Spec2Sm_StateId_TEST6_S1: return "TEST6_S1";
        case Spec2Sm_StateId_TEST6_S2: return "TEST6_S2";
        case Spec2Sm_StateId_TEST7_INITIAL_OR_HISTORY: return "TEST7_INITIAL_OR_HISTORY";
        case Spec2Sm_StateId_TEST7: return "TEST7";
        case Spec2Sm_StateId_TEST7__HISTORY1: return "TEST7__HISTORY1";
        case Spec2Sm_StateId_TEST7__HISTORY1__OFF: return "TEST7__HISTORY1__OFF";
        case Spec2Sm_StateId_TEST7__HISTORY1__OFF1: return "TEST7__HISTORY1__OFF1";
        case Spec2Sm_StateId_TEST7__HISTORY1__OFF2: return "TEST7__HISTORY1__OFF2";
        case Spec2Sm_StateId_TEST7__HISTORY1__OFF3: return "TEST7__HISTORY1__OFF3";
        case Spec2Sm_StateId_TEST7__HISTORY1__ON: return "TEST7__HISTORY1__ON";
        case Spec2Sm_StateId_TEST7__HISTORY1__ON1: return "TEST7__HISTORY1__ON1";
        case Spec2Sm_StateId_TEST7__HISTORY1__ON2: return "TEST7__HISTORY1__ON2";
        case Spec2Sm_StateId_TEST7__HISTORY1__ON3: return "TEST7__HISTORY1__ON3";
        case Spec2Sm_StateId_TEST7__HISTORY2: return "TEST7__HISTORY2";
        case Spec2Sm_StateId_TEST7__HISTORY2__S1: return "TEST7__HISTORY2__S1";
        case Spec2Sm_StateId_TEST7__INITIAL1: return "TEST7__INITIAL1";
        case Spec2Sm_StateId_TEST7__INITIAL1__PARENT: return "TEST7__INITIAL1__PARENT";
        case Spec2Sm_StateId_TEST7__INITIAL1__G: return "TEST7__INITIAL1__G";
        case Spec2Sm_StateId_TEST7__INITIAL1__G_S1: return "TEST7__INITIAL1__G_S1";
        case Spec2Sm_StateId_TEST7__INITIAL1__G_S2: return "TEST7__INITIAL1__G_S2";
        case Spec2Sm_StateId_TEST7__INITIAL1__G_S3: return "TEST7__INITIAL1__G_S3";
        case Spec2Sm_StateId_TEST7__INITIAL1__S1: return "TEST7__INITIAL1__S1";
        case Spec2Sm_StateId_TEST7_DECIDE: return "TEST7_DECIDE";
        case Spec2Sm_StateId_TEST8_ENTRY_CHOICE: return "TEST8_ENTRY_CHOICE";
        case Spec2Sm_StateId_TEST8_ROOT: return "TEST8_ROOT";
        case Spec2Sm_StateId_TEST8_G: return "TEST8_G";
        case Spec2Sm_StateId_TEST8_G_S1: return "TEST8_G_S1";
        case Spec2Sm_StateId_TEST8_G_S2: return "TEST8_G_S2";
        case Spec2Sm_StateId_TEST8_G_S3: return "TEST8_G_S3";
        case Spec2Sm_StateId_TEST8_S1: return "TEST8_S1";
        case Spec2Sm_StateId_TEST9_EXIT_CHOICE: return "TEST9_EXIT_CHOICE";
        case Spec2Sm_StateId_TEST9_DECIDE: return "TEST9_DECIDE";
        case Spec2Sm_StateId_TEST9_ROOT: return "TEST9_ROOT";
        case Spec2Sm_StateId_TEST9_G_S1: return "TEST9_G_S1";
        case Spec2Sm_StateId_TEST9_G_S2: return "TEST9_G_S2";
        case Spec2Sm_StateId_TEST9_G_S3: return "TEST9_G_S3";
        case Spec2Sm_StateId_TEST9_G_S4: return "TEST9_G_S4";
        case Spec2Sm_StateId_TEST9_S1: return "TEST9_S1";
        case Spec2Sm_StateId_TEST9_S1_1: return "TEST9_S1_1";
        case Spec2Sm_StateId_TEST9A_ROOT: return "TEST9A_ROOT";
        case Spec2Sm_StateId_TEST9A_S1: return "TEST9A_S1";
        case Spec2Sm_StateId_TEST9A_S1_1: return "TEST9A_S1_1";
        default: return "?";
    }
}

////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = ROOT_exit;
    
    // ROOT behavior
    // uml: enter / { trace("Enter Spec2Sm."); }
    {
        // Step 1: execute action `trace("Enter Spec2Sm.");`
        trace("Enter Spec2Sm.");
    } // end of behavior for ROOT
}

static void ROOT_exit(Spec2Sm* self)
{
    // ROOT behavior
    // uml: exit / { trace("Exit Spec2Sm."); }
    {
        // Step 1: execute action `trace("Exit Spec2Sm.");`
        trace("Exit Spec2Sm.");
    } // end of behavior for ROOT
    
    // State machine root is a special case. It cannot be exited.
    (void)self;  // nothing to see here compiler. move along!
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state DECIDE
////////////////////////////////////////////////////////////////////////////////

static void DECIDE_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = DECIDE_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = DECIDE_ev1;
    self->current_event_handlers[Spec2Sm_EventId_EV10] = DECIDE_ev10;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = DECIDE_ev2;
    self->current_event_handlers[Spec2Sm_EventId_EV3] = DECIDE_ev3;
    self->current_event_handlers[Spec2Sm_EventId_EV4] = DECIDE_ev4;
    self->current_event_handlers[Spec2Sm_EventId_EV5] = DECIDE_ev5;
    self->current_event_handlers[Spec2Sm_EventId_EV6] = DECIDE_ev6;
    self->current_event_handlers[Spec2Sm_EventId_EV7] = DECIDE_ev7;
    self->current_event_handlers[Spec2Sm_EventId_EV8] = DECIDE_ev8;
    self->current_event_handlers[Spec2Sm_EventId_EV9] = DECIDE_ev9;
    
    // DECIDE behavior
    // uml: enter / { trace("Enter DECIDE."); }
    {
        // Step 1: execute action `trace("Enter DECIDE.");`
        trace("Enter DECIDE.");
    } // end of behavior for DECIDE
}

static void DECIDE_exit(Spec2Sm* self)
{
    // DECIDE behavior
    // uml: exit / { trace("Exit DECIDE."); }
    {
        // Step 1: execute action `trace("Exit DECIDE.");`
        trace("Exit DECIDE.");
    } // end of behavior for DECIDE
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV10] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV3] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV4] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV5] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV6] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV7] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV8] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV9] = NULL;  // no ancestor listens to this event
}

static void DECIDE_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // DECIDE behavior
    // uml: EV1 [trace_guard("State DECIDE: check behavior `EV1 TransitionTo(TEST1_DO_EVENT_TESTING)`.", true)] / { trace("Transition action `` for DECIDE to TEST1_DO_EVENT_TESTING."); } TransitionTo(TEST1_DO_EVENT_TESTING)
    if (trace_guard("State DECIDE: check behavior `EV1 TransitionTo(TEST1_DO_EVENT_TESTING)`.", true))
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        DECIDE_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for DECIDE to TEST1_DO_EVENT_TESTING.");`.
        trace("Transition action `` for DECIDE to TEST1_DO_EVENT_TESTING.");
        
        // Step 3: Enter/move towards transition target `TEST1_DO_EVENT_TESTING`.
        TEST1_DO_EVENT_TESTING_enter(self);
        
        // TEST1_DO_EVENT_TESTING.InitialState behavior
        // uml: / { trace("Transition action `` for TEST1_DO_EVENT_TESTING.InitialState to TEST1_ROOT."); } TransitionTo(TEST1_ROOT)
        {
            // Step 1: Exit states until we reach `TEST1_DO_EVENT_TESTING` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST1_DO_EVENT_TESTING.InitialState to TEST1_ROOT.");`.
            trace("Transition action `` for TEST1_DO_EVENT_TESTING.InitialState to TEST1_ROOT.");
            
            // Step 3: Enter/move towards transition target `TEST1_ROOT`.
            TEST1_ROOT_enter(self);
            
            // TEST1_ROOT.InitialState behavior
            // uml: / { trace("Transition action `` for TEST1_ROOT.InitialState to TEST1_S1_1."); } TransitionTo(TEST1_S1_1)
            {
                // Step 1: Exit states until we reach `TEST1_ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `trace("Transition action `` for TEST1_ROOT.InitialState to TEST1_S1_1.");`.
                trace("Transition action `` for TEST1_ROOT.InitialState to TEST1_S1_1.");
                
                // Step 3: Enter/move towards transition target `TEST1_S1_1`.
                TEST1_S1_enter(self);
                TEST1_S1_1_enter(self);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                self->state_id = Spec2Sm_StateId_TEST1_S1_1;
                // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
                return;
            } // end of behavior for TEST1_ROOT.InitialState
        } // end of behavior for TEST1_DO_EVENT_TESTING.InitialState
    } // end of behavior for DECIDE
}

static void DECIDE_ev10(Spec2Sm* self)
{
    // No ancestor state handles `EV10` event.
    
    // DECIDE behavior
    // uml: EV10 [trace_guard("State DECIDE: check behavior `EV10 TransitionTo(TEST10_CHOICE_POINT)`.", true)] / { trace("Transition action `` for DECIDE to TEST10_CHOICE_POINT."); } TransitionTo(TEST10_CHOICE_POINT)
    if (trace_guard("State DECIDE: check behavior `EV10 TransitionTo(TEST10_CHOICE_POINT)`.", true))
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        DECIDE_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for DECIDE to TEST10_CHOICE_POINT.");`.
        trace("Transition action `` for DECIDE to TEST10_CHOICE_POINT.");
        
        // Step 3: Enter/move towards transition target `TEST10_CHOICE_POINT`.
        TEST10_CHOICE_POINT_enter(self);
        
        // TEST10_CHOICE_POINT.InitialState behavior
        // uml: / { trace("Transition action `` for TEST10_CHOICE_POINT.InitialState to TEST10_S1."); } TransitionTo(TEST10_S1)
        {
            // Step 1: Exit states until we reach `TEST10_CHOICE_POINT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST10_CHOICE_POINT.InitialState to TEST10_S1.");`.
            trace("Transition action `` for TEST10_CHOICE_POINT.InitialState to TEST10_S1.");
            
            // Step 3: Enter/move towards transition target `TEST10_S1`.
            TEST10_ROOT_enter(self);
            TEST10_S1_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_TEST10_S1;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for TEST10_CHOICE_POINT.InitialState
    } // end of behavior for DECIDE
}

static void DECIDE_ev2(Spec2Sm* self)
{
    // No ancestor state handles `EV2` event.
    
    // DECIDE behavior
    // uml: EV2 [trace_guard("State DECIDE: check behavior `EV2 TransitionTo(TEST2_REGULAR_EVENT_TESTING)`.", true)] / { trace("Transition action `` for DECIDE to TEST2_REGULAR_EVENT_TESTING."); } TransitionTo(TEST2_REGULAR_EVENT_TESTING)
    if (trace_guard("State DECIDE: check behavior `EV2 TransitionTo(TEST2_REGULAR_EVENT_TESTING)`.", true))
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        DECIDE_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for DECIDE to TEST2_REGULAR_EVENT_TESTING.");`.
        trace("Transition action `` for DECIDE to TEST2_REGULAR_EVENT_TESTING.");
        
        // Step 3: Enter/move towards transition target `TEST2_REGULAR_EVENT_TESTING`.
        TEST2_REGULAR_EVENT_TESTING_enter(self);
        
        // TEST2_REGULAR_EVENT_TESTING.InitialState behavior
        // uml: / { trace("Transition action `` for TEST2_REGULAR_EVENT_TESTING.InitialState to TEST2_ROOT."); } TransitionTo(TEST2_ROOT)
        {
            // Step 1: Exit states until we reach `TEST2_REGULAR_EVENT_TESTING` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST2_REGULAR_EVENT_TESTING.InitialState to TEST2_ROOT.");`.
            trace("Transition action `` for TEST2_REGULAR_EVENT_TESTING.InitialState to TEST2_ROOT.");
            
            // Step 3: Enter/move towards transition target `TEST2_ROOT`.
            TEST2_ROOT_enter(self);
            
            // TEST2_ROOT.InitialState behavior
            // uml: / { trace("Transition action `` for TEST2_ROOT.InitialState to TEST2_S1_1."); } TransitionTo(TEST2_S1_1)
            {
                // Step 1: Exit states until we reach `TEST2_ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `trace("Transition action `` for TEST2_ROOT.InitialState to TEST2_S1_1.");`.
                trace("Transition action `` for TEST2_ROOT.InitialState to TEST2_S1_1.");
                
                // Step 3: Enter/move towards transition target `TEST2_S1_1`.
                TEST2_S1_enter(self);
                TEST2_S1_1_enter(self);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                self->state_id = Spec2Sm_StateId_TEST2_S1_1;
                // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
                return;
            } // end of behavior for TEST2_ROOT.InitialState
        } // end of behavior for TEST2_REGULAR_EVENT_TESTING.InitialState
    } // end of behavior for DECIDE
}

static void DECIDE_ev3(Spec2Sm* self)
{
    // No ancestor state handles `EV3` event.
    
    // DECIDE behavior
    // uml: EV3 [trace_guard("State DECIDE: check behavior `EV3 TransitionTo(TEST3_BEHAVIOR_ORDERING)`.", true)] / { trace("Transition action `` for DECIDE to TEST3_BEHAVIOR_ORDERING."); } TransitionTo(TEST3_BEHAVIOR_ORDERING)
    if (trace_guard("State DECIDE: check behavior `EV3 TransitionTo(TEST3_BEHAVIOR_ORDERING)`.", true))
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        DECIDE_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for DECIDE to TEST3_BEHAVIOR_ORDERING.");`.
        trace("Transition action `` for DECIDE to TEST3_BEHAVIOR_ORDERING.");
        
        // Step 3: Enter/move towards transition target `TEST3_BEHAVIOR_ORDERING`.
        TEST3_BEHAVIOR_ORDERING_enter(self);
        
        // TEST3_BEHAVIOR_ORDERING.InitialState behavior
        // uml: / { trace("Transition action `` for TEST3_BEHAVIOR_ORDERING.InitialState to TEST3_ROOT."); } TransitionTo(TEST3_ROOT)
        {
            // Step 1: Exit states until we reach `TEST3_BEHAVIOR_ORDERING` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST3_BEHAVIOR_ORDERING.InitialState to TEST3_ROOT.");`.
            trace("Transition action `` for TEST3_BEHAVIOR_ORDERING.InitialState to TEST3_ROOT.");
            
            // Step 3: Enter/move towards transition target `TEST3_ROOT`.
            TEST3_ROOT_enter(self);
            
            // TEST3_ROOT.InitialState behavior
            // uml: / { trace("Transition action `` for TEST3_ROOT.InitialState to TEST3_S1."); } TransitionTo(TEST3_S1)
            {
                // Step 1: Exit states until we reach `TEST3_ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `trace("Transition action `` for TEST3_ROOT.InitialState to TEST3_S1.");`.
                trace("Transition action `` for TEST3_ROOT.InitialState to TEST3_S1.");
                
                // Step 3: Enter/move towards transition target `TEST3_S1`.
                TEST3_S1_enter(self);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                self->state_id = Spec2Sm_StateId_TEST3_S1;
                // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
                return;
            } // end of behavior for TEST3_ROOT.InitialState
        } // end of behavior for TEST3_BEHAVIOR_ORDERING.InitialState
    } // end of behavior for DECIDE
}

static void DECIDE_ev4(Spec2Sm* self)
{
    // No ancestor state handles `EV4` event.
    
    // DECIDE behavior
    // uml: EV4 [trace_guard("State DECIDE: check behavior `EV4 TransitionTo(TEST4_PARENT_CHILD_TRANSITIONS)`.", true)] / { trace("Transition action `` for DECIDE to TEST4_PARENT_CHILD_TRANSITIONS."); } TransitionTo(TEST4_PARENT_CHILD_TRANSITIONS)
    if (trace_guard("State DECIDE: check behavior `EV4 TransitionTo(TEST4_PARENT_CHILD_TRANSITIONS)`.", true))
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        DECIDE_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for DECIDE to TEST4_PARENT_CHILD_TRANSITIONS.");`.
        trace("Transition action `` for DECIDE to TEST4_PARENT_CHILD_TRANSITIONS.");
        
        // Step 3: Enter/move towards transition target `TEST4_PARENT_CHILD_TRANSITIONS`.
        TEST4_PARENT_CHILD_TRANSITIONS_enter(self);
        
        // TEST4_PARENT_CHILD_TRANSITIONS.InitialState behavior
        // uml: / { trace("Transition action `` for TEST4_PARENT_CHILD_TRANSITIONS.InitialState to TEST4_DECIDE."); } TransitionTo(TEST4_DECIDE)
        {
            // Step 1: Exit states until we reach `TEST4_PARENT_CHILD_TRANSITIONS` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST4_PARENT_CHILD_TRANSITIONS.InitialState to TEST4_DECIDE.");`.
            trace("Transition action `` for TEST4_PARENT_CHILD_TRANSITIONS.InitialState to TEST4_DECIDE.");
            
            // Step 3: Enter/move towards transition target `TEST4_DECIDE`.
            TEST4_DECIDE_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_TEST4_DECIDE;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for TEST4_PARENT_CHILD_TRANSITIONS.InitialState
    } // end of behavior for DECIDE
}

static void DECIDE_ev5(Spec2Sm* self)
{
    // No ancestor state handles `EV5` event.
    
    // DECIDE behavior
    // uml: EV5 [trace_guard("State DECIDE: check behavior `EV5 TransitionTo(TEST5_PARENT_CHILD_TRANSITIONS_ALIAS)`.", true)] / { trace("Transition action `` for DECIDE to TEST5_PARENT_CHILD_TRANSITIONS_ALIAS."); } TransitionTo(TEST5_PARENT_CHILD_TRANSITIONS_ALIAS)
    if (trace_guard("State DECIDE: check behavior `EV5 TransitionTo(TEST5_PARENT_CHILD_TRANSITIONS_ALIAS)`.", true))
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        DECIDE_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for DECIDE to TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.");`.
        trace("Transition action `` for DECIDE to TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.");
        
        // Step 3: Enter/move towards transition target `TEST5_PARENT_CHILD_TRANSITIONS_ALIAS`.
        TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_enter(self);
        
        // TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.InitialState behavior
        // uml: / { trace("Transition action `` for TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.InitialState to TEST5_ROOT."); } TransitionTo(TEST5_ROOT)
        {
            // Step 1: Exit states until we reach `TEST5_PARENT_CHILD_TRANSITIONS_ALIAS` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.InitialState to TEST5_ROOT.");`.
            trace("Transition action `` for TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.InitialState to TEST5_ROOT.");
            
            // Step 3: Enter/move towards transition target `TEST5_ROOT`.
            TEST5_ROOT_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_TEST5_ROOT;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.InitialState
    } // end of behavior for DECIDE
}

static void DECIDE_ev6(Spec2Sm* self)
{
    // No ancestor state handles `EV6` event.
    
    // DECIDE behavior
    // uml: EV6 [trace_guard("State DECIDE: check behavior `EV6 TransitionTo(TEST6_VARIABLES)`.", true)] / { trace("Transition action `` for DECIDE to TEST6_VARIABLES."); } TransitionTo(TEST6_VARIABLES)
    if (trace_guard("State DECIDE: check behavior `EV6 TransitionTo(TEST6_VARIABLES)`.", true))
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        DECIDE_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for DECIDE to TEST6_VARIABLES.");`.
        trace("Transition action `` for DECIDE to TEST6_VARIABLES.");
        
        // Step 3: Enter/move towards transition target `TEST6_VARIABLES`.
        TEST6_VARIABLES_enter(self);
        
        // TEST6_VARIABLES.InitialState behavior
        // uml: / { trace("Transition action `` for TEST6_VARIABLES.InitialState to TEST6_ROOT."); } TransitionTo(TEST6_ROOT)
        {
            // Step 1: Exit states until we reach `TEST6_VARIABLES` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST6_VARIABLES.InitialState to TEST6_ROOT.");`.
            trace("Transition action `` for TEST6_VARIABLES.InitialState to TEST6_ROOT.");
            
            // Step 3: Enter/move towards transition target `TEST6_ROOT`.
            TEST6_ROOT_enter(self);
            
            // TEST6_ROOT.InitialState behavior
            // uml: / { trace("Transition action `` for TEST6_ROOT.InitialState to TEST6_S1."); } TransitionTo(TEST6_S1)
            {
                // Step 1: Exit states until we reach `TEST6_ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `trace("Transition action `` for TEST6_ROOT.InitialState to TEST6_S1.");`.
                trace("Transition action `` for TEST6_ROOT.InitialState to TEST6_S1.");
                
                // Step 3: Enter/move towards transition target `TEST6_S1`.
                TEST6_S1_enter(self);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                self->state_id = Spec2Sm_StateId_TEST6_S1;
                // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
                return;
            } // end of behavior for TEST6_ROOT.InitialState
        } // end of behavior for TEST6_VARIABLES.InitialState
    } // end of behavior for DECIDE
}

static void DECIDE_ev7(Spec2Sm* self)
{
    // No ancestor state handles `EV7` event.
    
    // DECIDE behavior
    // uml: EV7 [trace_guard("State DECIDE: check behavior `EV7 TransitionTo(TEST7_INITIAL_OR_HISTORY)`.", true)] / { trace("Transition action `` for DECIDE to TEST7_INITIAL_OR_HISTORY."); } TransitionTo(TEST7_INITIAL_OR_HISTORY)
    if (trace_guard("State DECIDE: check behavior `EV7 TransitionTo(TEST7_INITIAL_OR_HISTORY)`.", true))
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        DECIDE_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for DECIDE to TEST7_INITIAL_OR_HISTORY.");`.
        trace("Transition action `` for DECIDE to TEST7_INITIAL_OR_HISTORY.");
        
        // Step 3: Enter/move towards transition target `TEST7_INITIAL_OR_HISTORY`.
        TEST7_INITIAL_OR_HISTORY_enter(self);
        
        // TEST7_INITIAL_OR_HISTORY.InitialState behavior
        // uml: / { trace("Transition action `` for TEST7_INITIAL_OR_HISTORY.InitialState to TEST7_DECIDE."); } TransitionTo(TEST7_DECIDE)
        {
            // Step 1: Exit states until we reach `TEST7_INITIAL_OR_HISTORY` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST7_INITIAL_OR_HISTORY.InitialState to TEST7_DECIDE.");`.
            trace("Transition action `` for TEST7_INITIAL_OR_HISTORY.InitialState to TEST7_DECIDE.");
            
            // Step 3: Enter/move towards transition target `TEST7_DECIDE`.
            TEST7_DECIDE_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_TEST7_DECIDE;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for TEST7_INITIAL_OR_HISTORY.InitialState
    } // end of behavior for DECIDE
}

static void DECIDE_ev8(Spec2Sm* self)
{
    // No ancestor state handles `EV8` event.
    
    // DECIDE behavior
    // uml: EV8 [trace_guard("State DECIDE: check behavior `EV8 TransitionTo(TEST8_ENTRY_CHOICE)`.", true)] / { trace("Transition action `` for DECIDE to TEST8_ENTRY_CHOICE."); } TransitionTo(TEST8_ENTRY_CHOICE)
    if (trace_guard("State DECIDE: check behavior `EV8 TransitionTo(TEST8_ENTRY_CHOICE)`.", true))
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        DECIDE_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for DECIDE to TEST8_ENTRY_CHOICE.");`.
        trace("Transition action `` for DECIDE to TEST8_ENTRY_CHOICE.");
        
        // Step 3: Enter/move towards transition target `TEST8_ENTRY_CHOICE`.
        TEST8_ENTRY_CHOICE_enter(self);
        
        // TEST8_ENTRY_CHOICE.InitialState behavior
        // uml: / { trace("Transition action `` for TEST8_ENTRY_CHOICE.InitialState to TEST8_ROOT.EntryPoint(1)."); } TransitionTo(TEST8_ROOT.EntryPoint(1))
        {
            // Step 1: Exit states until we reach `TEST8_ENTRY_CHOICE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST8_ENTRY_CHOICE.InitialState to TEST8_ROOT.EntryPoint(1).");`.
            trace("Transition action `` for TEST8_ENTRY_CHOICE.InitialState to TEST8_ROOT.EntryPoint(1).");
            
            // Step 3: Enter/move towards transition target `TEST8_ROOT.EntryPoint(1)`.
            TEST8_ROOT_enter(self);
            // TEST8_ROOT.EntryPoint(1) is a pseudo state and cannot have an `enter` trigger.
            
            // Finish transition by calling pseudo state transition function.
            TEST8_ROOT_EntryPoint_1__transition(self);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for TEST8_ENTRY_CHOICE.InitialState
    } // end of behavior for DECIDE
}

static void DECIDE_ev9(Spec2Sm* self)
{
    // No ancestor state handles `EV9` event.
    
    // DECIDE behavior
    // uml: EV9 [trace_guard("State DECIDE: check behavior `EV9 TransitionTo(TEST9_EXIT_CHOICE)`.", true)] / { trace("Transition action `` for DECIDE to TEST9_EXIT_CHOICE."); } TransitionTo(TEST9_EXIT_CHOICE)
    if (trace_guard("State DECIDE: check behavior `EV9 TransitionTo(TEST9_EXIT_CHOICE)`.", true))
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        DECIDE_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for DECIDE to TEST9_EXIT_CHOICE.");`.
        trace("Transition action `` for DECIDE to TEST9_EXIT_CHOICE.");
        
        // Step 3: Enter/move towards transition target `TEST9_EXIT_CHOICE`.
        TEST9_EXIT_CHOICE_enter(self);
        
        // TEST9_EXIT_CHOICE.InitialState behavior
        // uml: / { trace("Transition action `` for TEST9_EXIT_CHOICE.InitialState to TEST9_DECIDE."); } TransitionTo(TEST9_DECIDE)
        {
            // Step 1: Exit states until we reach `TEST9_EXIT_CHOICE` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST9_EXIT_CHOICE.InitialState to TEST9_DECIDE.");`.
            trace("Transition action `` for TEST9_EXIT_CHOICE.InitialState to TEST9_DECIDE.");
            
            // Step 3: Enter/move towards transition target `TEST9_DECIDE`.
            TEST9_DECIDE_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_TEST9_DECIDE;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for TEST9_EXIT_CHOICE.InitialState
    } // end of behavior for DECIDE
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_DO_EVENT_TESTING
////////////////////////////////////////////////////////////////////////////////

static void TEST1_DO_EVENT_TESTING_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_DO_EVENT_TESTING_exit;
    
    // TEST1_DO_EVENT_TESTING behavior
    // uml: enter / { trace("Enter TEST1_DO_EVENT_TESTING."); }
    {
        // Step 1: execute action `trace("Enter TEST1_DO_EVENT_TESTING.");`
        trace("Enter TEST1_DO_EVENT_TESTING.");
    } // end of behavior for TEST1_DO_EVENT_TESTING
}

static void TEST1_DO_EVENT_TESTING_exit(Spec2Sm* self)
{
    // TEST1_DO_EVENT_TESTING behavior
    // uml: exit / { trace("Exit TEST1_DO_EVENT_TESTING."); }
    {
        // Step 1: execute action `trace("Exit TEST1_DO_EVENT_TESTING.");`
        trace("Exit TEST1_DO_EVENT_TESTING.");
    } // end of behavior for TEST1_DO_EVENT_TESTING
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST1_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_ROOT_do;
    
    // TEST1_ROOT behavior
    // uml: enter / { trace("Enter TEST1_ROOT."); }
    {
        // Step 1: execute action `trace("Enter TEST1_ROOT.");`
        trace("Enter TEST1_ROOT.");
    } // end of behavior for TEST1_ROOT
}

static void TEST1_ROOT_exit(Spec2Sm* self)
{
    // TEST1_ROOT behavior
    // uml: exit / { trace("Exit TEST1_ROOT."); }
    {
        // Step 1: execute action `trace("Exit TEST1_ROOT.");`
        trace("Exit TEST1_ROOT.");
    } // end of behavior for TEST1_ROOT
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST1_DO_EVENT_TESTING_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void TEST1_ROOT_do(Spec2Sm* self)
{
    // No ancestor state handles `do` event.
    
    // TEST1_ROOT behavior
    // uml: do [trace_guard("State TEST1_ROOT: check behavior `do`.", true)]
    if (trace_guard("State TEST1_ROOT: check behavior `do`.", true))
    {
        // Step 1: execute action ``
        // Step 2: determine if ancestor gets to handle event next.
        // Don't consume special `do` event.
    } // end of behavior for TEST1_ROOT
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST1_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_S1_exit;
    
    // TEST1_S1 behavior
    // uml: enter / { trace("Enter TEST1_S1."); }
    {
        // Step 1: execute action `trace("Enter TEST1_S1.");`
        trace("Enter TEST1_S1.");
    } // end of behavior for TEST1_S1
}

static void TEST1_S1_exit(Spec2Sm* self)
{
    // TEST1_S1 behavior
    // uml: exit / { trace("Exit TEST1_S1."); }
    {
        // Step 1: execute action `trace("Exit TEST1_S1.");`
        trace("Exit TEST1_S1.");
    } // end of behavior for TEST1_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST1_ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_S1_1
////////////////////////////////////////////////////////////////////////////////

static void TEST1_S1_1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_S1_1_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_S1_1_do;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST1_S1_1_ev1;
    
    // TEST1_S1_1 behavior
    // uml: enter / { trace("Enter TEST1_S1_1."); }
    {
        // Step 1: execute action `trace("Enter TEST1_S1_1.");`
        trace("Enter TEST1_S1_1.");
    } // end of behavior for TEST1_S1_1
    
    // TEST1_S1_1 behavior
    // uml: enter [trace_guard("State TEST1_S1_1: check behavior `enter / { clear_output(); }`.", true)] / { clear_output(); }
    if (trace_guard("State TEST1_S1_1: check behavior `enter / { clear_output(); }`.", true))
    {
        // Step 1: execute action `clear_output();`
        trace("IGNORE_OUTPUT_BEFORE_THIS");;
    } // end of behavior for TEST1_S1_1
}

static void TEST1_S1_1_exit(Spec2Sm* self)
{
    // TEST1_S1_1 behavior
    // uml: exit / { trace("Exit TEST1_S1_1."); }
    {
        // Step 1: execute action `trace("Exit TEST1_S1_1.");`
        trace("Exit TEST1_S1_1.");
    } // end of behavior for TEST1_S1_1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST1_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_ROOT_do;  // the next ancestor that handles this event is TEST1_ROOT
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST1_S1_1_do(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `do` event.
    self->ancestor_event_handler = TEST1_ROOT_do;
    
    // TEST1_S1_1 behavior
    // uml: do [trace_guard("State TEST1_S1_1: check behavior `do`.", true)]
    if (trace_guard("State TEST1_S1_1: check behavior `do`.", true))
    {
        // Step 1: execute action ``
        // Step 2: determine if ancestor gets to handle event next.
        // Don't consume special `do` event.
    } // end of behavior for TEST1_S1_1
}

static void TEST1_S1_1_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST1_S1_1 behavior
    // uml: EV1 [trace_guard("State TEST1_S1_1: check behavior `EV1 TransitionTo(TEST1_S2)`.", true)] / { trace("Transition action `` for TEST1_S1_1 to TEST1_S2."); } TransitionTo(TEST1_S2)
    if (trace_guard("State TEST1_S1_1: check behavior `EV1 TransitionTo(TEST1_S2)`.", true))
    {
        // Step 1: Exit states until we reach `TEST1_ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, TEST1_ROOT_exit);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST1_S1_1 to TEST1_S2.");`.
        trace("Transition action `` for TEST1_S1_1 to TEST1_S2.");
        
        // Step 3: Enter/move towards transition target `TEST1_S2`.
        TEST1_S2_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST1_S2;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST1_S1_1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST1_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_S2_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_S2_do;
    
    // TEST1_S2 behavior
    // uml: enter / { trace("Enter TEST1_S2."); }
    {
        // Step 1: execute action `trace("Enter TEST1_S2.");`
        trace("Enter TEST1_S2.");
    } // end of behavior for TEST1_S2
}

static void TEST1_S2_exit(Spec2Sm* self)
{
    // TEST1_S2 behavior
    // uml: exit / { trace("Exit TEST1_S2."); }
    {
        // Step 1: execute action `trace("Exit TEST1_S2.");`
        trace("Exit TEST1_S2.");
    } // end of behavior for TEST1_S2
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST1_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_ROOT_do;  // the next ancestor that handles this event is TEST1_ROOT
}

static void TEST1_S2_do(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `do` event.
    self->ancestor_event_handler = TEST1_ROOT_do;
    
    // TEST1_S2 behavior
    // uml: do [trace_guard("State TEST1_S2: check behavior `do / { consume_event = true; }`.", true)] / { consume_event = true; }
    if (trace_guard("State TEST1_S2: check behavior `do / { consume_event = true; }`.", true))
    {
        bool consume_event = false; // the `do` event is special in that it normally is not consumed.
        
        // Step 1: execute action `consume_event = true;`
        consume_event = true;
        
        // Step 2: determine if ancestor gets to handle event next.
        if (consume_event)
        {
            self->ancestor_event_handler = NULL;  // consume event
        }
    } // end of behavior for TEST1_S2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST10_CHOICE_POINT
////////////////////////////////////////////////////////////////////////////////

static void TEST10_CHOICE_POINT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST10_CHOICE_POINT_exit;
    
    // TEST10_CHOICE_POINT behavior
    // uml: enter / { trace("Enter TEST10_CHOICE_POINT."); }
    {
        // Step 1: execute action `trace("Enter TEST10_CHOICE_POINT.");`
        trace("Enter TEST10_CHOICE_POINT.");
    } // end of behavior for TEST10_CHOICE_POINT
}

static void TEST10_CHOICE_POINT_exit(Spec2Sm* self)
{
    // TEST10_CHOICE_POINT behavior
    // uml: exit / { trace("Exit TEST10_CHOICE_POINT."); }
    {
        // Step 1: execute action `trace("Exit TEST10_CHOICE_POINT.");`
        trace("Exit TEST10_CHOICE_POINT.");
    } // end of behavior for TEST10_CHOICE_POINT
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST10_A
////////////////////////////////////////////////////////////////////////////////

static void TEST10_A_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST10_A_exit;
    
    // TEST10_A behavior
    // uml: enter / { trace("Enter TEST10_A."); }
    {
        // Step 1: execute action `trace("Enter TEST10_A.");`
        trace("Enter TEST10_A.");
    } // end of behavior for TEST10_A
}

static void TEST10_A_exit(Spec2Sm* self)
{
    // TEST10_A behavior
    // uml: exit / { trace("Exit TEST10_A."); }
    {
        // Step 1: execute action `trace("Exit TEST10_A.");`
        trace("Exit TEST10_A.");
    } // end of behavior for TEST10_A
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST10_CHOICE_POINT_exit;
}

static void TEST10_A_ChoicePoint__transition(Spec2Sm* self)
{
    // TEST10_A.ChoicePoint() behavior
    // uml: [count == 1] / { trace("Transition action `` for TEST10_A.ChoicePoint() to TEST10_A.ChoicePoint()."); } TransitionTo(TEST10_A.ChoicePoint())
    if (self->vars.count == 1)
    {
        // Step 1: Exit states until we reach `TEST10_A` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST10_A.ChoicePoint() to TEST10_A.ChoicePoint().");`.
        trace("Transition action `` for TEST10_A.ChoicePoint() to TEST10_A.ChoicePoint().");
        
        // Step 3: Enter/move towards transition target `TEST10_A.ChoicePoint()`.
        // TEST10_A.ChoicePoint() is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        TEST10_A_ChoicePoint__transition_kid_index3(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST10_A.ChoicePoint()
    
    // TEST10_A.ChoicePoint() behavior
    // uml: else / { trace("Transition action `` for TEST10_A.ChoicePoint() to TEST10_A.ChoicePoint()."); } TransitionTo(TEST10_A.ChoicePoint())
    {
        // Step 1: Exit states until we reach `TEST10_A` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST10_A.ChoicePoint() to TEST10_A.ChoicePoint().");`.
        trace("Transition action `` for TEST10_A.ChoicePoint() to TEST10_A.ChoicePoint().");
        
        // Step 3: Enter/move towards transition target `TEST10_A.ChoicePoint()`.
        // TEST10_A.ChoicePoint() is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        TEST10_A_ChoicePoint__transition_kid_index3(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST10_A.ChoicePoint()
}

static void TEST10_A_ChoicePoint__transition_kid_index3(Spec2Sm* self)
{
    // TEST10_A.ChoicePoint() behavior
    // uml: [count == 1] / { trace("Transition action `` for TEST10_A.ChoicePoint() to TEST10_A.ChoicePoint(a)."); } TransitionTo(TEST10_A.ChoicePoint(a))
    if (self->vars.count == 1)
    {
        // Step 1: Exit states until we reach `TEST10_A` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST10_A.ChoicePoint() to TEST10_A.ChoicePoint(a).");`.
        trace("Transition action `` for TEST10_A.ChoicePoint() to TEST10_A.ChoicePoint(a).");
        
        // Step 3: Enter/move towards transition target `TEST10_A.ChoicePoint(a)`.
        // TEST10_A.ChoicePoint(a) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        TEST10_A_ChoicePoint_a__transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST10_A.ChoicePoint()
    
    // TEST10_A.ChoicePoint() behavior
    // uml: else / { trace("Transition action `` for TEST10_A.ChoicePoint() to TEST10_A.ChoicePoint(a)."); } TransitionTo(TEST10_A.ChoicePoint(a))
    {
        // Step 1: Exit states until we reach `TEST10_A` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST10_A.ChoicePoint() to TEST10_A.ChoicePoint(a).");`.
        trace("Transition action `` for TEST10_A.ChoicePoint() to TEST10_A.ChoicePoint(a).");
        
        // Step 3: Enter/move towards transition target `TEST10_A.ChoicePoint(a)`.
        // TEST10_A.ChoicePoint(a) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        TEST10_A_ChoicePoint_a__transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST10_A.ChoicePoint()
}

static void TEST10_A_ChoicePoint_a__transition(Spec2Sm* self)
{
    // TEST10_A.ChoicePoint(a) behavior
    // uml: [count == 1] / { trace("Transition action `` for TEST10_A.ChoicePoint(a) to TEST10_A.ChoicePoint(a)."); } TransitionTo(TEST10_A.ChoicePoint(a))
    if (self->vars.count == 1)
    {
        // Step 1: Exit states until we reach `TEST10_A` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST10_A.ChoicePoint(a) to TEST10_A.ChoicePoint(a).");`.
        trace("Transition action `` for TEST10_A.ChoicePoint(a) to TEST10_A.ChoicePoint(a).");
        
        // Step 3: Enter/move towards transition target `TEST10_A.ChoicePoint(a)`.
        // TEST10_A.ChoicePoint(a) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        TEST10_A_ChoicePoint_a__transition_kid_index7(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST10_A.ChoicePoint(a)
    
    // TEST10_A.ChoicePoint(a) behavior
    // uml: else / { trace("Transition action `` for TEST10_A.ChoicePoint(a) to TEST10_A.ChoicePoint(a)."); } TransitionTo(TEST10_A.ChoicePoint(a))
    {
        // Step 1: Exit states until we reach `TEST10_A` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST10_A.ChoicePoint(a) to TEST10_A.ChoicePoint(a).");`.
        trace("Transition action `` for TEST10_A.ChoicePoint(a) to TEST10_A.ChoicePoint(a).");
        
        // Step 3: Enter/move towards transition target `TEST10_A.ChoicePoint(a)`.
        // TEST10_A.ChoicePoint(a) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        TEST10_A_ChoicePoint_a__transition_kid_index7(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST10_A.ChoicePoint(a)
}

static void TEST10_A_ChoicePoint_a__transition_kid_index7(Spec2Sm* self)
{
    // TEST10_A.ChoicePoint(a) behavior
    // uml: / { trace("Transition action `` for TEST10_A.ChoicePoint(a) to TEST10_A_1."); } TransitionTo(TEST10_A_1)
    {
        // Step 1: Exit states until we reach `TEST10_A` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST10_A.ChoicePoint(a) to TEST10_A_1.");`.
        trace("Transition action `` for TEST10_A.ChoicePoint(a) to TEST10_A_1.");
        
        // Step 3: Enter/move towards transition target `TEST10_A_1`.
        TEST10_A_1_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST10_A_1;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for TEST10_A.ChoicePoint(a)
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST10_A_1
////////////////////////////////////////////////////////////////////////////////

static void TEST10_A_1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST10_A_1_exit;
    
    // TEST10_A_1 behavior
    // uml: enter / { trace("Enter TEST10_A_1."); }
    {
        // Step 1: execute action `trace("Enter TEST10_A_1.");`
        trace("Enter TEST10_A_1.");
    } // end of behavior for TEST10_A_1
}

static void TEST10_A_1_exit(Spec2Sm* self)
{
    // TEST10_A_1 behavior
    // uml: exit / { trace("Exit TEST10_A_1."); }
    {
        // Step 1: execute action `trace("Exit TEST10_A_1.");`
        trace("Exit TEST10_A_1.");
    } // end of behavior for TEST10_A_1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST10_A_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST10_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST10_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST10_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV5] = TEST10_ROOT_ev5;
    
    // TEST10_ROOT behavior
    // uml: enter / { trace("Enter TEST10_ROOT."); }
    {
        // Step 1: execute action `trace("Enter TEST10_ROOT.");`
        trace("Enter TEST10_ROOT.");
    } // end of behavior for TEST10_ROOT
}

static void TEST10_ROOT_exit(Spec2Sm* self)
{
    // TEST10_ROOT behavior
    // uml: exit / { trace("Exit TEST10_ROOT."); }
    {
        // Step 1: execute action `trace("Exit TEST10_ROOT.");`
        trace("Exit TEST10_ROOT.");
    } // end of behavior for TEST10_ROOT
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST10_CHOICE_POINT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV5] = NULL;  // no ancestor listens to this event
}

static void TEST10_ROOT_ev5(Spec2Sm* self)
{
    // No ancestor state handles `EV5` event.
    
    // TEST10_ROOT behavior
    // uml: EV5 [trace_guard("State TEST10_ROOT: check behavior `EV5 / { count++; }`.", true)] / { count++; }
    if (trace_guard("State TEST10_ROOT: check behavior `EV5 / { count++; }`.", true))
    {
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        
        // Step 1: execute action `count++;`
        self->vars.count++;
        
        // Step 2: determine if ancestor gets to handle event next.
        // No ancestor handles event. Ignore `consume_event` flag.
    } // end of behavior for TEST10_ROOT
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST10_G
////////////////////////////////////////////////////////////////////////////////

static void TEST10_G_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST10_G_exit;
    
    // TEST10_G behavior
    // uml: enter / { trace("Enter TEST10_G."); }
    {
        // Step 1: execute action `trace("Enter TEST10_G.");`
        trace("Enter TEST10_G.");
    } // end of behavior for TEST10_G
}

static void TEST10_G_exit(Spec2Sm* self)
{
    // TEST10_G behavior
    // uml: exit / { trace("Exit TEST10_G."); }
    {
        // Step 1: execute action `trace("Exit TEST10_G.");`
        trace("Exit TEST10_G.");
    } // end of behavior for TEST10_G
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST10_ROOT_exit;
}

static void TEST10_G_ChoicePoint__transition(Spec2Sm* self)
{
    // TEST10_G.ChoicePoint() behavior
    // uml: / { trace("Transition action `` for TEST10_G.ChoicePoint() to TEST10_G.ChoicePoint(1)."); } TransitionTo(TEST10_G.ChoicePoint(1))
    {
        // Step 1: Exit states until we reach `TEST10_G` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST10_G.ChoicePoint() to TEST10_G.ChoicePoint(1).");`.
        trace("Transition action `` for TEST10_G.ChoicePoint() to TEST10_G.ChoicePoint(1).");
        
        // Step 3: Enter/move towards transition target `TEST10_G.ChoicePoint(1)`.
        // TEST10_G.ChoicePoint(1) is a pseudo state and cannot have an `enter` trigger.
        
        // TEST10_G.ChoicePoint(1) behavior
        // uml: 1. [count <= 0] / { trace("Transition action `` for TEST10_G.ChoicePoint(1) to TEST10_G_S0."); } TransitionTo(TEST10_G_S0)
        if (self->vars.count <= 0)
        {
            // Step 1: Exit states until we reach `TEST10_G` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST10_G.ChoicePoint(1) to TEST10_G_S0.");`.
            trace("Transition action `` for TEST10_G.ChoicePoint(1) to TEST10_G_S0.");
            
            // Step 3: Enter/move towards transition target `TEST10_G_S0`.
            TEST10_G_S0_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_TEST10_G_S0;
            self->ancestor_event_handler = NULL;
            return;
        } // end of behavior for TEST10_G.ChoicePoint(1)
        
        // TEST10_G.ChoicePoint(1) behavior
        // uml: [count <= 2] / { trace("Transition action `` for TEST10_G.ChoicePoint(1) to TEST10_G.ChoicePoint(lower)."); } TransitionTo(TEST10_G.ChoicePoint(lower))
        if (self->vars.count <= 2)
        {
            // Step 1: Exit states until we reach `TEST10_G` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST10_G.ChoicePoint(1) to TEST10_G.ChoicePoint(lower).");`.
            trace("Transition action `` for TEST10_G.ChoicePoint(1) to TEST10_G.ChoicePoint(lower).");
            
            // Step 3: Enter/move towards transition target `TEST10_G.ChoicePoint(lower)`.
            // TEST10_G.ChoicePoint(lower) is a pseudo state and cannot have an `enter` trigger.
            
            // TEST10_G.ChoicePoint(lower) behavior
            // uml: [count <=1] / { trace("Transition action `` for TEST10_G.ChoicePoint(lower) to TEST10_G_S1."); } TransitionTo(TEST10_G_S1)
            if (self->vars.count <=1)
            {
                // Step 1: Exit states until we reach `TEST10_G` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `trace("Transition action `` for TEST10_G.ChoicePoint(lower) to TEST10_G_S1.");`.
                trace("Transition action `` for TEST10_G.ChoicePoint(lower) to TEST10_G_S1.");
                
                // Step 3: Enter/move towards transition target `TEST10_G_S1`.
                TEST10_G_S1_enter(self);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                self->state_id = Spec2Sm_StateId_TEST10_G_S1;
                self->ancestor_event_handler = NULL;
                return;
            } // end of behavior for TEST10_G.ChoicePoint(lower)
            
            // TEST10_G.ChoicePoint(lower) behavior
            // uml: else / { trace("Transition action `` for TEST10_G.ChoicePoint(lower) to TEST10_G_S2."); } TransitionTo(TEST10_G_S2)
            {
                // Step 1: Exit states until we reach `TEST10_G` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `trace("Transition action `` for TEST10_G.ChoicePoint(lower) to TEST10_G_S2.");`.
                trace("Transition action `` for TEST10_G.ChoicePoint(lower) to TEST10_G_S2.");
                
                // Step 3: Enter/move towards transition target `TEST10_G_S2`.
                TEST10_G_S2_enter(self);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                self->state_id = Spec2Sm_StateId_TEST10_G_S2;
                self->ancestor_event_handler = NULL;
                return;
            } // end of behavior for TEST10_G.ChoicePoint(lower)
        } // end of behavior for TEST10_G.ChoicePoint(1)
        
        // TEST10_G.ChoicePoint(1) behavior
        // uml: else / { trace("Transition action `` for TEST10_G.ChoicePoint(1) to TEST10_G.ChoicePoint(upper)."); } TransitionTo(TEST10_G.ChoicePoint(upper))
        {
            // Step 1: Exit states until we reach `TEST10_G` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST10_G.ChoicePoint(1) to TEST10_G.ChoicePoint(upper).");`.
            trace("Transition action `` for TEST10_G.ChoicePoint(1) to TEST10_G.ChoicePoint(upper).");
            
            // Step 3: Enter/move towards transition target `TEST10_G.ChoicePoint(upper)`.
            // TEST10_G.ChoicePoint(upper) is a pseudo state and cannot have an `enter` trigger.
            
            // TEST10_G.ChoicePoint(upper) behavior
            // uml: [count <= 3] / { trace("Transition action `` for TEST10_G.ChoicePoint(upper) to TEST10_G_S3."); } TransitionTo(TEST10_G_S3)
            if (self->vars.count <= 3)
            {
                // Step 1: Exit states until we reach `TEST10_G` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `trace("Transition action `` for TEST10_G.ChoicePoint(upper) to TEST10_G_S3.");`.
                trace("Transition action `` for TEST10_G.ChoicePoint(upper) to TEST10_G_S3.");
                
                // Step 3: Enter/move towards transition target `TEST10_G_S3`.
                TEST10_G_S3_enter(self);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                self->state_id = Spec2Sm_StateId_TEST10_G_S3;
                self->ancestor_event_handler = NULL;
                return;
            } // end of behavior for TEST10_G.ChoicePoint(upper)
            
            // TEST10_G.ChoicePoint(upper) behavior
            // uml: else / { trace("Transition action `` for TEST10_G.ChoicePoint(upper) to TEST10_S4."); } TransitionTo(TEST10_S4)
            {
                // Step 1: Exit states until we reach `TEST10_ROOT` state (Least Common Ancestor for transition).
                exit_up_to_state_handler(self, TEST10_ROOT_exit);
                
                // Step 2: Transition action: `trace("Transition action `` for TEST10_G.ChoicePoint(upper) to TEST10_S4.");`.
                trace("Transition action `` for TEST10_G.ChoicePoint(upper) to TEST10_S4.");
                
                // Step 3: Enter/move towards transition target `TEST10_S4`.
                TEST10_S4_enter(self);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                self->state_id = Spec2Sm_StateId_TEST10_S4;
                self->ancestor_event_handler = NULL;
                return;
            } // end of behavior for TEST10_G.ChoicePoint(upper)
        } // end of behavior for TEST10_G.ChoicePoint(1)
    } // end of behavior for TEST10_G.ChoicePoint()
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST10_G_S0
////////////////////////////////////////////////////////////////////////////////

static void TEST10_G_S0_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST10_G_S0_exit;
    
    // TEST10_G_S0 behavior
    // uml: enter / { trace("Enter TEST10_G_S0."); }
    {
        // Step 1: execute action `trace("Enter TEST10_G_S0.");`
        trace("Enter TEST10_G_S0.");
    } // end of behavior for TEST10_G_S0
}

static void TEST10_G_S0_exit(Spec2Sm* self)
{
    // TEST10_G_S0 behavior
    // uml: exit / { trace("Exit TEST10_G_S0."); }
    {
        // Step 1: execute action `trace("Exit TEST10_G_S0.");`
        trace("Exit TEST10_G_S0.");
    } // end of behavior for TEST10_G_S0
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST10_G_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST10_G_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST10_G_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST10_G_S1_exit;
    
    // TEST10_G_S1 behavior
    // uml: enter / { trace("Enter TEST10_G_S1."); }
    {
        // Step 1: execute action `trace("Enter TEST10_G_S1.");`
        trace("Enter TEST10_G_S1.");
    } // end of behavior for TEST10_G_S1
}

static void TEST10_G_S1_exit(Spec2Sm* self)
{
    // TEST10_G_S1 behavior
    // uml: exit / { trace("Exit TEST10_G_S1."); }
    {
        // Step 1: execute action `trace("Exit TEST10_G_S1.");`
        trace("Exit TEST10_G_S1.");
    } // end of behavior for TEST10_G_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST10_G_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST10_G_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST10_G_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST10_G_S2_exit;
    
    // TEST10_G_S2 behavior
    // uml: enter / { trace("Enter TEST10_G_S2."); }
    {
        // Step 1: execute action `trace("Enter TEST10_G_S2.");`
        trace("Enter TEST10_G_S2.");
    } // end of behavior for TEST10_G_S2
}

static void TEST10_G_S2_exit(Spec2Sm* self)
{
    // TEST10_G_S2 behavior
    // uml: exit / { trace("Exit TEST10_G_S2."); }
    {
        // Step 1: execute action `trace("Exit TEST10_G_S2.");`
        trace("Exit TEST10_G_S2.");
    } // end of behavior for TEST10_G_S2
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST10_G_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST10_G_S3
////////////////////////////////////////////////////////////////////////////////

static void TEST10_G_S3_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST10_G_S3_exit;
    
    // TEST10_G_S3 behavior
    // uml: enter / { trace("Enter TEST10_G_S3."); }
    {
        // Step 1: execute action `trace("Enter TEST10_G_S3.");`
        trace("Enter TEST10_G_S3.");
    } // end of behavior for TEST10_G_S3
}

static void TEST10_G_S3_exit(Spec2Sm* self)
{
    // TEST10_G_S3 behavior
    // uml: exit / { trace("Exit TEST10_G_S3."); }
    {
        // Step 1: execute action `trace("Exit TEST10_G_S3.");`
        trace("Exit TEST10_G_S3.");
    } // end of behavior for TEST10_G_S3
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST10_G_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST10_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST10_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST10_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST10_S1_ev1;
    self->current_event_handlers[Spec2Sm_EventId_EV10] = TEST10_S1_ev10;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST10_S1_ev2;
    self->current_event_handlers[Spec2Sm_EventId_EV3] = TEST10_S1_ev3;
    
    // TEST10_S1 behavior
    // uml: enter / { trace("Enter TEST10_S1."); }
    {
        // Step 1: execute action `trace("Enter TEST10_S1.");`
        trace("Enter TEST10_S1.");
    } // end of behavior for TEST10_S1
    
    // TEST10_S1 behavior
    // uml: enter [trace_guard("State TEST10_S1: check behavior `enter / { clear_output(); }`.", true)] / { clear_output(); }
    if (trace_guard("State TEST10_S1: check behavior `enter / { clear_output(); }`.", true))
    {
        // Step 1: execute action `clear_output();`
        trace("IGNORE_OUTPUT_BEFORE_THIS");;
    } // end of behavior for TEST10_S1
}

static void TEST10_S1_exit(Spec2Sm* self)
{
    // TEST10_S1 behavior
    // uml: exit / { trace("Exit TEST10_S1."); }
    {
        // Step 1: execute action `trace("Exit TEST10_S1.");`
        trace("Exit TEST10_S1.");
    } // end of behavior for TEST10_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST10_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV10] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV3] = NULL;  // no ancestor listens to this event
}

static void TEST10_S1_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST10_S1 behavior
    // uml: EV1 [trace_guard("State TEST10_S1: check behavior `EV1 TransitionTo(TEST10_G.EntryPoint(1))`.", true)] / { trace("Transition action `` for TEST10_S1 to TEST10_G.EntryPoint(1)."); } TransitionTo(TEST10_G.EntryPoint(1))
    if (trace_guard("State TEST10_S1: check behavior `EV1 TransitionTo(TEST10_G.EntryPoint(1))`.", true))
    {
        // Step 1: Exit states until we reach `TEST10_ROOT` state (Least Common Ancestor for transition).
        TEST10_S1_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST10_S1 to TEST10_G.EntryPoint(1).");`.
        trace("Transition action `` for TEST10_S1 to TEST10_G.EntryPoint(1).");
        
        // Step 3: Enter/move towards transition target `TEST10_G.EntryPoint(1)`.
        TEST10_G_enter(self);
        // TEST10_G.EntryPoint(1) is a pseudo state and cannot have an `enter` trigger.
        
        // TEST10_G.EntryPoint(1) behavior
        // uml: / { trace("Transition action `` for TEST10_G.EntryPoint(1) to TEST10_G.ChoicePoint()."); } TransitionTo(TEST10_G.ChoicePoint())
        {
            // Step 1: Exit states until we reach `TEST10_G` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST10_G.EntryPoint(1) to TEST10_G.ChoicePoint().");`.
            trace("Transition action `` for TEST10_G.EntryPoint(1) to TEST10_G.ChoicePoint().");
            
            // Step 3: Enter/move towards transition target `TEST10_G.ChoicePoint()`.
            // TEST10_G.ChoicePoint() is a pseudo state and cannot have an `enter` trigger.
            
            // Finish transition by calling pseudo state transition function.
            TEST10_G_ChoicePoint__transition(self);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for TEST10_G.EntryPoint(1)
    } // end of behavior for TEST10_S1
}

static void TEST10_S1_ev10(Spec2Sm* self)
{
    // No ancestor state handles `EV10` event.
    
    // TEST10_S1 behavior
    // uml: EV10 [trace_guard("State TEST10_S1: check behavior `EV10 TransitionTo(TEST10_A)`.", true)] / { trace("Transition action `` for TEST10_S1 to TEST10_A."); } TransitionTo(TEST10_A)
    if (trace_guard("State TEST10_S1: check behavior `EV10 TransitionTo(TEST10_A)`.", true))
    {
        // Step 1: Exit states until we reach `TEST10_CHOICE_POINT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, TEST10_CHOICE_POINT_exit);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST10_S1 to TEST10_A.");`.
        trace("Transition action `` for TEST10_S1 to TEST10_A.");
        
        // Step 3: Enter/move towards transition target `TEST10_A`.
        TEST10_A_enter(self);
        
        // TEST10_A.InitialState behavior
        // uml: [count == 1] / { trace("Transition action `` for TEST10_A.InitialState to TEST10_A.ChoicePoint()."); } TransitionTo(TEST10_A.ChoicePoint())
        if (self->vars.count == 1)
        {
            // Step 1: Exit states until we reach `TEST10_A` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST10_A.InitialState to TEST10_A.ChoicePoint().");`.
            trace("Transition action `` for TEST10_A.InitialState to TEST10_A.ChoicePoint().");
            
            // Step 3: Enter/move towards transition target `TEST10_A.ChoicePoint()`.
            // TEST10_A.ChoicePoint() is a pseudo state and cannot have an `enter` trigger.
            
            // Finish transition by calling pseudo state transition function.
            TEST10_A_ChoicePoint__transition(self);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for TEST10_A.InitialState
        
        // TEST10_A.InitialState behavior
        // uml: [count == 0] / { trace("Transition action `count++;` for TEST10_A.InitialState to TEST10_A.ChoicePoint().");\ncount++; } TransitionTo(TEST10_A.ChoicePoint())
        if (self->vars.count == 0)
        {
            // Step 1: Exit states until we reach `TEST10_A` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `count++;` for TEST10_A.InitialState to TEST10_A.ChoicePoint().");\ncount++;`.
            trace("Transition action `count++;` for TEST10_A.InitialState to TEST10_A.ChoicePoint().");
            self->vars.count++;
            
            // Step 3: Enter/move towards transition target `TEST10_A.ChoicePoint()`.
            // TEST10_A.ChoicePoint() is a pseudo state and cannot have an `enter` trigger.
            
            // Finish transition by calling pseudo state transition function.
            TEST10_A_ChoicePoint__transition(self);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for TEST10_A.InitialState
        
        // TEST10_A.InitialState behavior
        // uml: else / { trace("Transition action `` for TEST10_A.InitialState to TEST10_A.ChoicePoint()."); } TransitionTo(TEST10_A.ChoicePoint())
        {
            // Step 1: Exit states until we reach `TEST10_A` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST10_A.InitialState to TEST10_A.ChoicePoint().");`.
            trace("Transition action `` for TEST10_A.InitialState to TEST10_A.ChoicePoint().");
            
            // Step 3: Enter/move towards transition target `TEST10_A.ChoicePoint()`.
            // TEST10_A.ChoicePoint() is a pseudo state and cannot have an `enter` trigger.
            
            // Finish transition by calling pseudo state transition function.
            TEST10_A_ChoicePoint__transition_kid_index3(self);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for TEST10_A.InitialState
    } // end of behavior for TEST10_S1
}

static void TEST10_S1_ev2(Spec2Sm* self)
{
    // No ancestor state handles `EV2` event.
    
    // TEST10_S1 behavior
    // uml: EV2 [trace_guard("State TEST10_S1: check behavior `EV2 TransitionTo(TEST10_G.ChoicePoint())`.", true)] / { trace("Transition action `` for TEST10_S1 to TEST10_G.ChoicePoint()."); } TransitionTo(TEST10_G.ChoicePoint())
    if (trace_guard("State TEST10_S1: check behavior `EV2 TransitionTo(TEST10_G.ChoicePoint())`.", true))
    {
        // Step 1: Exit states until we reach `TEST10_ROOT` state (Least Common Ancestor for transition).
        TEST10_S1_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST10_S1 to TEST10_G.ChoicePoint().");`.
        trace("Transition action `` for TEST10_S1 to TEST10_G.ChoicePoint().");
        
        // Step 3: Enter/move towards transition target `TEST10_G.ChoicePoint()`.
        TEST10_G_enter(self);
        // TEST10_G.ChoicePoint() is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        TEST10_G_ChoicePoint__transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST10_S1
}

static void TEST10_S1_ev3(Spec2Sm* self)
{
    // No ancestor state handles `EV3` event.
    
    // TEST10_S1 behavior
    // uml: EV3 [trace_guard("State TEST10_S1: check behavior `EV3 TransitionTo(TEST10_G)`.", true)] / { trace("Transition action `` for TEST10_S1 to TEST10_G."); } TransitionTo(TEST10_G)
    if (trace_guard("State TEST10_S1: check behavior `EV3 TransitionTo(TEST10_G)`.", true))
    {
        // Step 1: Exit states until we reach `TEST10_ROOT` state (Least Common Ancestor for transition).
        TEST10_S1_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST10_S1 to TEST10_G.");`.
        trace("Transition action `` for TEST10_S1 to TEST10_G.");
        
        // Step 3: Enter/move towards transition target `TEST10_G`.
        TEST10_G_enter(self);
        
        // TEST10_G.InitialState behavior
        // uml: / { trace("Transition action `` for TEST10_G.InitialState to TEST10_G.ChoicePoint()."); } TransitionTo(TEST10_G.ChoicePoint())
        {
            // Step 1: Exit states until we reach `TEST10_G` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST10_G.InitialState to TEST10_G.ChoicePoint().");`.
            trace("Transition action `` for TEST10_G.InitialState to TEST10_G.ChoicePoint().");
            
            // Step 3: Enter/move towards transition target `TEST10_G.ChoicePoint()`.
            // TEST10_G.ChoicePoint() is a pseudo state and cannot have an `enter` trigger.
            
            // Finish transition by calling pseudo state transition function.
            TEST10_G_ChoicePoint__transition(self);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for TEST10_G.InitialState
    } // end of behavior for TEST10_S1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST10_S4
////////////////////////////////////////////////////////////////////////////////

static void TEST10_S4_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST10_S4_exit;
    
    // TEST10_S4 behavior
    // uml: enter / { trace("Enter TEST10_S4."); }
    {
        // Step 1: execute action `trace("Enter TEST10_S4.");`
        trace("Enter TEST10_S4.");
    } // end of behavior for TEST10_S4
}

static void TEST10_S4_exit(Spec2Sm* self)
{
    // TEST10_S4 behavior
    // uml: exit / { trace("Exit TEST10_S4."); }
    {
        // Step 1: execute action `trace("Exit TEST10_S4.");`
        trace("Exit TEST10_S4.");
    } // end of behavior for TEST10_S4
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST10_ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_REGULAR_EVENT_TESTING
////////////////////////////////////////////////////////////////////////////////

static void TEST2_REGULAR_EVENT_TESTING_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_REGULAR_EVENT_TESTING_exit;
    
    // TEST2_REGULAR_EVENT_TESTING behavior
    // uml: enter / { trace("Enter TEST2_REGULAR_EVENT_TESTING."); }
    {
        // Step 1: execute action `trace("Enter TEST2_REGULAR_EVENT_TESTING.");`
        trace("Enter TEST2_REGULAR_EVENT_TESTING.");
    } // end of behavior for TEST2_REGULAR_EVENT_TESTING
}

static void TEST2_REGULAR_EVENT_TESTING_exit(Spec2Sm* self)
{
    // TEST2_REGULAR_EVENT_TESTING behavior
    // uml: exit / { trace("Exit TEST2_REGULAR_EVENT_TESTING."); }
    {
        // Step 1: execute action `trace("Exit TEST2_REGULAR_EVENT_TESTING.");`
        trace("Exit TEST2_REGULAR_EVENT_TESTING.");
    } // end of behavior for TEST2_REGULAR_EVENT_TESTING
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST2_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST2_ROOT_do;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_ROOT_ev1;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST2_ROOT_ev2;
    
    // TEST2_ROOT behavior
    // uml: enter / { trace("Enter TEST2_ROOT."); }
    {
        // Step 1: execute action `trace("Enter TEST2_ROOT.");`
        trace("Enter TEST2_ROOT.");
    } // end of behavior for TEST2_ROOT
}

static void TEST2_ROOT_exit(Spec2Sm* self)
{
    // TEST2_ROOT behavior
    // uml: exit / { trace("Exit TEST2_ROOT."); }
    {
        // Step 1: execute action `trace("Exit TEST2_ROOT.");`
        trace("Exit TEST2_ROOT.");
    } // end of behavior for TEST2_ROOT
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST2_REGULAR_EVENT_TESTING_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
}

static void TEST2_ROOT_do(Spec2Sm* self)
{
    // No ancestor state handles `do` event.
    
    // TEST2_ROOT behavior
    // uml: do [trace_guard("State TEST2_ROOT: check behavior `do`.", true)]
    if (trace_guard("State TEST2_ROOT: check behavior `do`.", true))
    {
        // Step 1: execute action ``
        // Step 2: determine if ancestor gets to handle event next.
        // Don't consume special `do` event.
    } // end of behavior for TEST2_ROOT
}

static void TEST2_ROOT_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST2_ROOT behavior
    // uml: EV1 [trace_guard("State TEST2_ROOT: check behavior `EV1`.", true)]
    if (trace_guard("State TEST2_ROOT: check behavior `EV1`.", true))
    {
        // Step 1: execute action ``
        // Step 2: determine if ancestor gets to handle event next.
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
    } // end of behavior for TEST2_ROOT
}

static void TEST2_ROOT_ev2(Spec2Sm* self)
{
    // No ancestor state handles `EV2` event.
    
    // TEST2_ROOT behavior
    // uml: EV2 [trace_guard("State TEST2_ROOT: check behavior `EV2`.", true)]
    if (trace_guard("State TEST2_ROOT: check behavior `EV2`.", true))
    {
        // Step 1: execute action ``
        // Step 2: determine if ancestor gets to handle event next.
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
    } // end of behavior for TEST2_ROOT
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST2_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_S1_exit;
    
    // TEST2_S1 behavior
    // uml: enter / { trace("Enter TEST2_S1."); }
    {
        // Step 1: execute action `trace("Enter TEST2_S1.");`
        trace("Enter TEST2_S1.");
    } // end of behavior for TEST2_S1
}

static void TEST2_S1_exit(Spec2Sm* self)
{
    // TEST2_S1 behavior
    // uml: exit / { trace("Exit TEST2_S1."); }
    {
        // Step 1: execute action `trace("Exit TEST2_S1.");`
        trace("Exit TEST2_S1.");
    } // end of behavior for TEST2_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST2_ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_S1_1
////////////////////////////////////////////////////////////////////////////////

static void TEST2_S1_1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_S1_1_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST2_S1_1_do;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_S1_1_ev1;
    
    // TEST2_S1_1 behavior
    // uml: enter / { trace("Enter TEST2_S1_1."); }
    {
        // Step 1: execute action `trace("Enter TEST2_S1_1.");`
        trace("Enter TEST2_S1_1.");
    } // end of behavior for TEST2_S1_1
    
    // TEST2_S1_1 behavior
    // uml: enter [trace_guard("State TEST2_S1_1: check behavior `enter / { clear_output(); }`.", true)] / { clear_output(); }
    if (trace_guard("State TEST2_S1_1: check behavior `enter / { clear_output(); }`.", true))
    {
        // Step 1: execute action `clear_output();`
        trace("IGNORE_OUTPUT_BEFORE_THIS");;
    } // end of behavior for TEST2_S1_1
}

static void TEST2_S1_1_exit(Spec2Sm* self)
{
    // TEST2_S1_1 behavior
    // uml: exit / { trace("Exit TEST2_S1_1."); }
    {
        // Step 1: execute action `trace("Exit TEST2_S1_1.");`
        trace("Exit TEST2_S1_1.");
    } // end of behavior for TEST2_S1_1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST2_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST2_ROOT_do;  // the next ancestor that handles this event is TEST2_ROOT
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_ROOT_ev1;  // the next ancestor that handles this event is TEST2_ROOT
}

static void TEST2_S1_1_do(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `do` event.
    self->ancestor_event_handler = TEST2_ROOT_do;
    
    // TEST2_S1_1 behavior
    // uml: do [trace_guard("State TEST2_S1_1: check behavior `do TransitionTo(TEST2_S2)`.", true)] / { trace("Transition action `` for TEST2_S1_1 to TEST2_S2."); } TransitionTo(TEST2_S2)
    if (trace_guard("State TEST2_S1_1: check behavior `do TransitionTo(TEST2_S2)`.", true))
    {
        // Step 1: Exit states until we reach `TEST2_ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, TEST2_ROOT_exit);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST2_S1_1 to TEST2_S2.");`.
        trace("Transition action `` for TEST2_S1_1 to TEST2_S2.");
        
        // Step 3: Enter/move towards transition target `TEST2_S2`.
        TEST2_S2_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST2_S2;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for TEST2_S1_1
}

static void TEST2_S1_1_ev1(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `EV1` event.
    self->ancestor_event_handler = TEST2_ROOT_ev1;
    
    // TEST2_S1_1 behavior
    // uml: EV1 [trace_guard("State TEST2_S1_1: check behavior `EV1`.", true)]
    if (trace_guard("State TEST2_S1_1: check behavior `EV1`.", true))
    {
        // Step 1: execute action ``
        // Step 2: determine if ancestor gets to handle event next.
        self->ancestor_event_handler = NULL;  // consume event
    } // end of behavior for TEST2_S1_1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST2_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_S2_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_S2_ev1;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST2_S2_ev2;
    
    // TEST2_S2 behavior
    // uml: enter / { trace("Enter TEST2_S2."); }
    {
        // Step 1: execute action `trace("Enter TEST2_S2.");`
        trace("Enter TEST2_S2.");
    } // end of behavior for TEST2_S2
}

static void TEST2_S2_exit(Spec2Sm* self)
{
    // TEST2_S2 behavior
    // uml: exit / { trace("Exit TEST2_S2."); }
    {
        // Step 1: execute action `trace("Exit TEST2_S2.");`
        trace("Exit TEST2_S2.");
    } // end of behavior for TEST2_S2
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST2_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_ROOT_ev1;  // the next ancestor that handles this event is TEST2_ROOT
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST2_ROOT_ev2;  // the next ancestor that handles this event is TEST2_ROOT
}

static void TEST2_S2_ev1(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `EV1` event.
    self->ancestor_event_handler = TEST2_ROOT_ev1;
    
    // TEST2_S2 behavior
    // uml: EV1 [trace_guard("State TEST2_S2: check behavior `EV1 / { consume_event = false; }`.", true)] / { consume_event = false; }
    if (trace_guard("State TEST2_S2: check behavior `EV1 / { consume_event = false; }`.", true))
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        
        // Step 1: execute action `consume_event = false;`
        consume_event = false;
        
        // Step 2: determine if ancestor gets to handle event next.
        if (consume_event)
        {
            self->ancestor_event_handler = NULL;  // consume event
        }
    } // end of behavior for TEST2_S2
}

static void TEST2_S2_ev2(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `EV2` event.
    self->ancestor_event_handler = TEST2_ROOT_ev2;
    
    // TEST2_S2 behavior
    // uml: EV2 [trace_guard("State TEST2_S2: check behavior `EV2 TransitionTo(TEST2_S2)`.", true)] / { trace("Transition action `` for TEST2_S2 to TEST2_S2."); } TransitionTo(TEST2_S2)
    if (trace_guard("State TEST2_S2: check behavior `EV2 TransitionTo(TEST2_S2)`.", true))
    {
        // Step 1: Exit states until we reach `TEST2_ROOT` state (Least Common Ancestor for transition).
        TEST2_S2_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST2_S2 to TEST2_S2.");`.
        trace("Transition action `` for TEST2_S2 to TEST2_S2.");
        
        // Step 3: Enter/move towards transition target `TEST2_S2`.
        TEST2_S2_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST2_S2;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for TEST2_S2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_BEHAVIOR_ORDERING
////////////////////////////////////////////////////////////////////////////////

static void TEST3_BEHAVIOR_ORDERING_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_BEHAVIOR_ORDERING_exit;
    
    // TEST3_BEHAVIOR_ORDERING behavior
    // uml: enter / { trace("Enter TEST3_BEHAVIOR_ORDERING."); }
    {
        // Step 1: execute action `trace("Enter TEST3_BEHAVIOR_ORDERING.");`
        trace("Enter TEST3_BEHAVIOR_ORDERING.");
    } // end of behavior for TEST3_BEHAVIOR_ORDERING
}

static void TEST3_BEHAVIOR_ORDERING_exit(Spec2Sm* self)
{
    // TEST3_BEHAVIOR_ORDERING behavior
    // uml: exit / { trace("Exit TEST3_BEHAVIOR_ORDERING."); }
    {
        // Step 1: execute action `trace("Exit TEST3_BEHAVIOR_ORDERING.");`
        trace("Exit TEST3_BEHAVIOR_ORDERING.");
    } // end of behavior for TEST3_BEHAVIOR_ORDERING
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST3_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_ROOT_ev1;
    
    // TEST3_ROOT behavior
    // uml: enter / { trace("Enter TEST3_ROOT."); }
    {
        // Step 1: execute action `trace("Enter TEST3_ROOT.");`
        trace("Enter TEST3_ROOT.");
    } // end of behavior for TEST3_ROOT
}

static void TEST3_ROOT_exit(Spec2Sm* self)
{
    // TEST3_ROOT behavior
    // uml: exit / { trace("Exit TEST3_ROOT."); }
    {
        // Step 1: execute action `trace("Exit TEST3_ROOT.");`
        trace("Exit TEST3_ROOT.");
    } // end of behavior for TEST3_ROOT
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST3_BEHAVIOR_ORDERING_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST3_ROOT_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST3_ROOT behavior
    // uml: EV1 [trace_guard("State TEST3_ROOT: check behavior `EV1`.", true)]
    if (trace_guard("State TEST3_ROOT: check behavior `EV1`.", true))
    {
        // Step 1: execute action ``
        // Step 2: determine if ancestor gets to handle event next.
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
    } // end of behavior for TEST3_ROOT
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST3_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_S1_ev1;
    
    // TEST3_S1 behavior
    // uml: enter / { trace("Enter TEST3_S1."); }
    {
        // Step 1: execute action `trace("Enter TEST3_S1.");`
        trace("Enter TEST3_S1.");
    } // end of behavior for TEST3_S1
    
    // TEST3_S1 behavior
    // uml: enter [trace_guard("State TEST3_S1: check behavior `enter / { clear_output(); }`.", true)] / { clear_output(); }
    if (trace_guard("State TEST3_S1: check behavior `enter / { clear_output(); }`.", true))
    {
        // Step 1: execute action `clear_output();`
        trace("IGNORE_OUTPUT_BEFORE_THIS");;
    } // end of behavior for TEST3_S1
}

static void TEST3_S1_exit(Spec2Sm* self)
{
    // TEST3_S1 behavior
    // uml: exit / { trace("Exit TEST3_S1."); }
    {
        // Step 1: execute action `trace("Exit TEST3_S1.");`
        trace("Exit TEST3_S1.");
    } // end of behavior for TEST3_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST3_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_ROOT_ev1;  // the next ancestor that handles this event is TEST3_ROOT
}

static void TEST3_S1_ev1(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `EV1` event.
    self->ancestor_event_handler = TEST3_ROOT_ev1;
    
    // TEST3_S1 behavior
    // uml: 1. EV1 [trace_guard("State TEST3_S1: check behavior `1. EV1 TransitionTo(TEST3_S2)`.", true)] / { trace("Transition action `` for TEST3_S1 to TEST3_S2."); } TransitionTo(TEST3_S2)
    if (trace_guard("State TEST3_S1: check behavior `1. EV1 TransitionTo(TEST3_S2)`.", true))
    {
        // Step 1: Exit states until we reach `TEST3_ROOT` state (Least Common Ancestor for transition).
        TEST3_S1_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST3_S1 to TEST3_S2.");`.
        trace("Transition action `` for TEST3_S1 to TEST3_S2.");
        
        // Step 3: Enter/move towards transition target `TEST3_S2`.
        TEST3_S2_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST3_S2;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for TEST3_S1
    
    // TEST3_S1 behavior
    // uml: 2. EV1 [trace_guard("State TEST3_S1: check behavior `2. EV1 / { trace(\"failed\"); }`.", true)] / { trace("failed"); }
    if (trace_guard("State TEST3_S1: check behavior `2. EV1 / { trace(\"failed\"); }`.", true))
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        
        // Step 1: execute action `trace("failed");`
        trace("failed");
        
        // Step 2: determine if ancestor gets to handle event next.
        if (consume_event)
        {
            self->ancestor_event_handler = NULL;  // consume event
        }
    } // end of behavior for TEST3_S1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST3_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_S2_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_S2_ev1;
    
    // TEST3_S2 behavior
    // uml: enter / { trace("Enter TEST3_S2."); }
    {
        // Step 1: execute action `trace("Enter TEST3_S2.");`
        trace("Enter TEST3_S2.");
    } // end of behavior for TEST3_S2
}

static void TEST3_S2_exit(Spec2Sm* self)
{
    // TEST3_S2 behavior
    // uml: exit / { trace("Exit TEST3_S2."); }
    {
        // Step 1: execute action `trace("Exit TEST3_S2.");`
        trace("Exit TEST3_S2.");
    } // end of behavior for TEST3_S2
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST3_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_ROOT_ev1;  // the next ancestor that handles this event is TEST3_ROOT
}

static void TEST3_S2_ev1(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `EV1` event.
    self->ancestor_event_handler = TEST3_ROOT_ev1;
    
    // TEST3_S2 behavior
    // uml: 1. EV1 [trace_guard("State TEST3_S2: check behavior `1. EV1 / { trace(\"1 woot!\"); }`.", true)] / { trace("1 woot!"); }
    if (trace_guard("State TEST3_S2: check behavior `1. EV1 / { trace(\"1 woot!\"); }`.", true))
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        
        // Step 1: execute action `trace("1 woot!");`
        trace("1 woot!");
        
        // Step 2: determine if ancestor gets to handle event next.
        if (consume_event)
        {
            self->ancestor_event_handler = NULL;  // consume event
        }
    } // end of behavior for TEST3_S2
    
    // TEST3_S2 behavior
    // uml: 1.1. EV1 [trace_guard("State TEST3_S2: check behavior `1.1. EV1 / { trace(\"2 woot!\"); }`.", true)] / { trace("2 woot!"); }
    if (trace_guard("State TEST3_S2: check behavior `1.1. EV1 / { trace(\"2 woot!\"); }`.", true))
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        
        // Step 1: execute action `trace("2 woot!");`
        trace("2 woot!");
        
        // Step 2: determine if ancestor gets to handle event next.
        if (consume_event)
        {
            self->ancestor_event_handler = NULL;  // consume event
        }
    } // end of behavior for TEST3_S2
    
    // TEST3_S2 behavior
    // uml: 2. EV1 [trace_guard("State TEST3_S2: check behavior `2. EV1 / { trace(\"3 woot!\"); } TransitionTo(TEST3_S3)`.", true)] / { trace("Transition action `trace(\"3 woot!\");` for TEST3_S2 to TEST3_S3.");\ntrace("3 woot!"); } TransitionTo(TEST3_S3)
    if (trace_guard("State TEST3_S2: check behavior `2. EV1 / { trace(\"3 woot!\"); } TransitionTo(TEST3_S3)`.", true))
    {
        // Step 1: Exit states until we reach `TEST3_ROOT` state (Least Common Ancestor for transition).
        TEST3_S2_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `trace(\"3 woot!\");` for TEST3_S2 to TEST3_S3.");\ntrace("3 woot!");`.
        trace("Transition action `trace(\"3 woot!\");` for TEST3_S2 to TEST3_S3.");
        trace("3 woot!");
        
        // Step 3: Enter/move towards transition target `TEST3_S3`.
        TEST3_S3_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST3_S3;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for TEST3_S2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_S3
////////////////////////////////////////////////////////////////////////////////

static void TEST3_S3_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_S3_exit;
    
    // TEST3_S3 behavior
    // uml: enter / { trace("Enter TEST3_S3."); }
    {
        // Step 1: execute action `trace("Enter TEST3_S3.");`
        trace("Enter TEST3_S3.");
    } // end of behavior for TEST3_S3
}

static void TEST3_S3_exit(Spec2Sm* self)
{
    // TEST3_S3 behavior
    // uml: exit / { trace("Exit TEST3_S3."); }
    {
        // Step 1: execute action `trace("Exit TEST3_S3.");`
        trace("Exit TEST3_S3.");
    } // end of behavior for TEST3_S3
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST3_ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_PARENT_CHILD_TRANSITIONS
////////////////////////////////////////////////////////////////////////////////

static void TEST4_PARENT_CHILD_TRANSITIONS_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_PARENT_CHILD_TRANSITIONS_exit;
    
    // TEST4_PARENT_CHILD_TRANSITIONS behavior
    // uml: enter / { trace("Enter TEST4_PARENT_CHILD_TRANSITIONS."); }
    {
        // Step 1: execute action `trace("Enter TEST4_PARENT_CHILD_TRANSITIONS.");`
        trace("Enter TEST4_PARENT_CHILD_TRANSITIONS.");
    } // end of behavior for TEST4_PARENT_CHILD_TRANSITIONS
}

static void TEST4_PARENT_CHILD_TRANSITIONS_exit(Spec2Sm* self)
{
    // TEST4_PARENT_CHILD_TRANSITIONS behavior
    // uml: exit / { trace("Exit TEST4_PARENT_CHILD_TRANSITIONS."); }
    {
        // Step 1: execute action `trace("Exit TEST4_PARENT_CHILD_TRANSITIONS.");`
        trace("Exit TEST4_PARENT_CHILD_TRANSITIONS.");
    } // end of behavior for TEST4_PARENT_CHILD_TRANSITIONS
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_B_AND_OTHERS
////////////////////////////////////////////////////////////////////////////////

static void TEST4_B_AND_OTHERS_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_B_AND_OTHERS_exit;
    
    // TEST4_B_AND_OTHERS behavior
    // uml: enter / { trace("Enter TEST4_B_AND_OTHERS."); }
    {
        // Step 1: execute action `trace("Enter TEST4_B_AND_OTHERS.");`
        trace("Enter TEST4_B_AND_OTHERS.");
    } // end of behavior for TEST4_B_AND_OTHERS
    
    // TEST4_B_AND_OTHERS behavior
    // uml: enter [trace_guard("State TEST4_B_AND_OTHERS: check behavior `enter / { clear_dispatch_output(); }`.", true)] / { clear_dispatch_output(); }
    if (trace_guard("State TEST4_B_AND_OTHERS: check behavior `enter / { clear_dispatch_output(); }`.", true))
    {
        // Step 1: execute action `clear_dispatch_output();`
        trace("CLEAR_OUTPUT_BEFORE_THIS_AND_FOR_THIS_EVENT_DISPATCH");;
    } // end of behavior for TEST4_B_AND_OTHERS
}

static void TEST4_B_AND_OTHERS_exit(Spec2Sm* self)
{
    // TEST4_B_AND_OTHERS behavior
    // uml: exit / { trace("Exit TEST4_B_AND_OTHERS."); }
    {
        // Step 1: execute action `trace("Exit TEST4_B_AND_OTHERS.");`
        trace("Exit TEST4_B_AND_OTHERS.");
    } // end of behavior for TEST4_B_AND_OTHERS
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_PARENT_CHILD_TRANSITIONS_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4B_LOCAL
////////////////////////////////////////////////////////////////////////////////

static void TEST4B_LOCAL_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4B_LOCAL_exit;
    
    // TEST4B_LOCAL behavior
    // uml: enter / { trace("Enter TEST4B_LOCAL."); }
    {
        // Step 1: execute action `trace("Enter TEST4B_LOCAL.");`
        trace("Enter TEST4B_LOCAL.");
    } // end of behavior for TEST4B_LOCAL
}

static void TEST4B_LOCAL_exit(Spec2Sm* self)
{
    // TEST4B_LOCAL behavior
    // uml: exit / { trace("Exit TEST4B_LOCAL."); }
    {
        // Step 1: execute action `trace("Exit TEST4B_LOCAL.");`
        trace("Exit TEST4B_LOCAL.");
    } // end of behavior for TEST4B_LOCAL
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_B_AND_OTHERS_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4B_G
////////////////////////////////////////////////////////////////////////////////

static void TEST4B_G_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4B_G_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST4B_G_ev1;
    
    // TEST4B_G behavior
    // uml: enter / { trace("Enter TEST4B_G."); }
    {
        // Step 1: execute action `trace("Enter TEST4B_G.");`
        trace("Enter TEST4B_G.");
    } // end of behavior for TEST4B_G
}

static void TEST4B_G_exit(Spec2Sm* self)
{
    // TEST4B_G behavior
    // uml: exit / { trace("Exit TEST4B_G."); }
    {
        // Step 1: execute action `trace("Exit TEST4B_G.");`
        trace("Exit TEST4B_G.");
    } // end of behavior for TEST4B_G
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4B_LOCAL_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST4B_G_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST4B_G behavior
    // uml: EV1 [trace_guard("State TEST4B_G: check behavior `EV1 TransitionTo(TEST4B_G_1)`.", true)] / { trace("Transition action `` for TEST4B_G to TEST4B_G_1."); } TransitionTo(TEST4B_G_1)
    if (trace_guard("State TEST4B_G: check behavior `EV1 TransitionTo(TEST4B_G_1)`.", true))
    {
        // Step 1: Exit states until we reach `TEST4B_G` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, TEST4B_G_exit);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST4B_G to TEST4B_G_1.");`.
        trace("Transition action `` for TEST4B_G to TEST4B_G_1.");
        
        // Step 3: Enter/move towards transition target `TEST4B_G_1`.
        TEST4B_G_1_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST4B_G_1;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST4B_G
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4B_G_1
////////////////////////////////////////////////////////////////////////////////

static void TEST4B_G_1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4B_G_1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST4B_G_1_ev2;
    
    // TEST4B_G_1 behavior
    // uml: enter / { trace("Enter TEST4B_G_1."); }
    {
        // Step 1: execute action `trace("Enter TEST4B_G_1.");`
        trace("Enter TEST4B_G_1.");
    } // end of behavior for TEST4B_G_1
}

static void TEST4B_G_1_exit(Spec2Sm* self)
{
    // TEST4B_G_1 behavior
    // uml: exit / { trace("Exit TEST4B_G_1."); }
    {
        // Step 1: execute action `trace("Exit TEST4B_G_1.");`
        trace("Exit TEST4B_G_1.");
    } // end of behavior for TEST4B_G_1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4B_G_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
}

static void TEST4B_G_1_ev2(Spec2Sm* self)
{
    // No ancestor state handles `EV2` event.
    
    // TEST4B_G_1 behavior
    // uml: EV2 [trace_guard("State TEST4B_G_1: check behavior `EV2 TransitionTo(TEST4B_G)`.", true)] / { trace("Transition action `` for TEST4B_G_1 to TEST4B_G."); } TransitionTo(TEST4B_G)
    if (trace_guard("State TEST4B_G_1: check behavior `EV2 TransitionTo(TEST4B_G)`.", true))
    {
        // Step 1: Exit states until we reach `TEST4B_G` state (Least Common Ancestor for transition).
        TEST4B_G_1_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST4B_G_1 to TEST4B_G.");`.
        trace("Transition action `` for TEST4B_G_1 to TEST4B_G.");
        
        // Step 3: Enter/move towards transition target `TEST4B_G`.
        // Already in target. No entering required.
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST4B_G;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST4B_G_1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4C_LOCAL_TO_ALIAS
////////////////////////////////////////////////////////////////////////////////

static void TEST4C_LOCAL_TO_ALIAS_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4C_LOCAL_TO_ALIAS_exit;
    
    // TEST4C_LOCAL_TO_ALIAS behavior
    // uml: enter / { trace("Enter TEST4C_LOCAL_TO_ALIAS."); }
    {
        // Step 1: execute action `trace("Enter TEST4C_LOCAL_TO_ALIAS.");`
        trace("Enter TEST4C_LOCAL_TO_ALIAS.");
    } // end of behavior for TEST4C_LOCAL_TO_ALIAS
}

static void TEST4C_LOCAL_TO_ALIAS_exit(Spec2Sm* self)
{
    // TEST4C_LOCAL_TO_ALIAS behavior
    // uml: exit / { trace("Exit TEST4C_LOCAL_TO_ALIAS."); }
    {
        // Step 1: execute action `trace("Exit TEST4C_LOCAL_TO_ALIAS.");`
        trace("Exit TEST4C_LOCAL_TO_ALIAS.");
    } // end of behavior for TEST4C_LOCAL_TO_ALIAS
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_B_AND_OTHERS_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4C_G
////////////////////////////////////////////////////////////////////////////////

static void TEST4C_G_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4C_G_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST4C_G_ev1;
    
    // TEST4C_G behavior
    // uml: enter / { trace("Enter TEST4C_G."); }
    {
        // Step 1: execute action `trace("Enter TEST4C_G.");`
        trace("Enter TEST4C_G.");
    } // end of behavior for TEST4C_G
}

static void TEST4C_G_exit(Spec2Sm* self)
{
    // TEST4C_G behavior
    // uml: exit / { trace("Exit TEST4C_G."); }
    {
        // Step 1: execute action `trace("Exit TEST4C_G.");`
        trace("Exit TEST4C_G.");
    } // end of behavior for TEST4C_G
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4C_LOCAL_TO_ALIAS_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST4C_G_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST4C_G behavior
    // uml: EV1 [trace_guard("State TEST4C_G: check behavior `EV1 TransitionTo(TEST4C_G_1)`.", true)] / { trace("Transition action `` for TEST4C_G to TEST4C_G_1."); } TransitionTo(TEST4C_G_1)
    if (trace_guard("State TEST4C_G: check behavior `EV1 TransitionTo(TEST4C_G_1)`.", true))
    {
        // Step 1: Exit states until we reach `TEST4C_G` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, TEST4C_G_exit);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST4C_G to TEST4C_G_1.");`.
        trace("Transition action `` for TEST4C_G to TEST4C_G_1.");
        
        // Step 3: Enter/move towards transition target `TEST4C_G_1`.
        TEST4C_G_1_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST4C_G_1;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST4C_G
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4C_G_1
////////////////////////////////////////////////////////////////////////////////

static void TEST4C_G_1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4C_G_1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST4C_G_1_ev2;
    
    // TEST4C_G_1 behavior
    // uml: enter / { trace("Enter TEST4C_G_1."); }
    {
        // Step 1: execute action `trace("Enter TEST4C_G_1.");`
        trace("Enter TEST4C_G_1.");
    } // end of behavior for TEST4C_G_1
}

static void TEST4C_G_1_exit(Spec2Sm* self)
{
    // TEST4C_G_1 behavior
    // uml: exit / { trace("Exit TEST4C_G_1."); }
    {
        // Step 1: execute action `trace("Exit TEST4C_G_1.");`
        trace("Exit TEST4C_G_1.");
    } // end of behavior for TEST4C_G_1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4C_G_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
}

static void TEST4C_G_1_ev2(Spec2Sm* self)
{
    // No ancestor state handles `EV2` event.
    
    // TEST4C_G_1 behavior
    // uml: EV2 [trace_guard("State TEST4C_G_1: check behavior `EV2 TransitionTo(TEST4C_G)`.", true)] / { trace("Transition action `` for TEST4C_G_1 to TEST4C_G."); } TransitionTo(TEST4C_G)
    if (trace_guard("State TEST4C_G_1: check behavior `EV2 TransitionTo(TEST4C_G)`.", true))
    {
        // Step 1: Exit states until we reach `TEST4C_G` state (Least Common Ancestor for transition).
        TEST4C_G_1_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST4C_G_1 to TEST4C_G.");`.
        trace("Transition action `` for TEST4C_G_1 to TEST4C_G.");
        
        // Step 3: Enter/move towards transition target `TEST4C_G`.
        // Already in target. No entering required.
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST4C_G;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST4C_G_1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4D_EXTERNAL
////////////////////////////////////////////////////////////////////////////////

static void TEST4D_EXTERNAL_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4D_EXTERNAL_exit;
    
    // TEST4D_EXTERNAL behavior
    // uml: enter / { trace("Enter TEST4D_EXTERNAL."); }
    {
        // Step 1: execute action `trace("Enter TEST4D_EXTERNAL.");`
        trace("Enter TEST4D_EXTERNAL.");
    } // end of behavior for TEST4D_EXTERNAL
}

static void TEST4D_EXTERNAL_exit(Spec2Sm* self)
{
    // TEST4D_EXTERNAL behavior
    // uml: exit / { trace("Exit TEST4D_EXTERNAL."); }
    {
        // Step 1: execute action `trace("Exit TEST4D_EXTERNAL.");`
        trace("Exit TEST4D_EXTERNAL.");
    } // end of behavior for TEST4D_EXTERNAL
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_B_AND_OTHERS_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4D_G
////////////////////////////////////////////////////////////////////////////////

static void TEST4D_G_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4D_G_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST4D_G_ev1;
    
    // TEST4D_G behavior
    // uml: enter / { trace("Enter TEST4D_G."); }
    {
        // Step 1: execute action `trace("Enter TEST4D_G.");`
        trace("Enter TEST4D_G.");
    } // end of behavior for TEST4D_G
}

static void TEST4D_G_exit(Spec2Sm* self)
{
    // TEST4D_G behavior
    // uml: exit / { trace("Exit TEST4D_G."); }
    {
        // Step 1: execute action `trace("Exit TEST4D_G.");`
        trace("Exit TEST4D_G.");
    } // end of behavior for TEST4D_G
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4D_EXTERNAL_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST4D_G_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST4D_G behavior
    // uml: EV1 [trace_guard("State TEST4D_G: check behavior `EV1 TransitionTo(TEST4D_EXTERNAL.ChoicePoint())`.", true)] / { trace("Transition action `` for TEST4D_G to TEST4D_EXTERNAL.ChoicePoint()."); } TransitionTo(TEST4D_EXTERNAL.ChoicePoint())
    if (trace_guard("State TEST4D_G: check behavior `EV1 TransitionTo(TEST4D_EXTERNAL.ChoicePoint())`.", true))
    {
        // Step 1: Exit states until we reach `TEST4D_EXTERNAL` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, TEST4D_EXTERNAL_exit);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST4D_G to TEST4D_EXTERNAL.ChoicePoint().");`.
        trace("Transition action `` for TEST4D_G to TEST4D_EXTERNAL.ChoicePoint().");
        
        // Step 3: Enter/move towards transition target `TEST4D_EXTERNAL.ChoicePoint()`.
        // TEST4D_EXTERNAL.ChoicePoint() is a pseudo state and cannot have an `enter` trigger.
        
        // TEST4D_EXTERNAL.ChoicePoint() behavior
        // uml: / { trace("Transition action `` for TEST4D_EXTERNAL.ChoicePoint() to TEST4D_G_1."); } TransitionTo(TEST4D_G_1)
        {
            // Step 1: Exit states until we reach `TEST4D_EXTERNAL` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST4D_EXTERNAL.ChoicePoint() to TEST4D_G_1.");`.
            trace("Transition action `` for TEST4D_EXTERNAL.ChoicePoint() to TEST4D_G_1.");
            
            // Step 3: Enter/move towards transition target `TEST4D_G_1`.
            TEST4D_G_enter(self);
            TEST4D_G_1_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_TEST4D_G_1;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for TEST4D_EXTERNAL.ChoicePoint()
    } // end of behavior for TEST4D_G
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4D_G_1
////////////////////////////////////////////////////////////////////////////////

static void TEST4D_G_1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4D_G_1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST4D_G_1_ev2;
    
    // TEST4D_G_1 behavior
    // uml: enter / { trace("Enter TEST4D_G_1."); }
    {
        // Step 1: execute action `trace("Enter TEST4D_G_1.");`
        trace("Enter TEST4D_G_1.");
    } // end of behavior for TEST4D_G_1
}

static void TEST4D_G_1_exit(Spec2Sm* self)
{
    // TEST4D_G_1 behavior
    // uml: exit / { trace("Exit TEST4D_G_1."); }
    {
        // Step 1: execute action `trace("Exit TEST4D_G_1.");`
        trace("Exit TEST4D_G_1.");
    } // end of behavior for TEST4D_G_1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4D_G_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
}

static void TEST4D_G_1_ev2(Spec2Sm* self)
{
    // No ancestor state handles `EV2` event.
    
    // TEST4D_G_1 behavior
    // uml: EV2 [trace_guard("State TEST4D_G_1: check behavior `EV2 TransitionTo(TEST4D_EXTERNAL.ChoicePoint())`.", true)] / { trace("Transition action `` for TEST4D_G_1 to TEST4D_EXTERNAL.ChoicePoint()."); } TransitionTo(TEST4D_EXTERNAL.ChoicePoint())
    if (trace_guard("State TEST4D_G_1: check behavior `EV2 TransitionTo(TEST4D_EXTERNAL.ChoicePoint())`.", true))
    {
        // Step 1: Exit states until we reach `TEST4D_EXTERNAL` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, TEST4D_EXTERNAL_exit);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST4D_G_1 to TEST4D_EXTERNAL.ChoicePoint().");`.
        trace("Transition action `` for TEST4D_G_1 to TEST4D_EXTERNAL.ChoicePoint().");
        
        // Step 3: Enter/move towards transition target `TEST4D_EXTERNAL.ChoicePoint()`.
        // TEST4D_EXTERNAL.ChoicePoint() is a pseudo state and cannot have an `enter` trigger.
        
        // TEST4D_EXTERNAL.ChoicePoint() behavior
        // uml: / { trace("Transition action `` for TEST4D_EXTERNAL.ChoicePoint() to TEST4D_G."); } TransitionTo(TEST4D_G)
        {
            // Step 1: Exit states until we reach `TEST4D_EXTERNAL` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST4D_EXTERNAL.ChoicePoint() to TEST4D_G.");`.
            trace("Transition action `` for TEST4D_EXTERNAL.ChoicePoint() to TEST4D_G.");
            
            // Step 3: Enter/move towards transition target `TEST4D_G`.
            TEST4D_G_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_TEST4D_G;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for TEST4D_EXTERNAL.ChoicePoint()
    } // end of behavior for TEST4D_G_1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_DECIDE
////////////////////////////////////////////////////////////////////////////////

static void TEST4_DECIDE_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_DECIDE_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST4_DECIDE_ev1;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST4_DECIDE_ev2;
    self->current_event_handlers[Spec2Sm_EventId_EV3] = TEST4_DECIDE_ev3;
    self->current_event_handlers[Spec2Sm_EventId_EV4] = TEST4_DECIDE_ev4;
    
    // TEST4_DECIDE behavior
    // uml: enter / { trace("Enter TEST4_DECIDE."); }
    {
        // Step 1: execute action `trace("Enter TEST4_DECIDE.");`
        trace("Enter TEST4_DECIDE.");
    } // end of behavior for TEST4_DECIDE
}

static void TEST4_DECIDE_exit(Spec2Sm* self)
{
    // TEST4_DECIDE behavior
    // uml: exit / { trace("Exit TEST4_DECIDE."); }
    {
        // Step 1: execute action `trace("Exit TEST4_DECIDE.");`
        trace("Exit TEST4_DECIDE.");
    } // end of behavior for TEST4_DECIDE
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_PARENT_CHILD_TRANSITIONS_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV3] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV4] = NULL;  // no ancestor listens to this event
}

static void TEST4_DECIDE_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST4_DECIDE behavior
    // uml: EV1 [trace_guard("State TEST4_DECIDE: check behavior `EV1 TransitionTo(TEST4_ROOT)`.", true)] / { trace("Transition action `` for TEST4_DECIDE to TEST4_ROOT."); } TransitionTo(TEST4_ROOT)
    if (trace_guard("State TEST4_DECIDE: check behavior `EV1 TransitionTo(TEST4_ROOT)`.", true))
    {
        // Step 1: Exit states until we reach `TEST4_PARENT_CHILD_TRANSITIONS` state (Least Common Ancestor for transition).
        TEST4_DECIDE_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST4_DECIDE to TEST4_ROOT.");`.
        trace("Transition action `` for TEST4_DECIDE to TEST4_ROOT.");
        
        // Step 3: Enter/move towards transition target `TEST4_ROOT`.
        TEST4_ROOT_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST4_ROOT;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST4_DECIDE
}

static void TEST4_DECIDE_ev2(Spec2Sm* self)
{
    // No ancestor state handles `EV2` event.
    
    // TEST4_DECIDE behavior
    // uml: EV2 [trace_guard("State TEST4_DECIDE: check behavior `EV2 TransitionTo(TEST4B_LOCAL)`.", true)] / { trace("Transition action `` for TEST4_DECIDE to TEST4B_LOCAL."); } TransitionTo(TEST4B_LOCAL)
    if (trace_guard("State TEST4_DECIDE: check behavior `EV2 TransitionTo(TEST4B_LOCAL)`.", true))
    {
        // Step 1: Exit states until we reach `TEST4_PARENT_CHILD_TRANSITIONS` state (Least Common Ancestor for transition).
        TEST4_DECIDE_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST4_DECIDE to TEST4B_LOCAL.");`.
        trace("Transition action `` for TEST4_DECIDE to TEST4B_LOCAL.");
        
        // Step 3: Enter/move towards transition target `TEST4B_LOCAL`.
        TEST4_B_AND_OTHERS_enter(self);
        TEST4B_LOCAL_enter(self);
        
        // TEST4B_LOCAL.InitialState behavior
        // uml: / { trace("Transition action `` for TEST4B_LOCAL.InitialState to TEST4B_G."); } TransitionTo(TEST4B_G)
        {
            // Step 1: Exit states until we reach `TEST4B_LOCAL` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST4B_LOCAL.InitialState to TEST4B_G.");`.
            trace("Transition action `` for TEST4B_LOCAL.InitialState to TEST4B_G.");
            
            // Step 3: Enter/move towards transition target `TEST4B_G`.
            TEST4B_G_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_TEST4B_G;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for TEST4B_LOCAL.InitialState
    } // end of behavior for TEST4_DECIDE
}

static void TEST4_DECIDE_ev3(Spec2Sm* self)
{
    // No ancestor state handles `EV3` event.
    
    // TEST4_DECIDE behavior
    // uml: EV3 [trace_guard("State TEST4_DECIDE: check behavior `EV3 TransitionTo(TEST4C_LOCAL_TO_ALIAS)`.", true)] / { trace("Transition action `` for TEST4_DECIDE to TEST4C_LOCAL_TO_ALIAS."); } TransitionTo(TEST4C_LOCAL_TO_ALIAS)
    if (trace_guard("State TEST4_DECIDE: check behavior `EV3 TransitionTo(TEST4C_LOCAL_TO_ALIAS)`.", true))
    {
        // Step 1: Exit states until we reach `TEST4_PARENT_CHILD_TRANSITIONS` state (Least Common Ancestor for transition).
        TEST4_DECIDE_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST4_DECIDE to TEST4C_LOCAL_TO_ALIAS.");`.
        trace("Transition action `` for TEST4_DECIDE to TEST4C_LOCAL_TO_ALIAS.");
        
        // Step 3: Enter/move towards transition target `TEST4C_LOCAL_TO_ALIAS`.
        TEST4_B_AND_OTHERS_enter(self);
        TEST4C_LOCAL_TO_ALIAS_enter(self);
        
        // TEST4C_LOCAL_TO_ALIAS.InitialState behavior
        // uml: / { trace("Transition action `` for TEST4C_LOCAL_TO_ALIAS.InitialState to TEST4C_G."); } TransitionTo(TEST4C_G)
        {
            // Step 1: Exit states until we reach `TEST4C_LOCAL_TO_ALIAS` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST4C_LOCAL_TO_ALIAS.InitialState to TEST4C_G.");`.
            trace("Transition action `` for TEST4C_LOCAL_TO_ALIAS.InitialState to TEST4C_G.");
            
            // Step 3: Enter/move towards transition target `TEST4C_G`.
            TEST4C_G_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_TEST4C_G;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for TEST4C_LOCAL_TO_ALIAS.InitialState
    } // end of behavior for TEST4_DECIDE
}

static void TEST4_DECIDE_ev4(Spec2Sm* self)
{
    // No ancestor state handles `EV4` event.
    
    // TEST4_DECIDE behavior
    // uml: EV4 [trace_guard("State TEST4_DECIDE: check behavior `EV4 TransitionTo(TEST4D_EXTERNAL)`.", true)] / { trace("Transition action `` for TEST4_DECIDE to TEST4D_EXTERNAL."); } TransitionTo(TEST4D_EXTERNAL)
    if (trace_guard("State TEST4_DECIDE: check behavior `EV4 TransitionTo(TEST4D_EXTERNAL)`.", true))
    {
        // Step 1: Exit states until we reach `TEST4_PARENT_CHILD_TRANSITIONS` state (Least Common Ancestor for transition).
        TEST4_DECIDE_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST4_DECIDE to TEST4D_EXTERNAL.");`.
        trace("Transition action `` for TEST4_DECIDE to TEST4D_EXTERNAL.");
        
        // Step 3: Enter/move towards transition target `TEST4D_EXTERNAL`.
        TEST4_B_AND_OTHERS_enter(self);
        TEST4D_EXTERNAL_enter(self);
        
        // TEST4D_EXTERNAL.InitialState behavior
        // uml: / { trace("Transition action `` for TEST4D_EXTERNAL.InitialState to TEST4D_G."); } TransitionTo(TEST4D_G)
        {
            // Step 1: Exit states until we reach `TEST4D_EXTERNAL` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST4D_EXTERNAL.InitialState to TEST4D_G.");`.
            trace("Transition action `` for TEST4D_EXTERNAL.InitialState to TEST4D_G.");
            
            // Step 3: Enter/move towards transition target `TEST4D_G`.
            TEST4D_G_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_TEST4D_G;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for TEST4D_EXTERNAL.InitialState
    } // end of behavior for TEST4_DECIDE
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST4_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST4_ROOT_ev2;
    self->current_event_handlers[Spec2Sm_EventId_EV3] = TEST4_ROOT_ev3;
    self->current_event_handlers[Spec2Sm_EventId_EV4] = TEST4_ROOT_ev4;
    
    // TEST4_ROOT behavior
    // uml: enter / { trace("Enter TEST4_ROOT."); }
    {
        // Step 1: execute action `trace("Enter TEST4_ROOT.");`
        trace("Enter TEST4_ROOT.");
    } // end of behavior for TEST4_ROOT
    
    // TEST4_ROOT behavior
    // uml: enter [trace_guard("State TEST4_ROOT: check behavior `enter / { clear_output(); }`.", true)] / { clear_output(); }
    if (trace_guard("State TEST4_ROOT: check behavior `enter / { clear_output(); }`.", true))
    {
        // Step 1: execute action `clear_output();`
        trace("IGNORE_OUTPUT_BEFORE_THIS");;
    } // end of behavior for TEST4_ROOT
}

static void TEST4_ROOT_exit(Spec2Sm* self)
{
    // TEST4_ROOT behavior
    // uml: exit / { trace("Exit TEST4_ROOT."); }
    {
        // Step 1: execute action `trace("Exit TEST4_ROOT.");`
        trace("Exit TEST4_ROOT.");
    } // end of behavior for TEST4_ROOT
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_PARENT_CHILD_TRANSITIONS_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV3] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV4] = NULL;  // no ancestor listens to this event
}

static void TEST4_ROOT_ev2(Spec2Sm* self)
{
    // No ancestor state handles `EV2` event.
    
    // TEST4_ROOT behavior
    // uml: EV2 [trace_guard("State TEST4_ROOT: check behavior `EV2 TransitionTo(TEST4_S1)`.", true)] / { trace("Transition action `` for TEST4_ROOT to TEST4_S1."); } TransitionTo(TEST4_S1)
    if (trace_guard("State TEST4_ROOT: check behavior `EV2 TransitionTo(TEST4_S1)`.", true))
    {
        // Step 1: Exit states until we reach `TEST4_ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, TEST4_ROOT_exit);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST4_ROOT to TEST4_S1.");`.
        trace("Transition action `` for TEST4_ROOT to TEST4_S1.");
        
        // Step 3: Enter/move towards transition target `TEST4_S1`.
        TEST4_S1_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST4_S1;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST4_ROOT
}

static void TEST4_ROOT_ev3(Spec2Sm* self)
{
    // No ancestor state handles `EV3` event.
    
    // TEST4_ROOT behavior
    // uml: EV3 [trace_guard("State TEST4_ROOT: check behavior `EV3 TransitionTo(TEST4_S10_1)`.", true)] / { trace("Transition action `` for TEST4_ROOT to TEST4_S10_1."); } TransitionTo(TEST4_S10_1)
    if (trace_guard("State TEST4_ROOT: check behavior `EV3 TransitionTo(TEST4_S10_1)`.", true))
    {
        // Step 1: Exit states until we reach `TEST4_ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, TEST4_ROOT_exit);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST4_ROOT to TEST4_S10_1.");`.
        trace("Transition action `` for TEST4_ROOT to TEST4_S10_1.");
        
        // Step 3: Enter/move towards transition target `TEST4_S10_1`.
        TEST4_S10_enter(self);
        TEST4_S10_1_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST4_S10_1;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST4_ROOT
}

static void TEST4_ROOT_ev4(Spec2Sm* self)
{
    // No ancestor state handles `EV4` event.
    
    // TEST4_ROOT behavior
    // uml: EV4 [trace_guard("State TEST4_ROOT: check behavior `EV4 TransitionTo(TEST4_S20)`.", true)] / { trace("Transition action `` for TEST4_ROOT to TEST4_S20."); } TransitionTo(TEST4_S20)
    if (trace_guard("State TEST4_ROOT: check behavior `EV4 TransitionTo(TEST4_S20)`.", true))
    {
        // Step 1: Exit states until we reach `TEST4_ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, TEST4_ROOT_exit);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST4_ROOT to TEST4_S20.");`.
        trace("Transition action `` for TEST4_ROOT to TEST4_S20.");
        
        // Step 3: Enter/move towards transition target `TEST4_S20`.
        TEST4_S20_enter(self);
        
        // Finish transition by calling pseudo state transition function.
        TEST4_S20_InitialState_transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST4_ROOT
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST4_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST4_S1_ev1;
    
    // TEST4_S1 behavior
    // uml: enter / { trace("Enter TEST4_S1."); }
    {
        // Step 1: execute action `trace("Enter TEST4_S1.");`
        trace("Enter TEST4_S1.");
    } // end of behavior for TEST4_S1
}

static void TEST4_S1_exit(Spec2Sm* self)
{
    // TEST4_S1 behavior
    // uml: exit / { trace("Exit TEST4_S1."); }
    {
        // Step 1: execute action `trace("Exit TEST4_S1.");`
        trace("Exit TEST4_S1.");
    } // end of behavior for TEST4_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST4_S1_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST4_S1 behavior
    // uml: EV1 [trace_guard("State TEST4_S1: check behavior `EV1 TransitionTo(TEST4_S2)`.", true)] / { trace("Transition action `` for TEST4_S1 to TEST4_S2."); } TransitionTo(TEST4_S2)
    if (trace_guard("State TEST4_S1: check behavior `EV1 TransitionTo(TEST4_S2)`.", true))
    {
        // Step 1: Exit states until we reach `TEST4_ROOT` state (Least Common Ancestor for transition).
        TEST4_S1_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST4_S1 to TEST4_S2.");`.
        trace("Transition action `` for TEST4_S1 to TEST4_S2.");
        
        // Step 3: Enter/move towards transition target `TEST4_S2`.
        TEST4_S2_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST4_S2;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST4_S1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_S10
////////////////////////////////////////////////////////////////////////////////

static void TEST4_S10_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_S10_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV4] = TEST4_S10_ev4;
    
    // TEST4_S10 behavior
    // uml: enter / { trace("Enter TEST4_S10."); }
    {
        // Step 1: execute action `trace("Enter TEST4_S10.");`
        trace("Enter TEST4_S10.");
    } // end of behavior for TEST4_S10
}

static void TEST4_S10_exit(Spec2Sm* self)
{
    // TEST4_S10 behavior
    // uml: exit / { trace("Exit TEST4_S10."); }
    {
        // Step 1: execute action `trace("Exit TEST4_S10.");`
        trace("Exit TEST4_S10.");
    } // end of behavior for TEST4_S10
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV4] = TEST4_ROOT_ev4;  // the next ancestor that handles this event is TEST4_ROOT
}

static void TEST4_S10_ev4(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `EV4` event.
    self->ancestor_event_handler = TEST4_ROOT_ev4;
    
    // TEST4_S10 behavior
    // uml: EV4 [trace_guard("State TEST4_S10: check behavior `EV4 TransitionTo(TEST4_S10)`.", true)] / { trace("Transition action `` for TEST4_S10 to TEST4_S10."); } TransitionTo(TEST4_S10)
    if (trace_guard("State TEST4_S10: check behavior `EV4 TransitionTo(TEST4_S10)`.", true))
    {
        // Step 1: Exit states until we reach `TEST4_ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, TEST4_ROOT_exit);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST4_S10 to TEST4_S10.");`.
        trace("Transition action `` for TEST4_S10 to TEST4_S10.");
        
        // Step 3: Enter/move towards transition target `TEST4_S10`.
        TEST4_S10_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST4_S10;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for TEST4_S10
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_S10_1
////////////////////////////////////////////////////////////////////////////////

static void TEST4_S10_1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_S10_1_exit;
    
    // TEST4_S10_1 behavior
    // uml: enter / { trace("Enter TEST4_S10_1."); }
    {
        // Step 1: execute action `trace("Enter TEST4_S10_1.");`
        trace("Enter TEST4_S10_1.");
    } // end of behavior for TEST4_S10_1
}

static void TEST4_S10_1_exit(Spec2Sm* self)
{
    // TEST4_S10_1 behavior
    // uml: exit / { trace("Exit TEST4_S10_1."); }
    {
        // Step 1: execute action `trace("Exit TEST4_S10_1.");`
        trace("Exit TEST4_S10_1.");
    } // end of behavior for TEST4_S10_1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_S10_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST4_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_S2_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST4_S2_ev1;
    
    // TEST4_S2 behavior
    // uml: enter / { trace("Enter TEST4_S2."); }
    {
        // Step 1: execute action `trace("Enter TEST4_S2.");`
        trace("Enter TEST4_S2.");
    } // end of behavior for TEST4_S2
}

static void TEST4_S2_exit(Spec2Sm* self)
{
    // TEST4_S2 behavior
    // uml: exit / { trace("Exit TEST4_S2."); }
    {
        // Step 1: execute action `trace("Exit TEST4_S2.");`
        trace("Exit TEST4_S2.");
    } // end of behavior for TEST4_S2
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST4_S2_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST4_S2 behavior
    // uml: EV1 [trace_guard("State TEST4_S2: check behavior `EV1 TransitionTo(TEST4_S3)`.", true)] / { trace("Transition action `` for TEST4_S2 to TEST4_S3."); } TransitionTo(TEST4_S3)
    if (trace_guard("State TEST4_S2: check behavior `EV1 TransitionTo(TEST4_S3)`.", true))
    {
        // Step 1: Exit states until we reach `TEST4_ROOT` state (Least Common Ancestor for transition).
        TEST4_S2_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST4_S2 to TEST4_S3.");`.
        trace("Transition action `` for TEST4_S2 to TEST4_S3.");
        
        // Step 3: Enter/move towards transition target `TEST4_S3`.
        TEST4_S3_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST4_S3;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST4_S2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_S20
////////////////////////////////////////////////////////////////////////////////

static void TEST4_S20_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_S20_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV4] = TEST4_S20_ev4;
    
    // TEST4_S20 behavior
    // uml: enter / { trace("Enter TEST4_S20."); }
    {
        // Step 1: execute action `trace("Enter TEST4_S20.");`
        trace("Enter TEST4_S20.");
    } // end of behavior for TEST4_S20
}

static void TEST4_S20_exit(Spec2Sm* self)
{
    // TEST4_S20 behavior
    // uml: exit / { trace("Exit TEST4_S20."); }
    {
        // Step 1: execute action `trace("Exit TEST4_S20.");`
        trace("Exit TEST4_S20.");
    } // end of behavior for TEST4_S20
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV4] = TEST4_ROOT_ev4;  // the next ancestor that handles this event is TEST4_ROOT
}

static void TEST4_S20_ev4(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `EV4` event.
    self->ancestor_event_handler = TEST4_ROOT_ev4;
    
    // TEST4_S20 behavior
    // uml: EV4 [trace_guard("State TEST4_S20: check behavior `EV4 TransitionTo(TEST4_S20)`.", true)] / { trace("Transition action `` for TEST4_S20 to TEST4_S20."); } TransitionTo(TEST4_S20)
    if (trace_guard("State TEST4_S20: check behavior `EV4 TransitionTo(TEST4_S20)`.", true))
    {
        // Step 1: Exit states until we reach `TEST4_ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, TEST4_ROOT_exit);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST4_S20 to TEST4_S20.");`.
        trace("Transition action `` for TEST4_S20 to TEST4_S20.");
        
        // Step 3: Enter/move towards transition target `TEST4_S20`.
        TEST4_S20_enter(self);
        
        // Finish transition by calling pseudo state transition function.
        TEST4_S20_InitialState_transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST4_S20
}

static void TEST4_S20_InitialState_transition(Spec2Sm* self)
{
    // TEST4_S20.InitialState behavior
    // uml: / { trace("Transition action `` for TEST4_S20.InitialState to TEST4_S20_1."); } TransitionTo(TEST4_S20_1)
    {
        // Step 1: Exit states until we reach `TEST4_S20` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST4_S20.InitialState to TEST4_S20_1.");`.
        trace("Transition action `` for TEST4_S20.InitialState to TEST4_S20_1.");
        
        // Step 3: Enter/move towards transition target `TEST4_S20_1`.
        TEST4_S20_1_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST4_S20_1;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for TEST4_S20.InitialState
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_S20_1
////////////////////////////////////////////////////////////////////////////////

static void TEST4_S20_1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_S20_1_exit;
    
    // TEST4_S20_1 behavior
    // uml: enter / { trace("Enter TEST4_S20_1."); }
    {
        // Step 1: execute action `trace("Enter TEST4_S20_1.");`
        trace("Enter TEST4_S20_1.");
    } // end of behavior for TEST4_S20_1
}

static void TEST4_S20_1_exit(Spec2Sm* self)
{
    // TEST4_S20_1 behavior
    // uml: exit / { trace("Exit TEST4_S20_1."); }
    {
        // Step 1: execute action `trace("Exit TEST4_S20_1.");`
        trace("Exit TEST4_S20_1.");
    } // end of behavior for TEST4_S20_1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_S20_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST4_S3
////////////////////////////////////////////////////////////////////////////////

static void TEST4_S3_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST4_S3_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST4_S3_ev1;
    
    // TEST4_S3 behavior
    // uml: enter / { trace("Enter TEST4_S3."); }
    {
        // Step 1: execute action `trace("Enter TEST4_S3.");`
        trace("Enter TEST4_S3.");
    } // end of behavior for TEST4_S3
}

static void TEST4_S3_exit(Spec2Sm* self)
{
    // TEST4_S3 behavior
    // uml: exit / { trace("Exit TEST4_S3."); }
    {
        // Step 1: execute action `trace("Exit TEST4_S3.");`
        trace("Exit TEST4_S3.");
    } // end of behavior for TEST4_S3
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST4_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST4_S3_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST4_S3 behavior
    // uml: EV1 [trace_guard("State TEST4_S3: check behavior `EV1 TransitionTo(TEST4_ROOT)`.", true)] / { trace("Transition action `` for TEST4_S3 to TEST4_ROOT."); } TransitionTo(TEST4_ROOT)
    if (trace_guard("State TEST4_S3: check behavior `EV1 TransitionTo(TEST4_ROOT)`.", true))
    {
        // Step 1: Exit states until we reach `TEST4_ROOT` state (Least Common Ancestor for transition).
        TEST4_S3_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST4_S3 to TEST4_ROOT.");`.
        trace("Transition action `` for TEST4_S3 to TEST4_ROOT.");
        
        // Step 3: Enter/move towards transition target `TEST4_ROOT`.
        // Already in target. No entering required.
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST4_ROOT;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST4_S3
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST5_PARENT_CHILD_TRANSITIONS_ALIAS
////////////////////////////////////////////////////////////////////////////////

static void TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_exit;
    
    // TEST5_PARENT_CHILD_TRANSITIONS_ALIAS behavior
    // uml: enter / { trace("Enter TEST5_PARENT_CHILD_TRANSITIONS_ALIAS."); }
    {
        // Step 1: execute action `trace("Enter TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.");`
        trace("Enter TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.");
    } // end of behavior for TEST5_PARENT_CHILD_TRANSITIONS_ALIAS
}

static void TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_exit(Spec2Sm* self)
{
    // TEST5_PARENT_CHILD_TRANSITIONS_ALIAS behavior
    // uml: exit / { trace("Exit TEST5_PARENT_CHILD_TRANSITIONS_ALIAS."); }
    {
        // Step 1: execute action `trace("Exit TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.");`
        trace("Exit TEST5_PARENT_CHILD_TRANSITIONS_ALIAS.");
    } // end of behavior for TEST5_PARENT_CHILD_TRANSITIONS_ALIAS
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST5_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST5_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST5_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST5_ROOT_ev2;
    
    // TEST5_ROOT behavior
    // uml: enter / { trace("Enter TEST5_ROOT."); }
    {
        // Step 1: execute action `trace("Enter TEST5_ROOT.");`
        trace("Enter TEST5_ROOT.");
    } // end of behavior for TEST5_ROOT
    
    // TEST5_ROOT behavior
    // uml: enter [trace_guard("State TEST5_ROOT: check behavior `enter / { clear_output(); }`.", true)] / { clear_output(); }
    if (trace_guard("State TEST5_ROOT: check behavior `enter / { clear_output(); }`.", true))
    {
        // Step 1: execute action `clear_output();`
        trace("IGNORE_OUTPUT_BEFORE_THIS");;
    } // end of behavior for TEST5_ROOT
}

static void TEST5_ROOT_exit(Spec2Sm* self)
{
    // TEST5_ROOT behavior
    // uml: exit / { trace("Exit TEST5_ROOT."); }
    {
        // Step 1: execute action `trace("Exit TEST5_ROOT.");`
        trace("Exit TEST5_ROOT.");
    } // end of behavior for TEST5_ROOT
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST5_PARENT_CHILD_TRANSITIONS_ALIAS_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
}

static void TEST5_ROOT_ev2(Spec2Sm* self)
{
    // No ancestor state handles `EV2` event.
    
    // TEST5_ROOT behavior
    // uml: EV2 [trace_guard("State TEST5_ROOT: check behavior `EV2 TransitionTo(TEST5_S1)`.", true)] / { trace("Transition action `` for TEST5_ROOT to TEST5_S1."); } TransitionTo(TEST5_S1)
    if (trace_guard("State TEST5_ROOT: check behavior `EV2 TransitionTo(TEST5_S1)`.", true))
    {
        // Step 1: Exit states until we reach `TEST5_ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, TEST5_ROOT_exit);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST5_ROOT to TEST5_S1.");`.
        trace("Transition action `` for TEST5_ROOT to TEST5_S1.");
        
        // Step 3: Enter/move towards transition target `TEST5_S1`.
        TEST5_S1_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST5_S1;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST5_ROOT
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST5_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST5_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST5_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST5_S1_ev1;
    
    // TEST5_S1 behavior
    // uml: enter / { trace("Enter TEST5_S1."); }
    {
        // Step 1: execute action `trace("Enter TEST5_S1.");`
        trace("Enter TEST5_S1.");
    } // end of behavior for TEST5_S1
}

static void TEST5_S1_exit(Spec2Sm* self)
{
    // TEST5_S1 behavior
    // uml: exit / { trace("Exit TEST5_S1."); }
    {
        // Step 1: execute action `trace("Exit TEST5_S1.");`
        trace("Exit TEST5_S1.");
    } // end of behavior for TEST5_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST5_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST5_S1_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST5_S1 behavior
    // uml: EV1 [trace_guard("State TEST5_S1: check behavior `EV1 TransitionTo(TEST5_S2)`.", true)] / { trace("Transition action `` for TEST5_S1 to TEST5_S2."); } TransitionTo(TEST5_S2)
    if (trace_guard("State TEST5_S1: check behavior `EV1 TransitionTo(TEST5_S2)`.", true))
    {
        // Step 1: Exit states until we reach `TEST5_ROOT` state (Least Common Ancestor for transition).
        TEST5_S1_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST5_S1 to TEST5_S2.");`.
        trace("Transition action `` for TEST5_S1 to TEST5_S2.");
        
        // Step 3: Enter/move towards transition target `TEST5_S2`.
        TEST5_S2_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST5_S2;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST5_S1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST5_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST5_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST5_S2_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST5_S2_ev1;
    
    // TEST5_S2 behavior
    // uml: enter / { trace("Enter TEST5_S2."); }
    {
        // Step 1: execute action `trace("Enter TEST5_S2.");`
        trace("Enter TEST5_S2.");
    } // end of behavior for TEST5_S2
}

static void TEST5_S2_exit(Spec2Sm* self)
{
    // TEST5_S2 behavior
    // uml: exit / { trace("Exit TEST5_S2."); }
    {
        // Step 1: execute action `trace("Exit TEST5_S2.");`
        trace("Exit TEST5_S2.");
    } // end of behavior for TEST5_S2
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST5_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST5_S2_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST5_S2 behavior
    // uml: EV1 [trace_guard("State TEST5_S2: check behavior `EV1 TransitionTo(TEST5_S3)`.", true)] / { trace("Transition action `` for TEST5_S2 to TEST5_S3."); } TransitionTo(TEST5_S3)
    if (trace_guard("State TEST5_S2: check behavior `EV1 TransitionTo(TEST5_S3)`.", true))
    {
        // Step 1: Exit states until we reach `TEST5_ROOT` state (Least Common Ancestor for transition).
        TEST5_S2_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST5_S2 to TEST5_S3.");`.
        trace("Transition action `` for TEST5_S2 to TEST5_S3.");
        
        // Step 3: Enter/move towards transition target `TEST5_S3`.
        TEST5_S3_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST5_S3;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST5_S2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST5_S3
////////////////////////////////////////////////////////////////////////////////

static void TEST5_S3_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST5_S3_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST5_S3_ev1;
    
    // TEST5_S3 behavior
    // uml: enter / { trace("Enter TEST5_S3."); }
    {
        // Step 1: execute action `trace("Enter TEST5_S3.");`
        trace("Enter TEST5_S3.");
    } // end of behavior for TEST5_S3
}

static void TEST5_S3_exit(Spec2Sm* self)
{
    // TEST5_S3 behavior
    // uml: exit / { trace("Exit TEST5_S3."); }
    {
        // Step 1: execute action `trace("Exit TEST5_S3.");`
        trace("Exit TEST5_S3.");
    } // end of behavior for TEST5_S3
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST5_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST5_S3_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST5_S3 behavior
    // uml: EV1 [trace_guard("State TEST5_S3: check behavior `EV1 TransitionTo(TEST5_ROOT)`.", true)] / { trace("Transition action `` for TEST5_S3 to TEST5_ROOT."); } TransitionTo(TEST5_ROOT)
    if (trace_guard("State TEST5_S3: check behavior `EV1 TransitionTo(TEST5_ROOT)`.", true))
    {
        // Step 1: Exit states until we reach `TEST5_ROOT` state (Least Common Ancestor for transition).
        TEST5_S3_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST5_S3 to TEST5_ROOT.");`.
        trace("Transition action `` for TEST5_S3 to TEST5_ROOT.");
        
        // Step 3: Enter/move towards transition target `TEST5_ROOT`.
        // Already in target. No entering required.
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST5_ROOT;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST5_S3
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST6_VARIABLES
////////////////////////////////////////////////////////////////////////////////

static void TEST6_VARIABLES_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST6_VARIABLES_exit;
    
    // TEST6_VARIABLES behavior
    // uml: enter / { trace("Enter TEST6_VARIABLES."); }
    {
        // Step 1: execute action `trace("Enter TEST6_VARIABLES.");`
        trace("Enter TEST6_VARIABLES.");
    } // end of behavior for TEST6_VARIABLES
}

static void TEST6_VARIABLES_exit(Spec2Sm* self)
{
    // TEST6_VARIABLES behavior
    // uml: exit / { trace("Exit TEST6_VARIABLES."); }
    {
        // Step 1: execute action `trace("Exit TEST6_VARIABLES.");`
        trace("Exit TEST6_VARIABLES.");
    } // end of behavior for TEST6_VARIABLES
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST6_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST6_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST6_ROOT_exit;
    
    // TEST6_ROOT behavior
    // uml: enter / { trace("Enter TEST6_ROOT."); }
    {
        // Step 1: execute action `trace("Enter TEST6_ROOT.");`
        trace("Enter TEST6_ROOT.");
    } // end of behavior for TEST6_ROOT
}

static void TEST6_ROOT_exit(Spec2Sm* self)
{
    // TEST6_ROOT behavior
    // uml: exit / { trace("Exit TEST6_ROOT."); }
    {
        // Step 1: execute action `trace("Exit TEST6_ROOT.");`
        trace("Exit TEST6_ROOT.");
    } // end of behavior for TEST6_ROOT
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST6_VARIABLES_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST6_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST6_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST6_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST6_S1_ev1;
    
    // TEST6_S1 behavior
    // uml: enter / { trace("Enter TEST6_S1."); }
    {
        // Step 1: execute action `trace("Enter TEST6_S1.");`
        trace("Enter TEST6_S1.");
    } // end of behavior for TEST6_S1
    
    // TEST6_S1 behavior
    // uml: enter [trace_guard("State TEST6_S1: check behavior `enter / { clear_output(); }`.", true)] / { clear_output(); }
    if (trace_guard("State TEST6_S1: check behavior `enter / { clear_output(); }`.", true))
    {
        // Step 1: execute action `clear_output();`
        trace("IGNORE_OUTPUT_BEFORE_THIS");;
    } // end of behavior for TEST6_S1
}

static void TEST6_S1_exit(Spec2Sm* self)
{
    // TEST6_S1 behavior
    // uml: exit / { trace("Exit TEST6_S1."); }
    {
        // Step 1: execute action `trace("Exit TEST6_S1.");`
        trace("Exit TEST6_S1.");
    } // end of behavior for TEST6_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST6_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST6_S1_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST6_S1 behavior
    // uml: 1. EV1 [trace_guard("State TEST6_S1: check behavior `1. EV1 / { count++; }`.", true)] / { count++; }
    if (trace_guard("State TEST6_S1: check behavior `1. EV1 / { count++; }`.", true))
    {
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        
        // Step 1: execute action `count++;`
        self->vars.count++;
        
        // Step 2: determine if ancestor gets to handle event next.
        // No ancestor handles event. Ignore `consume_event` flag.
    } // end of behavior for TEST6_S1
    
    // TEST6_S1 behavior
    // uml: 2. EV1 [trace_guard("State TEST6_S1: check behavior `2. EV1 [count >= 2] TransitionTo(TEST6_S2)`.", count >= 2)] / { trace("Transition action `` for TEST6_S1 to TEST6_S2."); } TransitionTo(TEST6_S2)
    if (trace_guard("State TEST6_S1: check behavior `2. EV1 [count >= 2] TransitionTo(TEST6_S2)`.", self->vars.count >= 2))
    {
        // Step 1: Exit states until we reach `TEST6_ROOT` state (Least Common Ancestor for transition).
        TEST6_S1_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST6_S1 to TEST6_S2.");`.
        trace("Transition action `` for TEST6_S1 to TEST6_S2.");
        
        // Step 3: Enter/move towards transition target `TEST6_S2`.
        TEST6_S2_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST6_S2;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST6_S1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST6_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST6_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST6_S2_exit;
    
    // TEST6_S2 behavior
    // uml: enter / { trace("Enter TEST6_S2."); }
    {
        // Step 1: execute action `trace("Enter TEST6_S2.");`
        trace("Enter TEST6_S2.");
    } // end of behavior for TEST6_S2
}

static void TEST6_S2_exit(Spec2Sm* self)
{
    // TEST6_S2 behavior
    // uml: exit / { trace("Exit TEST6_S2."); }
    {
        // Step 1: execute action `trace("Exit TEST6_S2.");`
        trace("Exit TEST6_S2.");
    } // end of behavior for TEST6_S2
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST6_ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7_INITIAL_OR_HISTORY
////////////////////////////////////////////////////////////////////////////////

static void TEST7_INITIAL_OR_HISTORY_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7_INITIAL_OR_HISTORY_exit;
    
    // TEST7_INITIAL_OR_HISTORY behavior
    // uml: enter / { trace("Enter TEST7_INITIAL_OR_HISTORY."); }
    {
        // Step 1: execute action `trace("Enter TEST7_INITIAL_OR_HISTORY.");`
        trace("Enter TEST7_INITIAL_OR_HISTORY.");
    } // end of behavior for TEST7_INITIAL_OR_HISTORY
}

static void TEST7_INITIAL_OR_HISTORY_exit(Spec2Sm* self)
{
    // TEST7_INITIAL_OR_HISTORY behavior
    // uml: exit / { trace("Exit TEST7_INITIAL_OR_HISTORY."); }
    {
        // Step 1: execute action `trace("Exit TEST7_INITIAL_OR_HISTORY.");`
        trace("Exit TEST7_INITIAL_OR_HISTORY.");
    } // end of behavior for TEST7_INITIAL_OR_HISTORY
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7
////////////////////////////////////////////////////////////////////////////////

static void TEST7_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7_exit;
    
    // TEST7 behavior
    // uml: enter / { trace("Enter TEST7."); }
    {
        // Step 1: execute action `trace("Enter TEST7.");`
        trace("Enter TEST7.");
    } // end of behavior for TEST7
    
    // TEST7 behavior
    // uml: enter [trace_guard("State TEST7: check behavior `enter / { clear_dispatch_output(); }`.", true)] / { clear_dispatch_output(); }
    if (trace_guard("State TEST7: check behavior `enter / { clear_dispatch_output(); }`.", true))
    {
        // Step 1: execute action `clear_dispatch_output();`
        trace("CLEAR_OUTPUT_BEFORE_THIS_AND_FOR_THIS_EVENT_DISPATCH");;
    } // end of behavior for TEST7
}

static void TEST7_exit(Spec2Sm* self)
{
    // TEST7 behavior
    // uml: exit / { trace("Exit TEST7."); }
    {
        // Step 1: execute action `trace("Exit TEST7.");`
        trace("Exit TEST7.");
    } // end of behavior for TEST7
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7_INITIAL_OR_HISTORY_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7__HISTORY1
////////////////////////////////////////////////////////////////////////////////

static void TEST7__HISTORY1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7__HISTORY1_exit;
    
    // TEST7__HISTORY1 behavior
    // uml: enter / { trace("Enter TEST7__HISTORY1."); }
    {
        // Step 1: execute action `trace("Enter TEST7__HISTORY1.");`
        trace("Enter TEST7__HISTORY1.");
    } // end of behavior for TEST7__HISTORY1
}

static void TEST7__HISTORY1_exit(Spec2Sm* self)
{
    // TEST7__HISTORY1 behavior
    // uml: exit / { trace("Exit TEST7__HISTORY1."); }
    {
        // Step 1: execute action `trace("Exit TEST7__HISTORY1.");`
        trace("Exit TEST7__HISTORY1.");
    } // end of behavior for TEST7__HISTORY1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7__HISTORY1__OFF
////////////////////////////////////////////////////////////////////////////////

static void TEST7__HISTORY1__OFF_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7__HISTORY1__OFF_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV3] = TEST7__HISTORY1__OFF_ev3;
    self->current_event_handlers[Spec2Sm_EventId_EV4] = TEST7__HISTORY1__OFF_ev4;
    self->current_event_handlers[Spec2Sm_EventId_EV7] = TEST7__HISTORY1__OFF_ev7;
    
    // TEST7__HISTORY1__OFF behavior
    // uml: enter / { trace("Enter TEST7__HISTORY1__OFF."); }
    {
        // Step 1: execute action `trace("Enter TEST7__HISTORY1__OFF.");`
        trace("Enter TEST7__HISTORY1__OFF.");
    } // end of behavior for TEST7__HISTORY1__OFF
}

static void TEST7__HISTORY1__OFF_exit(Spec2Sm* self)
{
    // TEST7__HISTORY1__OFF behavior
    // uml: exit / { trace("Exit TEST7__HISTORY1__OFF."); }
    {
        // Step 1: execute action `trace("Exit TEST7__HISTORY1__OFF.");`
        trace("Exit TEST7__HISTORY1__OFF.");
    } // end of behavior for TEST7__HISTORY1__OFF
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7__HISTORY1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV3] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV4] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV7] = NULL;  // no ancestor listens to this event
}

static void TEST7__HISTORY1__OFF_ev3(Spec2Sm* self)
{
    // No ancestor state handles `EV3` event.
    
    // TEST7__HISTORY1__OFF behavior
    // uml: EV3 [trace_guard("State TEST7__HISTORY1__OFF: check behavior `EV3 TransitionTo(TEST7__HISTORY1__OFF3)`.", true)] / { trace("Transition action `` for TEST7__HISTORY1__OFF to TEST7__HISTORY1__OFF3."); } TransitionTo(TEST7__HISTORY1__OFF3)
    if (trace_guard("State TEST7__HISTORY1__OFF: check behavior `EV3 TransitionTo(TEST7__HISTORY1__OFF3)`.", true))
    {
        // Step 1: Exit states until we reach `TEST7__HISTORY1__OFF` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, TEST7__HISTORY1__OFF_exit);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7__HISTORY1__OFF to TEST7__HISTORY1__OFF3.");`.
        trace("Transition action `` for TEST7__HISTORY1__OFF to TEST7__HISTORY1__OFF3.");
        
        // Step 3: Enter/move towards transition target `TEST7__HISTORY1__OFF3`.
        TEST7__HISTORY1__OFF3_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST7__HISTORY1__OFF3;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST7__HISTORY1__OFF
}

static void TEST7__HISTORY1__OFF_ev4(Spec2Sm* self)
{
    // No ancestor state handles `EV4` event.
    
    // TEST7__HISTORY1__OFF behavior
    // uml: EV4 [trace_guard("State TEST7__HISTORY1__OFF: check behavior `EV4 TransitionTo(TEST7__HISTORY1__OFF)`.", true)] / { trace("Transition action `` for TEST7__HISTORY1__OFF to TEST7__HISTORY1__OFF."); } TransitionTo(TEST7__HISTORY1__OFF)
    if (trace_guard("State TEST7__HISTORY1__OFF: check behavior `EV4 TransitionTo(TEST7__HISTORY1__OFF)`.", true))
    {
        // Step 1: Exit states until we reach `TEST7__HISTORY1` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, TEST7__HISTORY1_exit);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7__HISTORY1__OFF to TEST7__HISTORY1__OFF.");`.
        trace("Transition action `` for TEST7__HISTORY1__OFF to TEST7__HISTORY1__OFF.");
        
        // Step 3: Enter/move towards transition target `TEST7__HISTORY1__OFF`.
        TEST7__HISTORY1__OFF_enter(self);
        
        // Finish transition by calling pseudo state transition function.
        TEST7__HISTORY1__OFF_InitialState_transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST7__HISTORY1__OFF
}

static void TEST7__HISTORY1__OFF_ev7(Spec2Sm* self)
{
    // No ancestor state handles `EV7` event.
    
    // TEST7__HISTORY1__OFF behavior
    // uml: EV7 [trace_guard("State TEST7__HISTORY1__OFF: check behavior `EV7 TransitionTo(TEST7__HISTORY1__ON)`.", true)] / { trace("Transition action `` for TEST7__HISTORY1__OFF to TEST7__HISTORY1__ON."); } TransitionTo(TEST7__HISTORY1__ON)
    if (trace_guard("State TEST7__HISTORY1__OFF: check behavior `EV7 TransitionTo(TEST7__HISTORY1__ON)`.", true))
    {
        // Step 1: Exit states until we reach `TEST7__HISTORY1` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, TEST7__HISTORY1_exit);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7__HISTORY1__OFF to TEST7__HISTORY1__ON.");`.
        trace("Transition action `` for TEST7__HISTORY1__OFF to TEST7__HISTORY1__ON.");
        
        // Step 3: Enter/move towards transition target `TEST7__HISTORY1__ON`.
        TEST7__HISTORY1__ON_enter(self);
        
        // Finish transition by calling pseudo state transition function.
        TEST7__HISTORY1__ON_InitialState_transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST7__HISTORY1__OFF
}

static void TEST7__HISTORY1__OFF_InitialState_transition(Spec2Sm* self)
{
    // TEST7__HISTORY1__OFF.InitialState behavior
    // uml: / { trace("Transition action `` for TEST7__HISTORY1__OFF.InitialState to TEST7__HISTORY1__OFF1."); } TransitionTo(TEST7__HISTORY1__OFF1)
    {
        // Step 1: Exit states until we reach `TEST7__HISTORY1__OFF` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7__HISTORY1__OFF.InitialState to TEST7__HISTORY1__OFF1.");`.
        trace("Transition action `` for TEST7__HISTORY1__OFF.InitialState to TEST7__HISTORY1__OFF1.");
        
        // Step 3: Enter/move towards transition target `TEST7__HISTORY1__OFF1`.
        TEST7__HISTORY1__OFF1_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST7__HISTORY1__OFF1;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for TEST7__HISTORY1__OFF.InitialState
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7__HISTORY1__OFF1
////////////////////////////////////////////////////////////////////////////////

static void TEST7__HISTORY1__OFF1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7__HISTORY1__OFF1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST7__HISTORY1__OFF1_ev1;
    
    // TEST7__HISTORY1__OFF1 behavior
    // uml: enter / { trace("Enter TEST7__HISTORY1__OFF1."); }
    {
        // Step 1: execute action `trace("Enter TEST7__HISTORY1__OFF1.");`
        trace("Enter TEST7__HISTORY1__OFF1.");
    } // end of behavior for TEST7__HISTORY1__OFF1
    
    // TEST7__HISTORY1__OFF1 behavior
    // uml: enter [trace_guard("State TEST7__HISTORY1__OFF1: check behavior `enter / { OFF_history_state_tracking_var_name___$$$$ = 0; }`.", true)] / { OFF_history_state_tracking_var_name___$$$$ = 0; }
    if (trace_guard("State TEST7__HISTORY1__OFF1: check behavior `enter / { OFF_history_state_tracking_var_name___$$$$ = 0; }`.", true))
    {
        // Step 1: execute action `OFF_history_state_tracking_var_name___$$$$ = 0;`
        self->vars.TEST7__HISTORY1__OFF_history_tracking_var = 0;
    } // end of behavior for TEST7__HISTORY1__OFF1
}

static void TEST7__HISTORY1__OFF1_exit(Spec2Sm* self)
{
    // TEST7__HISTORY1__OFF1 behavior
    // uml: exit / { trace("Exit TEST7__HISTORY1__OFF1."); }
    {
        // Step 1: execute action `trace("Exit TEST7__HISTORY1__OFF1.");`
        trace("Exit TEST7__HISTORY1__OFF1.");
    } // end of behavior for TEST7__HISTORY1__OFF1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7__HISTORY1__OFF_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST7__HISTORY1__OFF1_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST7__HISTORY1__OFF1 behavior
    // uml: EV1 [trace_guard("State TEST7__HISTORY1__OFF1: check behavior `EV1 TransitionTo(TEST7__HISTORY1__OFF2)`.", true)] / { trace("Transition action `` for TEST7__HISTORY1__OFF1 to TEST7__HISTORY1__OFF2."); } TransitionTo(TEST7__HISTORY1__OFF2)
    if (trace_guard("State TEST7__HISTORY1__OFF1: check behavior `EV1 TransitionTo(TEST7__HISTORY1__OFF2)`.", true))
    {
        // Step 1: Exit states until we reach `TEST7__HISTORY1__OFF` state (Least Common Ancestor for transition).
        TEST7__HISTORY1__OFF1_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7__HISTORY1__OFF1 to TEST7__HISTORY1__OFF2.");`.
        trace("Transition action `` for TEST7__HISTORY1__OFF1 to TEST7__HISTORY1__OFF2.");
        
        // Step 3: Enter/move towards transition target `TEST7__HISTORY1__OFF2`.
        TEST7__HISTORY1__OFF2_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST7__HISTORY1__OFF2;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST7__HISTORY1__OFF1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7__HISTORY1__OFF2
////////////////////////////////////////////////////////////////////////////////

static void TEST7__HISTORY1__OFF2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7__HISTORY1__OFF2_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST7__HISTORY1__OFF2_ev1;
    
    // TEST7__HISTORY1__OFF2 behavior
    // uml: enter / { trace("Enter TEST7__HISTORY1__OFF2."); }
    {
        // Step 1: execute action `trace("Enter TEST7__HISTORY1__OFF2.");`
        trace("Enter TEST7__HISTORY1__OFF2.");
    } // end of behavior for TEST7__HISTORY1__OFF2
    
    // TEST7__HISTORY1__OFF2 behavior
    // uml: enter [trace_guard("State TEST7__HISTORY1__OFF2: check behavior `enter / { OFF_history_state_tracking_var_name___$$$$ = 1; }`.", true)] / { OFF_history_state_tracking_var_name___$$$$ = 1; }
    if (trace_guard("State TEST7__HISTORY1__OFF2: check behavior `enter / { OFF_history_state_tracking_var_name___$$$$ = 1; }`.", true))
    {
        // Step 1: execute action `OFF_history_state_tracking_var_name___$$$$ = 1;`
        self->vars.TEST7__HISTORY1__OFF_history_tracking_var = 1;
    } // end of behavior for TEST7__HISTORY1__OFF2
}

static void TEST7__HISTORY1__OFF2_exit(Spec2Sm* self)
{
    // TEST7__HISTORY1__OFF2 behavior
    // uml: exit / { trace("Exit TEST7__HISTORY1__OFF2."); }
    {
        // Step 1: execute action `trace("Exit TEST7__HISTORY1__OFF2.");`
        trace("Exit TEST7__HISTORY1__OFF2.");
    } // end of behavior for TEST7__HISTORY1__OFF2
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7__HISTORY1__OFF_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST7__HISTORY1__OFF2_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST7__HISTORY1__OFF2 behavior
    // uml: EV1 [trace_guard("State TEST7__HISTORY1__OFF2: check behavior `EV1 TransitionTo(TEST7__HISTORY1__OFF3)`.", true)] / { trace("Transition action `` for TEST7__HISTORY1__OFF2 to TEST7__HISTORY1__OFF3."); } TransitionTo(TEST7__HISTORY1__OFF3)
    if (trace_guard("State TEST7__HISTORY1__OFF2: check behavior `EV1 TransitionTo(TEST7__HISTORY1__OFF3)`.", true))
    {
        // Step 1: Exit states until we reach `TEST7__HISTORY1__OFF` state (Least Common Ancestor for transition).
        TEST7__HISTORY1__OFF2_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7__HISTORY1__OFF2 to TEST7__HISTORY1__OFF3.");`.
        trace("Transition action `` for TEST7__HISTORY1__OFF2 to TEST7__HISTORY1__OFF3.");
        
        // Step 3: Enter/move towards transition target `TEST7__HISTORY1__OFF3`.
        TEST7__HISTORY1__OFF3_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST7__HISTORY1__OFF3;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST7__HISTORY1__OFF2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7__HISTORY1__OFF3
////////////////////////////////////////////////////////////////////////////////

static void TEST7__HISTORY1__OFF3_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7__HISTORY1__OFF3_exit;
    
    // TEST7__HISTORY1__OFF3 behavior
    // uml: enter / { trace("Enter TEST7__HISTORY1__OFF3."); }
    {
        // Step 1: execute action `trace("Enter TEST7__HISTORY1__OFF3.");`
        trace("Enter TEST7__HISTORY1__OFF3.");
    } // end of behavior for TEST7__HISTORY1__OFF3
    
    // TEST7__HISTORY1__OFF3 behavior
    // uml: enter [trace_guard("State TEST7__HISTORY1__OFF3: check behavior `enter / { OFF_history_state_tracking_var_name___$$$$ = 2; }`.", true)] / { OFF_history_state_tracking_var_name___$$$$ = 2; }
    if (trace_guard("State TEST7__HISTORY1__OFF3: check behavior `enter / { OFF_history_state_tracking_var_name___$$$$ = 2; }`.", true))
    {
        // Step 1: execute action `OFF_history_state_tracking_var_name___$$$$ = 2;`
        self->vars.TEST7__HISTORY1__OFF_history_tracking_var = 2;
    } // end of behavior for TEST7__HISTORY1__OFF3
}

static void TEST7__HISTORY1__OFF3_exit(Spec2Sm* self)
{
    // TEST7__HISTORY1__OFF3 behavior
    // uml: exit / { trace("Exit TEST7__HISTORY1__OFF3."); }
    {
        // Step 1: execute action `trace("Exit TEST7__HISTORY1__OFF3.");`
        trace("Exit TEST7__HISTORY1__OFF3.");
    } // end of behavior for TEST7__HISTORY1__OFF3
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7__HISTORY1__OFF_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7__HISTORY1__ON
////////////////////////////////////////////////////////////////////////////////

static void TEST7__HISTORY1__ON_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7__HISTORY1__ON_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV6] = TEST7__HISTORY1__ON_ev6;
    
    // TEST7__HISTORY1__ON behavior
    // uml: enter / { trace("Enter TEST7__HISTORY1__ON."); }
    {
        // Step 1: execute action `trace("Enter TEST7__HISTORY1__ON.");`
        trace("Enter TEST7__HISTORY1__ON.");
    } // end of behavior for TEST7__HISTORY1__ON
}

static void TEST7__HISTORY1__ON_exit(Spec2Sm* self)
{
    // TEST7__HISTORY1__ON behavior
    // uml: exit / { trace("Exit TEST7__HISTORY1__ON."); }
    {
        // Step 1: execute action `trace("Exit TEST7__HISTORY1__ON.");`
        trace("Exit TEST7__HISTORY1__ON.");
    } // end of behavior for TEST7__HISTORY1__ON
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7__HISTORY1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV6] = NULL;  // no ancestor listens to this event
}

static void TEST7__HISTORY1__ON_ev6(Spec2Sm* self)
{
    // No ancestor state handles `EV6` event.
    
    // TEST7__HISTORY1__ON behavior
    // uml: EV6 [trace_guard("State TEST7__HISTORY1__ON: check behavior `EV6 TransitionTo(TEST7__HISTORY1__OFF)`.", true)] / { trace("Transition action `` for TEST7__HISTORY1__ON to TEST7__HISTORY1__OFF."); } TransitionTo(TEST7__HISTORY1__OFF)
    if (trace_guard("State TEST7__HISTORY1__ON: check behavior `EV6 TransitionTo(TEST7__HISTORY1__OFF)`.", true))
    {
        // Step 1: Exit states until we reach `TEST7__HISTORY1` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, TEST7__HISTORY1_exit);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7__HISTORY1__ON to TEST7__HISTORY1__OFF.");`.
        trace("Transition action `` for TEST7__HISTORY1__ON to TEST7__HISTORY1__OFF.");
        
        // Step 3: Enter/move towards transition target `TEST7__HISTORY1__OFF`.
        TEST7__HISTORY1__OFF_enter(self);
        
        // Finish transition by calling pseudo state transition function.
        TEST7__HISTORY1__OFF_InitialState_transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST7__HISTORY1__ON
}

static void TEST7__HISTORY1__ON_InitialState_transition(Spec2Sm* self)
{
    // TEST7__HISTORY1__ON.InitialState behavior
    // uml: / { trace("Transition action `` for TEST7__HISTORY1__ON.InitialState to TEST7__HISTORY1__ON.ShallowHistory."); } TransitionTo(TEST7__HISTORY1__ON.ShallowHistory)
    {
        // Step 1: Exit states until we reach `TEST7__HISTORY1__ON` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7__HISTORY1__ON.InitialState to TEST7__HISTORY1__ON.ShallowHistory.");`.
        trace("Transition action `` for TEST7__HISTORY1__ON.InitialState to TEST7__HISTORY1__ON.ShallowHistory.");
        
        // Step 3: Enter/move towards transition target `TEST7__HISTORY1__ON.ShallowHistory`.
        // TEST7__HISTORY1__ON.ShallowHistory is a pseudo state and cannot have an `enter` trigger.
        
        // TEST7__HISTORY1__ON.ShallowHistory behavior
        // uml: [ON_history_state_tracking_var_name___$$$$ == 0] / { trace("Transition action `` for TEST7__HISTORY1__ON.ShallowHistory to TEST7__HISTORY1__ON1."); } TransitionTo(TEST7__HISTORY1__ON1)
        if (self->vars.TEST7__HISTORY1__ON_history_tracking_var == 0)
        {
            // Step 1: Exit states until we reach `TEST7__HISTORY1__ON` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST7__HISTORY1__ON.ShallowHistory to TEST7__HISTORY1__ON1.");`.
            trace("Transition action `` for TEST7__HISTORY1__ON.ShallowHistory to TEST7__HISTORY1__ON1.");
            
            // Step 3: Enter/move towards transition target `TEST7__HISTORY1__ON1`.
            TEST7__HISTORY1__ON1_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_TEST7__HISTORY1__ON1;
            self->ancestor_event_handler = NULL;
            return;
        } // end of behavior for TEST7__HISTORY1__ON.ShallowHistory
        
        // TEST7__HISTORY1__ON.ShallowHistory behavior
        // uml: [ON_history_state_tracking_var_name___$$$$ == 1] / { trace("Transition action `` for TEST7__HISTORY1__ON.ShallowHistory to TEST7__HISTORY1__ON2."); } TransitionTo(TEST7__HISTORY1__ON2)
        if (self->vars.TEST7__HISTORY1__ON_history_tracking_var == 1)
        {
            // Step 1: Exit states until we reach `TEST7__HISTORY1__ON` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST7__HISTORY1__ON.ShallowHistory to TEST7__HISTORY1__ON2.");`.
            trace("Transition action `` for TEST7__HISTORY1__ON.ShallowHistory to TEST7__HISTORY1__ON2.");
            
            // Step 3: Enter/move towards transition target `TEST7__HISTORY1__ON2`.
            TEST7__HISTORY1__ON2_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_TEST7__HISTORY1__ON2;
            self->ancestor_event_handler = NULL;
            return;
        } // end of behavior for TEST7__HISTORY1__ON.ShallowHistory
        
        // TEST7__HISTORY1__ON.ShallowHistory behavior
        // uml: [ON_history_state_tracking_var_name___$$$$ == 2] / { trace("Transition action `` for TEST7__HISTORY1__ON.ShallowHistory to TEST7__HISTORY1__ON3."); } TransitionTo(TEST7__HISTORY1__ON3)
        if (self->vars.TEST7__HISTORY1__ON_history_tracking_var == 2)
        {
            // Step 1: Exit states until we reach `TEST7__HISTORY1__ON` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST7__HISTORY1__ON.ShallowHistory to TEST7__HISTORY1__ON3.");`.
            trace("Transition action `` for TEST7__HISTORY1__ON.ShallowHistory to TEST7__HISTORY1__ON3.");
            
            // Step 3: Enter/move towards transition target `TEST7__HISTORY1__ON3`.
            TEST7__HISTORY1__ON3_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_TEST7__HISTORY1__ON3;
            self->ancestor_event_handler = NULL;
            return;
        } // end of behavior for TEST7__HISTORY1__ON.ShallowHistory
    } // end of behavior for TEST7__HISTORY1__ON.InitialState
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7__HISTORY1__ON1
////////////////////////////////////////////////////////////////////////////////

static void TEST7__HISTORY1__ON1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7__HISTORY1__ON1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST7__HISTORY1__ON1_ev1;
    
    // TEST7__HISTORY1__ON1 behavior
    // uml: enter / { trace("Enter TEST7__HISTORY1__ON1."); }
    {
        // Step 1: execute action `trace("Enter TEST7__HISTORY1__ON1.");`
        trace("Enter TEST7__HISTORY1__ON1.");
    } // end of behavior for TEST7__HISTORY1__ON1
    
    // TEST7__HISTORY1__ON1 behavior
    // uml: enter [trace_guard("State TEST7__HISTORY1__ON1: check behavior `enter / { ON_history_state_tracking_var_name___$$$$ = 0; }`.", true)] / { ON_history_state_tracking_var_name___$$$$ = 0; }
    if (trace_guard("State TEST7__HISTORY1__ON1: check behavior `enter / { ON_history_state_tracking_var_name___$$$$ = 0; }`.", true))
    {
        // Step 1: execute action `ON_history_state_tracking_var_name___$$$$ = 0;`
        self->vars.TEST7__HISTORY1__ON_history_tracking_var = 0;
    } // end of behavior for TEST7__HISTORY1__ON1
}

static void TEST7__HISTORY1__ON1_exit(Spec2Sm* self)
{
    // TEST7__HISTORY1__ON1 behavior
    // uml: exit / { trace("Exit TEST7__HISTORY1__ON1."); }
    {
        // Step 1: execute action `trace("Exit TEST7__HISTORY1__ON1.");`
        trace("Exit TEST7__HISTORY1__ON1.");
    } // end of behavior for TEST7__HISTORY1__ON1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7__HISTORY1__ON_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST7__HISTORY1__ON1_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST7__HISTORY1__ON1 behavior
    // uml: EV1 [trace_guard("State TEST7__HISTORY1__ON1: check behavior `EV1 TransitionTo(TEST7__HISTORY1__ON2)`.", true)] / { trace("Transition action `` for TEST7__HISTORY1__ON1 to TEST7__HISTORY1__ON2."); } TransitionTo(TEST7__HISTORY1__ON2)
    if (trace_guard("State TEST7__HISTORY1__ON1: check behavior `EV1 TransitionTo(TEST7__HISTORY1__ON2)`.", true))
    {
        // Step 1: Exit states until we reach `TEST7__HISTORY1__ON` state (Least Common Ancestor for transition).
        TEST7__HISTORY1__ON1_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7__HISTORY1__ON1 to TEST7__HISTORY1__ON2.");`.
        trace("Transition action `` for TEST7__HISTORY1__ON1 to TEST7__HISTORY1__ON2.");
        
        // Step 3: Enter/move towards transition target `TEST7__HISTORY1__ON2`.
        TEST7__HISTORY1__ON2_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST7__HISTORY1__ON2;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST7__HISTORY1__ON1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7__HISTORY1__ON2
////////////////////////////////////////////////////////////////////////////////

static void TEST7__HISTORY1__ON2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7__HISTORY1__ON2_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST7__HISTORY1__ON2_ev1;
    
    // TEST7__HISTORY1__ON2 behavior
    // uml: enter / { trace("Enter TEST7__HISTORY1__ON2."); }
    {
        // Step 1: execute action `trace("Enter TEST7__HISTORY1__ON2.");`
        trace("Enter TEST7__HISTORY1__ON2.");
    } // end of behavior for TEST7__HISTORY1__ON2
    
    // TEST7__HISTORY1__ON2 behavior
    // uml: enter [trace_guard("State TEST7__HISTORY1__ON2: check behavior `enter / { ON_history_state_tracking_var_name___$$$$ = 1; }`.", true)] / { ON_history_state_tracking_var_name___$$$$ = 1; }
    if (trace_guard("State TEST7__HISTORY1__ON2: check behavior `enter / { ON_history_state_tracking_var_name___$$$$ = 1; }`.", true))
    {
        // Step 1: execute action `ON_history_state_tracking_var_name___$$$$ = 1;`
        self->vars.TEST7__HISTORY1__ON_history_tracking_var = 1;
    } // end of behavior for TEST7__HISTORY1__ON2
}

static void TEST7__HISTORY1__ON2_exit(Spec2Sm* self)
{
    // TEST7__HISTORY1__ON2 behavior
    // uml: exit / { trace("Exit TEST7__HISTORY1__ON2."); }
    {
        // Step 1: execute action `trace("Exit TEST7__HISTORY1__ON2.");`
        trace("Exit TEST7__HISTORY1__ON2.");
    } // end of behavior for TEST7__HISTORY1__ON2
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7__HISTORY1__ON_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST7__HISTORY1__ON2_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST7__HISTORY1__ON2 behavior
    // uml: EV1 [trace_guard("State TEST7__HISTORY1__ON2: check behavior `EV1 TransitionTo(TEST7__HISTORY1__ON3)`.", true)] / { trace("Transition action `` for TEST7__HISTORY1__ON2 to TEST7__HISTORY1__ON3."); } TransitionTo(TEST7__HISTORY1__ON3)
    if (trace_guard("State TEST7__HISTORY1__ON2: check behavior `EV1 TransitionTo(TEST7__HISTORY1__ON3)`.", true))
    {
        // Step 1: Exit states until we reach `TEST7__HISTORY1__ON` state (Least Common Ancestor for transition).
        TEST7__HISTORY1__ON2_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7__HISTORY1__ON2 to TEST7__HISTORY1__ON3.");`.
        trace("Transition action `` for TEST7__HISTORY1__ON2 to TEST7__HISTORY1__ON3.");
        
        // Step 3: Enter/move towards transition target `TEST7__HISTORY1__ON3`.
        TEST7__HISTORY1__ON3_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST7__HISTORY1__ON3;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST7__HISTORY1__ON2
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7__HISTORY1__ON3
////////////////////////////////////////////////////////////////////////////////

static void TEST7__HISTORY1__ON3_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7__HISTORY1__ON3_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST7__HISTORY1__ON3_ev1;
    
    // TEST7__HISTORY1__ON3 behavior
    // uml: enter / { trace("Enter TEST7__HISTORY1__ON3."); }
    {
        // Step 1: execute action `trace("Enter TEST7__HISTORY1__ON3.");`
        trace("Enter TEST7__HISTORY1__ON3.");
    } // end of behavior for TEST7__HISTORY1__ON3
    
    // TEST7__HISTORY1__ON3 behavior
    // uml: enter [trace_guard("State TEST7__HISTORY1__ON3: check behavior `enter / { ON_history_state_tracking_var_name___$$$$ = 2; }`.", true)] / { ON_history_state_tracking_var_name___$$$$ = 2; }
    if (trace_guard("State TEST7__HISTORY1__ON3: check behavior `enter / { ON_history_state_tracking_var_name___$$$$ = 2; }`.", true))
    {
        // Step 1: execute action `ON_history_state_tracking_var_name___$$$$ = 2;`
        self->vars.TEST7__HISTORY1__ON_history_tracking_var = 2;
    } // end of behavior for TEST7__HISTORY1__ON3
}

static void TEST7__HISTORY1__ON3_exit(Spec2Sm* self)
{
    // TEST7__HISTORY1__ON3 behavior
    // uml: exit / { trace("Exit TEST7__HISTORY1__ON3."); }
    {
        // Step 1: execute action `trace("Exit TEST7__HISTORY1__ON3.");`
        trace("Exit TEST7__HISTORY1__ON3.");
    } // end of behavior for TEST7__HISTORY1__ON3
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7__HISTORY1__ON_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST7__HISTORY1__ON3_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST7__HISTORY1__ON3 behavior
    // uml: EV1 [trace_guard("State TEST7__HISTORY1__ON3: check behavior `EV1 TransitionTo(TEST7__HISTORY1__ON1)`.", true)] / { trace("Transition action `` for TEST7__HISTORY1__ON3 to TEST7__HISTORY1__ON1."); } TransitionTo(TEST7__HISTORY1__ON1)
    if (trace_guard("State TEST7__HISTORY1__ON3: check behavior `EV1 TransitionTo(TEST7__HISTORY1__ON1)`.", true))
    {
        // Step 1: Exit states until we reach `TEST7__HISTORY1__ON` state (Least Common Ancestor for transition).
        TEST7__HISTORY1__ON3_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7__HISTORY1__ON3 to TEST7__HISTORY1__ON1.");`.
        trace("Transition action `` for TEST7__HISTORY1__ON3 to TEST7__HISTORY1__ON1.");
        
        // Step 3: Enter/move towards transition target `TEST7__HISTORY1__ON1`.
        TEST7__HISTORY1__ON1_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST7__HISTORY1__ON1;
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
        return;
    } // end of behavior for TEST7__HISTORY1__ON3
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7__HISTORY2
////////////////////////////////////////////////////////////////////////////////

static void TEST7__HISTORY2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7__HISTORY2_exit;
    
    // TEST7__HISTORY2 behavior
    // uml: enter / { trace("Enter TEST7__HISTORY2."); }
    {
        // Step 1: execute action `trace("Enter TEST7__HISTORY2.");`
        trace("Enter TEST7__HISTORY2.");
    } // end of behavior for TEST7__HISTORY2
}

static void TEST7__HISTORY2_exit(Spec2Sm* self)
{
    // TEST7__HISTORY2 behavior
    // uml: exit / { trace("Exit TEST7__HISTORY2."); }
    {
        // Step 1: execute action `trace("Exit TEST7__HISTORY2.");`
        trace("Exit TEST7__HISTORY2.");
    } // end of behavior for TEST7__HISTORY2
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7__HISTORY2__S1
////////////////////////////////////////////////////////////////////////////////

static void TEST7__HISTORY2__S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7__HISTORY2__S1_exit;
    
    // TEST7__HISTORY2__S1 behavior
    // uml: enter / { trace("Enter TEST7__HISTORY2__S1."); }
    {
        // Step 1: execute action `trace("Enter TEST7__HISTORY2__S1.");`
        trace("Enter TEST7__HISTORY2__S1.");
    } // end of behavior for TEST7__HISTORY2__S1
    
    // TEST7__HISTORY2__S1 behavior
    // uml: enter [trace_guard("State TEST7__HISTORY2__S1: check behavior `enter / { HISTORY2_history_state_tracking_var_name___$$$$ = 0; }`.", true)] / { HISTORY2_history_state_tracking_var_name___$$$$ = 0; }
    if (trace_guard("State TEST7__HISTORY2__S1: check behavior `enter / { HISTORY2_history_state_tracking_var_name___$$$$ = 0; }`.", true))
    {
        // Step 1: execute action `HISTORY2_history_state_tracking_var_name___$$$$ = 0;`
        self->vars.TEST7__HISTORY2_history_tracking_var = 0;
    } // end of behavior for TEST7__HISTORY2__S1
}

static void TEST7__HISTORY2__S1_exit(Spec2Sm* self)
{
    // TEST7__HISTORY2__S1 behavior
    // uml: exit / { trace("Exit TEST7__HISTORY2__S1."); }
    {
        // Step 1: execute action `trace("Exit TEST7__HISTORY2__S1.");`
        trace("Exit TEST7__HISTORY2__S1.");
    } // end of behavior for TEST7__HISTORY2__S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7__HISTORY2_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7__INITIAL1
////////////////////////////////////////////////////////////////////////////////

static void TEST7__INITIAL1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7__INITIAL1_exit;
    
    // TEST7__INITIAL1 behavior
    // uml: enter / { trace("Enter TEST7__INITIAL1."); }
    {
        // Step 1: execute action `trace("Enter TEST7__INITIAL1.");`
        trace("Enter TEST7__INITIAL1.");
    } // end of behavior for TEST7__INITIAL1
}

static void TEST7__INITIAL1_exit(Spec2Sm* self)
{
    // TEST7__INITIAL1 behavior
    // uml: exit / { trace("Exit TEST7__INITIAL1."); }
    {
        // Step 1: execute action `trace("Exit TEST7__INITIAL1.");`
        trace("Exit TEST7__INITIAL1.");
    } // end of behavior for TEST7__INITIAL1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7__INITIAL1__PARENT
////////////////////////////////////////////////////////////////////////////////

static void TEST7__INITIAL1__PARENT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7__INITIAL1__PARENT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV5] = TEST7__INITIAL1__PARENT_ev5;
    
    // TEST7__INITIAL1__PARENT behavior
    // uml: enter / { trace("Enter TEST7__INITIAL1__PARENT."); }
    {
        // Step 1: execute action `trace("Enter TEST7__INITIAL1__PARENT.");`
        trace("Enter TEST7__INITIAL1__PARENT.");
    } // end of behavior for TEST7__INITIAL1__PARENT
}

static void TEST7__INITIAL1__PARENT_exit(Spec2Sm* self)
{
    // TEST7__INITIAL1__PARENT behavior
    // uml: exit / { trace("Exit TEST7__INITIAL1__PARENT."); }
    {
        // Step 1: execute action `trace("Exit TEST7__INITIAL1__PARENT.");`
        trace("Exit TEST7__INITIAL1__PARENT.");
    } // end of behavior for TEST7__INITIAL1__PARENT
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7__INITIAL1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV5] = NULL;  // no ancestor listens to this event
}

static void TEST7__INITIAL1__PARENT_ev5(Spec2Sm* self)
{
    // No ancestor state handles `EV5` event.
    
    // TEST7__INITIAL1__PARENT behavior
    // uml: EV5 [trace_guard("State TEST7__INITIAL1__PARENT: check behavior `EV5 / { count++; }`.", true)] / { count++; }
    if (trace_guard("State TEST7__INITIAL1__PARENT: check behavior `EV5 / { count++; }`.", true))
    {
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        
        // Step 1: execute action `count++;`
        self->vars.count++;
        
        // Step 2: determine if ancestor gets to handle event next.
        // No ancestor handles event. Ignore `consume_event` flag.
    } // end of behavior for TEST7__INITIAL1__PARENT
}

static void TEST7__INITIAL1__PARENT_InitialState_transition(Spec2Sm* self)
{
    // TEST7__INITIAL1__PARENT.InitialState behavior
    // uml: / { trace("Transition action `` for TEST7__INITIAL1__PARENT.InitialState to TEST7__INITIAL1__S1."); } TransitionTo(TEST7__INITIAL1__S1)
    {
        // Step 1: Exit states until we reach `TEST7__INITIAL1__PARENT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7__INITIAL1__PARENT.InitialState to TEST7__INITIAL1__S1.");`.
        trace("Transition action `` for TEST7__INITIAL1__PARENT.InitialState to TEST7__INITIAL1__S1.");
        
        // Step 3: Enter/move towards transition target `TEST7__INITIAL1__S1`.
        TEST7__INITIAL1__S1_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST7__INITIAL1__S1;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for TEST7__INITIAL1__PARENT.InitialState
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7__INITIAL1__G
////////////////////////////////////////////////////////////////////////////////

static void TEST7__INITIAL1__G_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7__INITIAL1__G_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST7__INITIAL1__G_ev2;
    
    // TEST7__INITIAL1__G behavior
    // uml: enter / { trace("Enter TEST7__INITIAL1__G."); }
    {
        // Step 1: execute action `trace("Enter TEST7__INITIAL1__G.");`
        trace("Enter TEST7__INITIAL1__G.");
    } // end of behavior for TEST7__INITIAL1__G
}

static void TEST7__INITIAL1__G_exit(Spec2Sm* self)
{
    // TEST7__INITIAL1__G behavior
    // uml: exit / { trace("Exit TEST7__INITIAL1__G."); }
    {
        // Step 1: execute action `trace("Exit TEST7__INITIAL1__G.");`
        trace("Exit TEST7__INITIAL1__G.");
    } // end of behavior for TEST7__INITIAL1__G
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7__INITIAL1__PARENT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
}

static void TEST7__INITIAL1__G_ev2(Spec2Sm* self)
{
    // No ancestor state handles `EV2` event.
    
    // TEST7__INITIAL1__G behavior
    // uml: EV2 [trace_guard("State TEST7__INITIAL1__G: check behavior `EV2 TransitionTo(TEST7__INITIAL1__PARENT.InitialState)`.", true)] / { trace("Transition action `` for TEST7__INITIAL1__G to TEST7__INITIAL1__PARENT.InitialState."); } TransitionTo(TEST7__INITIAL1__PARENT.InitialState)
    if (trace_guard("State TEST7__INITIAL1__G: check behavior `EV2 TransitionTo(TEST7__INITIAL1__PARENT.InitialState)`.", true))
    {
        // Step 1: Exit states until we reach `TEST7__INITIAL1__PARENT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, TEST7__INITIAL1__PARENT_exit);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7__INITIAL1__G to TEST7__INITIAL1__PARENT.InitialState.");`.
        trace("Transition action `` for TEST7__INITIAL1__G to TEST7__INITIAL1__PARENT.InitialState.");
        
        // Step 3: Enter/move towards transition target `TEST7__INITIAL1__PARENT.InitialState`.
        // TEST7__INITIAL1__PARENT.InitialState is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        TEST7__INITIAL1__PARENT_InitialState_transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST7__INITIAL1__G
}

static void TEST7__INITIAL1__G_InitialState_transition(Spec2Sm* self)
{
    // TEST7__INITIAL1__G.InitialState behavior
    // uml: [count == 1] / { trace("Transition action `` for TEST7__INITIAL1__G.InitialState to TEST7__INITIAL1__G_S1."); } TransitionTo(TEST7__INITIAL1__G_S1)
    if (self->vars.count == 1)
    {
        // Step 1: Exit states until we reach `TEST7__INITIAL1__G` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7__INITIAL1__G.InitialState to TEST7__INITIAL1__G_S1.");`.
        trace("Transition action `` for TEST7__INITIAL1__G.InitialState to TEST7__INITIAL1__G_S1.");
        
        // Step 3: Enter/move towards transition target `TEST7__INITIAL1__G_S1`.
        TEST7__INITIAL1__G_S1_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST7__INITIAL1__G_S1;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for TEST7__INITIAL1__G.InitialState
    
    // TEST7__INITIAL1__G.InitialState behavior
    // uml: [count == 2] / { trace("Transition action `` for TEST7__INITIAL1__G.InitialState to TEST7__INITIAL1__G_S2."); } TransitionTo(TEST7__INITIAL1__G_S2)
    if (self->vars.count == 2)
    {
        // Step 1: Exit states until we reach `TEST7__INITIAL1__G` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7__INITIAL1__G.InitialState to TEST7__INITIAL1__G_S2.");`.
        trace("Transition action `` for TEST7__INITIAL1__G.InitialState to TEST7__INITIAL1__G_S2.");
        
        // Step 3: Enter/move towards transition target `TEST7__INITIAL1__G_S2`.
        TEST7__INITIAL1__G_S2_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST7__INITIAL1__G_S2;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for TEST7__INITIAL1__G.InitialState
    
    // TEST7__INITIAL1__G.InitialState behavior
    // uml: else / { trace("Transition action `` for TEST7__INITIAL1__G.InitialState to TEST7__INITIAL1__G_S3."); } TransitionTo(TEST7__INITIAL1__G_S3)
    {
        // Step 1: Exit states until we reach `TEST7__INITIAL1__G` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7__INITIAL1__G.InitialState to TEST7__INITIAL1__G_S3.");`.
        trace("Transition action `` for TEST7__INITIAL1__G.InitialState to TEST7__INITIAL1__G_S3.");
        
        // Step 3: Enter/move towards transition target `TEST7__INITIAL1__G_S3`.
        TEST7__INITIAL1__G_S3_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST7__INITIAL1__G_S3;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for TEST7__INITIAL1__G.InitialState
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7__INITIAL1__G_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST7__INITIAL1__G_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7__INITIAL1__G_S1_exit;
    
    // TEST7__INITIAL1__G_S1 behavior
    // uml: enter / { trace("Enter TEST7__INITIAL1__G_S1."); }
    {
        // Step 1: execute action `trace("Enter TEST7__INITIAL1__G_S1.");`
        trace("Enter TEST7__INITIAL1__G_S1.");
    } // end of behavior for TEST7__INITIAL1__G_S1
}

static void TEST7__INITIAL1__G_S1_exit(Spec2Sm* self)
{
    // TEST7__INITIAL1__G_S1 behavior
    // uml: exit / { trace("Exit TEST7__INITIAL1__G_S1."); }
    {
        // Step 1: execute action `trace("Exit TEST7__INITIAL1__G_S1.");`
        trace("Exit TEST7__INITIAL1__G_S1.");
    } // end of behavior for TEST7__INITIAL1__G_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7__INITIAL1__G_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7__INITIAL1__G_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST7__INITIAL1__G_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7__INITIAL1__G_S2_exit;
    
    // TEST7__INITIAL1__G_S2 behavior
    // uml: enter / { trace("Enter TEST7__INITIAL1__G_S2."); }
    {
        // Step 1: execute action `trace("Enter TEST7__INITIAL1__G_S2.");`
        trace("Enter TEST7__INITIAL1__G_S2.");
    } // end of behavior for TEST7__INITIAL1__G_S2
}

static void TEST7__INITIAL1__G_S2_exit(Spec2Sm* self)
{
    // TEST7__INITIAL1__G_S2 behavior
    // uml: exit / { trace("Exit TEST7__INITIAL1__G_S2."); }
    {
        // Step 1: execute action `trace("Exit TEST7__INITIAL1__G_S2.");`
        trace("Exit TEST7__INITIAL1__G_S2.");
    } // end of behavior for TEST7__INITIAL1__G_S2
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7__INITIAL1__G_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7__INITIAL1__G_S3
////////////////////////////////////////////////////////////////////////////////

static void TEST7__INITIAL1__G_S3_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7__INITIAL1__G_S3_exit;
    
    // TEST7__INITIAL1__G_S3 behavior
    // uml: enter / { trace("Enter TEST7__INITIAL1__G_S3."); }
    {
        // Step 1: execute action `trace("Enter TEST7__INITIAL1__G_S3.");`
        trace("Enter TEST7__INITIAL1__G_S3.");
    } // end of behavior for TEST7__INITIAL1__G_S3
}

static void TEST7__INITIAL1__G_S3_exit(Spec2Sm* self)
{
    // TEST7__INITIAL1__G_S3 behavior
    // uml: exit / { trace("Exit TEST7__INITIAL1__G_S3."); }
    {
        // Step 1: execute action `trace("Exit TEST7__INITIAL1__G_S3.");`
        trace("Exit TEST7__INITIAL1__G_S3.");
    } // end of behavior for TEST7__INITIAL1__G_S3
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7__INITIAL1__G_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7__INITIAL1__S1
////////////////////////////////////////////////////////////////////////////////

static void TEST7__INITIAL1__S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7__INITIAL1__S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST7__INITIAL1__S1_ev1;
    self->current_event_handlers[Spec2Sm_EventId_EV3] = TEST7__INITIAL1__S1_ev3;
    
    // TEST7__INITIAL1__S1 behavior
    // uml: enter / { trace("Enter TEST7__INITIAL1__S1."); }
    {
        // Step 1: execute action `trace("Enter TEST7__INITIAL1__S1.");`
        trace("Enter TEST7__INITIAL1__S1.");
    } // end of behavior for TEST7__INITIAL1__S1
}

static void TEST7__INITIAL1__S1_exit(Spec2Sm* self)
{
    // TEST7__INITIAL1__S1 behavior
    // uml: exit / { trace("Exit TEST7__INITIAL1__S1."); }
    {
        // Step 1: execute action `trace("Exit TEST7__INITIAL1__S1.");`
        trace("Exit TEST7__INITIAL1__S1.");
    } // end of behavior for TEST7__INITIAL1__S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7__INITIAL1__PARENT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV3] = NULL;  // no ancestor listens to this event
}

static void TEST7__INITIAL1__S1_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST7__INITIAL1__S1 behavior
    // uml: EV1 [trace_guard("State TEST7__INITIAL1__S1: check behavior `EV1 TransitionTo(TEST7__INITIAL1__G)`.", true)] / { trace("Transition action `` for TEST7__INITIAL1__S1 to TEST7__INITIAL1__G."); } TransitionTo(TEST7__INITIAL1__G)
    if (trace_guard("State TEST7__INITIAL1__S1: check behavior `EV1 TransitionTo(TEST7__INITIAL1__G)`.", true))
    {
        // Step 1: Exit states until we reach `TEST7__INITIAL1__PARENT` state (Least Common Ancestor for transition).
        TEST7__INITIAL1__S1_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7__INITIAL1__S1 to TEST7__INITIAL1__G.");`.
        trace("Transition action `` for TEST7__INITIAL1__S1 to TEST7__INITIAL1__G.");
        
        // Step 3: Enter/move towards transition target `TEST7__INITIAL1__G`.
        TEST7__INITIAL1__G_enter(self);
        
        // Finish transition by calling pseudo state transition function.
        TEST7__INITIAL1__G_InitialState_transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST7__INITIAL1__S1
}

static void TEST7__INITIAL1__S1_ev3(Spec2Sm* self)
{
    // No ancestor state handles `EV3` event.
    
    // TEST7__INITIAL1__S1 behavior
    // uml: EV3 [trace_guard("State TEST7__INITIAL1__S1: check behavior `EV3 TransitionTo(TEST7__INITIAL1__G.InitialState)`.", true)] / { trace("Transition action `` for TEST7__INITIAL1__S1 to TEST7__INITIAL1__G.InitialState."); } TransitionTo(TEST7__INITIAL1__G.InitialState)
    if (trace_guard("State TEST7__INITIAL1__S1: check behavior `EV3 TransitionTo(TEST7__INITIAL1__G.InitialState)`.", true))
    {
        // Step 1: Exit states until we reach `TEST7__INITIAL1__PARENT` state (Least Common Ancestor for transition).
        TEST7__INITIAL1__S1_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7__INITIAL1__S1 to TEST7__INITIAL1__G.InitialState.");`.
        trace("Transition action `` for TEST7__INITIAL1__S1 to TEST7__INITIAL1__G.InitialState.");
        
        // Step 3: Enter/move towards transition target `TEST7__INITIAL1__G.InitialState`.
        TEST7__INITIAL1__G_enter(self);
        // TEST7__INITIAL1__G.InitialState is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        TEST7__INITIAL1__G_InitialState_transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST7__INITIAL1__S1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST7_DECIDE
////////////////////////////////////////////////////////////////////////////////

static void TEST7_DECIDE_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST7_DECIDE_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST7_DECIDE_ev1;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST7_DECIDE_ev2;
    self->current_event_handlers[Spec2Sm_EventId_EV3] = TEST7_DECIDE_ev3;
    
    // TEST7_DECIDE behavior
    // uml: enter / { trace("Enter TEST7_DECIDE."); }
    {
        // Step 1: execute action `trace("Enter TEST7_DECIDE.");`
        trace("Enter TEST7_DECIDE.");
    } // end of behavior for TEST7_DECIDE
}

static void TEST7_DECIDE_exit(Spec2Sm* self)
{
    // TEST7_DECIDE behavior
    // uml: exit / { trace("Exit TEST7_DECIDE."); }
    {
        // Step 1: execute action `trace("Exit TEST7_DECIDE.");`
        trace("Exit TEST7_DECIDE.");
    } // end of behavior for TEST7_DECIDE
    
    // TEST7_DECIDE behavior
    // uml: exit [trace_guard("State TEST7_DECIDE: check behavior `exit / { clear_dispatch_output(); }`.", true)] / { clear_dispatch_output(); }
    if (trace_guard("State TEST7_DECIDE: check behavior `exit / { clear_dispatch_output(); }`.", true))
    {
        // Step 1: execute action `clear_dispatch_output();`
        trace("CLEAR_OUTPUT_BEFORE_THIS_AND_FOR_THIS_EVENT_DISPATCH");;
    } // end of behavior for TEST7_DECIDE
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST7_INITIAL_OR_HISTORY_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV3] = NULL;  // no ancestor listens to this event
}

static void TEST7_DECIDE_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST7_DECIDE behavior
    // uml: EV1 [trace_guard("State TEST7_DECIDE: check behavior `EV1 TransitionTo(TEST7__INITIAL1)`.", true)] / { trace("Transition action `` for TEST7_DECIDE to TEST7__INITIAL1."); } TransitionTo(TEST7__INITIAL1)
    if (trace_guard("State TEST7_DECIDE: check behavior `EV1 TransitionTo(TEST7__INITIAL1)`.", true))
    {
        // Step 1: Exit states until we reach `TEST7_INITIAL_OR_HISTORY` state (Least Common Ancestor for transition).
        TEST7_DECIDE_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7_DECIDE to TEST7__INITIAL1.");`.
        trace("Transition action `` for TEST7_DECIDE to TEST7__INITIAL1.");
        
        // Step 3: Enter/move towards transition target `TEST7__INITIAL1`.
        TEST7_enter(self);
        TEST7__INITIAL1_enter(self);
        
        // TEST7__INITIAL1.InitialState behavior
        // uml: / { trace("Transition action `` for TEST7__INITIAL1.InitialState to TEST7__INITIAL1__PARENT."); } TransitionTo(TEST7__INITIAL1__PARENT)
        {
            // Step 1: Exit states until we reach `TEST7__INITIAL1` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST7__INITIAL1.InitialState to TEST7__INITIAL1__PARENT.");`.
            trace("Transition action `` for TEST7__INITIAL1.InitialState to TEST7__INITIAL1__PARENT.");
            
            // Step 3: Enter/move towards transition target `TEST7__INITIAL1__PARENT`.
            TEST7__INITIAL1__PARENT_enter(self);
            
            // Finish transition by calling pseudo state transition function.
            TEST7__INITIAL1__PARENT_InitialState_transition(self);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for TEST7__INITIAL1.InitialState
    } // end of behavior for TEST7_DECIDE
}

static void TEST7_DECIDE_ev2(Spec2Sm* self)
{
    // No ancestor state handles `EV2` event.
    
    // TEST7_DECIDE behavior
    // uml: EV2 [trace_guard("State TEST7_DECIDE: check behavior `EV2 TransitionTo(TEST7__HISTORY1)`.", true)] / { trace("Transition action `` for TEST7_DECIDE to TEST7__HISTORY1."); } TransitionTo(TEST7__HISTORY1)
    if (trace_guard("State TEST7_DECIDE: check behavior `EV2 TransitionTo(TEST7__HISTORY1)`.", true))
    {
        // Step 1: Exit states until we reach `TEST7_INITIAL_OR_HISTORY` state (Least Common Ancestor for transition).
        TEST7_DECIDE_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7_DECIDE to TEST7__HISTORY1.");`.
        trace("Transition action `` for TEST7_DECIDE to TEST7__HISTORY1.");
        
        // Step 3: Enter/move towards transition target `TEST7__HISTORY1`.
        TEST7_enter(self);
        TEST7__HISTORY1_enter(self);
        
        // TEST7__HISTORY1.InitialState behavior
        // uml: / { trace("Transition action `` for TEST7__HISTORY1.InitialState to TEST7__HISTORY1__ON."); } TransitionTo(TEST7__HISTORY1__ON)
        {
            // Step 1: Exit states until we reach `TEST7__HISTORY1` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST7__HISTORY1.InitialState to TEST7__HISTORY1__ON.");`.
            trace("Transition action `` for TEST7__HISTORY1.InitialState to TEST7__HISTORY1__ON.");
            
            // Step 3: Enter/move towards transition target `TEST7__HISTORY1__ON`.
            TEST7__HISTORY1__ON_enter(self);
            
            // Finish transition by calling pseudo state transition function.
            TEST7__HISTORY1__ON_InitialState_transition(self);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for TEST7__HISTORY1.InitialState
    } // end of behavior for TEST7_DECIDE
}

static void TEST7_DECIDE_ev3(Spec2Sm* self)
{
    // No ancestor state handles `EV3` event.
    
    // TEST7_DECIDE behavior
    // uml: EV3 [trace_guard("State TEST7_DECIDE: check behavior `EV3 TransitionTo(TEST7__HISTORY2)`.", true)] / { trace("Transition action `` for TEST7_DECIDE to TEST7__HISTORY2."); } TransitionTo(TEST7__HISTORY2)
    if (trace_guard("State TEST7_DECIDE: check behavior `EV3 TransitionTo(TEST7__HISTORY2)`.", true))
    {
        // Step 1: Exit states until we reach `TEST7_INITIAL_OR_HISTORY` state (Least Common Ancestor for transition).
        TEST7_DECIDE_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST7_DECIDE to TEST7__HISTORY2.");`.
        trace("Transition action `` for TEST7_DECIDE to TEST7__HISTORY2.");
        
        // Step 3: Enter/move towards transition target `TEST7__HISTORY2`.
        TEST7_enter(self);
        TEST7__HISTORY2_enter(self);
        
        // TEST7__HISTORY2.InitialState behavior
        // uml: / { trace("Transition action `` for TEST7__HISTORY2.InitialState to TEST7__HISTORY2__S1."); } TransitionTo(TEST7__HISTORY2__S1)
        {
            // Step 1: Exit states until we reach `TEST7__HISTORY2` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST7__HISTORY2.InitialState to TEST7__HISTORY2__S1.");`.
            trace("Transition action `` for TEST7__HISTORY2.InitialState to TEST7__HISTORY2__S1.");
            
            // Step 3: Enter/move towards transition target `TEST7__HISTORY2__S1`.
            TEST7__HISTORY2__S1_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_TEST7__HISTORY2__S1;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for TEST7__HISTORY2.InitialState
        
        // TEST7__HISTORY2.InitialState behavior
        // uml: / { trace("Transition action `` for TEST7__HISTORY2.InitialState to TEST7__HISTORY2.ShallowHistory."); } TransitionTo(TEST7__HISTORY2.ShallowHistory)
        {
            // Step 1: Exit states until we reach `TEST7__HISTORY2` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST7__HISTORY2.InitialState to TEST7__HISTORY2.ShallowHistory.");`.
            trace("Transition action `` for TEST7__HISTORY2.InitialState to TEST7__HISTORY2.ShallowHistory.");
            
            // Step 3: Enter/move towards transition target `TEST7__HISTORY2.ShallowHistory`.
            // TEST7__HISTORY2.ShallowHistory is a pseudo state and cannot have an `enter` trigger.
            
            // TEST7__HISTORY2.ShallowHistory behavior
            // uml: [HISTORY2_history_state_tracking_var_name___$$$$ == 0] / { trace("Transition action `` for TEST7__HISTORY2.ShallowHistory to TEST7__HISTORY2__S1."); } TransitionTo(TEST7__HISTORY2__S1)
            if (self->vars.TEST7__HISTORY2_history_tracking_var == 0)
            {
                // Step 1: Exit states until we reach `TEST7__HISTORY2` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `trace("Transition action `` for TEST7__HISTORY2.ShallowHistory to TEST7__HISTORY2__S1.");`.
                trace("Transition action `` for TEST7__HISTORY2.ShallowHistory to TEST7__HISTORY2__S1.");
                
                // Step 3: Enter/move towards transition target `TEST7__HISTORY2__S1`.
                TEST7__HISTORY2__S1_enter(self);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                self->state_id = Spec2Sm_StateId_TEST7__HISTORY2__S1;
                // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
                return;
            } // end of behavior for TEST7__HISTORY2.ShallowHistory
        } // end of behavior for TEST7__HISTORY2.InitialState
    } // end of behavior for TEST7_DECIDE
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST8_ENTRY_CHOICE
////////////////////////////////////////////////////////////////////////////////

static void TEST8_ENTRY_CHOICE_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST8_ENTRY_CHOICE_exit;
    
    // TEST8_ENTRY_CHOICE behavior
    // uml: enter / { trace("Enter TEST8_ENTRY_CHOICE."); }
    {
        // Step 1: execute action `trace("Enter TEST8_ENTRY_CHOICE.");`
        trace("Enter TEST8_ENTRY_CHOICE.");
    } // end of behavior for TEST8_ENTRY_CHOICE
}

static void TEST8_ENTRY_CHOICE_exit(Spec2Sm* self)
{
    // TEST8_ENTRY_CHOICE behavior
    // uml: exit / { trace("Exit TEST8_ENTRY_CHOICE."); }
    {
        // Step 1: execute action `trace("Exit TEST8_ENTRY_CHOICE.");`
        trace("Exit TEST8_ENTRY_CHOICE.");
    } // end of behavior for TEST8_ENTRY_CHOICE
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST8_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST8_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST8_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV3] = TEST8_ROOT_ev3;
    self->current_event_handlers[Spec2Sm_EventId_EV5] = TEST8_ROOT_ev5;
    
    // TEST8_ROOT behavior
    // uml: enter / { trace("Enter TEST8_ROOT."); }
    {
        // Step 1: execute action `trace("Enter TEST8_ROOT.");`
        trace("Enter TEST8_ROOT.");
    } // end of behavior for TEST8_ROOT
    
    // TEST8_ROOT behavior
    // uml: enter [trace_guard("State TEST8_ROOT: check behavior `enter / { clear_dispatch_output(); }`.", true)] / { clear_dispatch_output(); }
    if (trace_guard("State TEST8_ROOT: check behavior `enter / { clear_dispatch_output(); }`.", true))
    {
        // Step 1: execute action `clear_dispatch_output();`
        trace("CLEAR_OUTPUT_BEFORE_THIS_AND_FOR_THIS_EVENT_DISPATCH");;
    } // end of behavior for TEST8_ROOT
}

static void TEST8_ROOT_exit(Spec2Sm* self)
{
    // TEST8_ROOT behavior
    // uml: exit / { trace("Exit TEST8_ROOT."); }
    {
        // Step 1: execute action `trace("Exit TEST8_ROOT.");`
        trace("Exit TEST8_ROOT.");
    } // end of behavior for TEST8_ROOT
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST8_ENTRY_CHOICE_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV3] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV5] = NULL;  // no ancestor listens to this event
}

static void TEST8_ROOT_ev3(Spec2Sm* self)
{
    // No ancestor state handles `EV3` event.
    
    // TEST8_ROOT behavior
    // uml: EV3 [trace_guard("State TEST8_ROOT: check behavior `EV3`.", true)]
    if (trace_guard("State TEST8_ROOT: check behavior `EV3`.", true))
    {
        // Step 1: execute action ``
        // Step 2: determine if ancestor gets to handle event next.
        // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
    } // end of behavior for TEST8_ROOT
}

static void TEST8_ROOT_ev5(Spec2Sm* self)
{
    // No ancestor state handles `EV5` event.
    
    // TEST8_ROOT behavior
    // uml: EV5 [trace_guard("State TEST8_ROOT: check behavior `EV5 / { count++; }`.", true)] / { count++; }
    if (trace_guard("State TEST8_ROOT: check behavior `EV5 / { count++; }`.", true))
    {
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        
        // Step 1: execute action `count++;`
        self->vars.count++;
        
        // Step 2: determine if ancestor gets to handle event next.
        // No ancestor handles event. Ignore `consume_event` flag.
    } // end of behavior for TEST8_ROOT
}

static void TEST8_ROOT_EntryPoint_1__transition(Spec2Sm* self)
{
    // TEST8_ROOT.EntryPoint(1) behavior
    // uml: / { trace("Transition action `` for TEST8_ROOT.EntryPoint(1) to TEST8_S1."); } TransitionTo(TEST8_S1)
    {
        // Step 1: Exit states until we reach `TEST8_ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST8_ROOT.EntryPoint(1) to TEST8_S1.");`.
        trace("Transition action `` for TEST8_ROOT.EntryPoint(1) to TEST8_S1.");
        
        // Step 3: Enter/move towards transition target `TEST8_S1`.
        TEST8_S1_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST8_S1;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for TEST8_ROOT.EntryPoint(1)
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST8_G
////////////////////////////////////////////////////////////////////////////////

static void TEST8_G_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST8_G_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST8_G_ev2;
    
    // TEST8_G behavior
    // uml: enter / { trace("Enter TEST8_G."); }
    {
        // Step 1: execute action `trace("Enter TEST8_G.");`
        trace("Enter TEST8_G.");
    } // end of behavior for TEST8_G
}

static void TEST8_G_exit(Spec2Sm* self)
{
    // TEST8_G behavior
    // uml: exit / { trace("Exit TEST8_G."); }
    {
        // Step 1: execute action `trace("Exit TEST8_G.");`
        trace("Exit TEST8_G.");
    } // end of behavior for TEST8_G
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST8_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
}

static void TEST8_G_ev2(Spec2Sm* self)
{
    // No ancestor state handles `EV2` event.
    
    // TEST8_G behavior
    // uml: EV2 [trace_guard("State TEST8_G: check behavior `EV2 TransitionTo(TEST8_ROOT.EntryPoint(1))`.", true)] / { trace("Transition action `` for TEST8_G to TEST8_ROOT.EntryPoint(1)."); } TransitionTo(TEST8_ROOT.EntryPoint(1))
    if (trace_guard("State TEST8_G: check behavior `EV2 TransitionTo(TEST8_ROOT.EntryPoint(1))`.", true))
    {
        // Step 1: Exit states until we reach `TEST8_ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(self, TEST8_ROOT_exit);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST8_G to TEST8_ROOT.EntryPoint(1).");`.
        trace("Transition action `` for TEST8_G to TEST8_ROOT.EntryPoint(1).");
        
        // Step 3: Enter/move towards transition target `TEST8_ROOT.EntryPoint(1)`.
        // TEST8_ROOT.EntryPoint(1) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        TEST8_ROOT_EntryPoint_1__transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST8_G
}

static void TEST8_G_EntryPoint_1__transition(Spec2Sm* self)
{
    // TEST8_G.EntryPoint(1) behavior
    // uml: [count == 1] / { trace("Transition action `` for TEST8_G.EntryPoint(1) to TEST8_G_S1."); } TransitionTo(TEST8_G_S1)
    if (self->vars.count == 1)
    {
        // Step 1: Exit states until we reach `TEST8_G` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST8_G.EntryPoint(1) to TEST8_G_S1.");`.
        trace("Transition action `` for TEST8_G.EntryPoint(1) to TEST8_G_S1.");
        
        // Step 3: Enter/move towards transition target `TEST8_G_S1`.
        TEST8_G_S1_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST8_G_S1;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for TEST8_G.EntryPoint(1)
    
    // TEST8_G.EntryPoint(1) behavior
    // uml: [count == 2] / { trace("Transition action `` for TEST8_G.EntryPoint(1) to TEST8_G_S2."); } TransitionTo(TEST8_G_S2)
    if (self->vars.count == 2)
    {
        // Step 1: Exit states until we reach `TEST8_G` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST8_G.EntryPoint(1) to TEST8_G_S2.");`.
        trace("Transition action `` for TEST8_G.EntryPoint(1) to TEST8_G_S2.");
        
        // Step 3: Enter/move towards transition target `TEST8_G_S2`.
        TEST8_G_S2_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST8_G_S2;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for TEST8_G.EntryPoint(1)
    
    // TEST8_G.EntryPoint(1) behavior
    // uml: else / { trace("Transition action `` for TEST8_G.EntryPoint(1) to TEST8_G_S3."); } TransitionTo(TEST8_G_S3)
    {
        // Step 1: Exit states until we reach `TEST8_G` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST8_G.EntryPoint(1) to TEST8_G_S3.");`.
        trace("Transition action `` for TEST8_G.EntryPoint(1) to TEST8_G_S3.");
        
        // Step 3: Enter/move towards transition target `TEST8_G_S3`.
        TEST8_G_S3_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST8_G_S3;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for TEST8_G.EntryPoint(1)
}

static void TEST8_G_EntryPoint_3__transition(Spec2Sm* self)
{
    // TEST8_G.EntryPoint(3) behavior
    // uml: / { trace("Transition action `count += 0;` for TEST8_G.EntryPoint(3) to TEST8_G.EntryPoint(1).");\ncount += 0; } TransitionTo(TEST8_G.EntryPoint(1))
    {
        // Step 1: Exit states until we reach `TEST8_G` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `count += 0;` for TEST8_G.EntryPoint(3) to TEST8_G.EntryPoint(1).");\ncount += 0;`.
        trace("Transition action `count += 0;` for TEST8_G.EntryPoint(3) to TEST8_G.EntryPoint(1).");
        self->vars.count += 0;
        
        // Step 3: Enter/move towards transition target `TEST8_G.EntryPoint(1)`.
        // TEST8_G.EntryPoint(1) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        TEST8_G_EntryPoint_1__transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST8_G.EntryPoint(3)
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST8_G_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST8_G_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST8_G_S1_exit;
    
    // TEST8_G_S1 behavior
    // uml: enter / { trace("Enter TEST8_G_S1."); }
    {
        // Step 1: execute action `trace("Enter TEST8_G_S1.");`
        trace("Enter TEST8_G_S1.");
    } // end of behavior for TEST8_G_S1
}

static void TEST8_G_S1_exit(Spec2Sm* self)
{
    // TEST8_G_S1 behavior
    // uml: exit / { trace("Exit TEST8_G_S1."); }
    {
        // Step 1: execute action `trace("Exit TEST8_G_S1.");`
        trace("Exit TEST8_G_S1.");
    } // end of behavior for TEST8_G_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST8_G_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST8_G_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST8_G_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST8_G_S2_exit;
    
    // TEST8_G_S2 behavior
    // uml: enter / { trace("Enter TEST8_G_S2."); }
    {
        // Step 1: execute action `trace("Enter TEST8_G_S2.");`
        trace("Enter TEST8_G_S2.");
    } // end of behavior for TEST8_G_S2
}

static void TEST8_G_S2_exit(Spec2Sm* self)
{
    // TEST8_G_S2 behavior
    // uml: exit / { trace("Exit TEST8_G_S2."); }
    {
        // Step 1: execute action `trace("Exit TEST8_G_S2.");`
        trace("Exit TEST8_G_S2.");
    } // end of behavior for TEST8_G_S2
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST8_G_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST8_G_S3
////////////////////////////////////////////////////////////////////////////////

static void TEST8_G_S3_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST8_G_S3_exit;
    
    // TEST8_G_S3 behavior
    // uml: enter / { trace("Enter TEST8_G_S3."); }
    {
        // Step 1: execute action `trace("Enter TEST8_G_S3.");`
        trace("Enter TEST8_G_S3.");
    } // end of behavior for TEST8_G_S3
}

static void TEST8_G_S3_exit(Spec2Sm* self)
{
    // TEST8_G_S3 behavior
    // uml: exit / { trace("Exit TEST8_G_S3."); }
    {
        // Step 1: execute action `trace("Exit TEST8_G_S3.");`
        trace("Exit TEST8_G_S3.");
    } // end of behavior for TEST8_G_S3
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST8_G_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST8_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST8_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST8_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST8_S1_ev1;
    self->current_event_handlers[Spec2Sm_EventId_EV3] = TEST8_S1_ev3;
    self->current_event_handlers[Spec2Sm_EventId_EV6] = TEST8_S1_ev6;
    
    // TEST8_S1 behavior
    // uml: enter / { trace("Enter TEST8_S1."); }
    {
        // Step 1: execute action `trace("Enter TEST8_S1.");`
        trace("Enter TEST8_S1.");
    } // end of behavior for TEST8_S1
}

static void TEST8_S1_exit(Spec2Sm* self)
{
    // TEST8_S1 behavior
    // uml: exit / { trace("Exit TEST8_S1."); }
    {
        // Step 1: execute action `trace("Exit TEST8_S1.");`
        trace("Exit TEST8_S1.");
    } // end of behavior for TEST8_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST8_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV3] = TEST8_ROOT_ev3;  // the next ancestor that handles this event is TEST8_ROOT
    self->current_event_handlers[Spec2Sm_EventId_EV6] = NULL;  // no ancestor listens to this event
}

static void TEST8_S1_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST8_S1 behavior
    // uml: 1. EV1 [trace_guard("State TEST8_S1: check behavior `1. EV1 TransitionTo(TEST8_G.EntryPoint(1))`.", true)] / { trace("Transition action `` for TEST8_S1 to TEST8_G.EntryPoint(1)."); } TransitionTo(TEST8_G.EntryPoint(1))
    if (trace_guard("State TEST8_S1: check behavior `1. EV1 TransitionTo(TEST8_G.EntryPoint(1))`.", true))
    {
        // Step 1: Exit states until we reach `TEST8_ROOT` state (Least Common Ancestor for transition).
        TEST8_S1_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST8_S1 to TEST8_G.EntryPoint(1).");`.
        trace("Transition action `` for TEST8_S1 to TEST8_G.EntryPoint(1).");
        
        // Step 3: Enter/move towards transition target `TEST8_G.EntryPoint(1)`.
        TEST8_G_enter(self);
        // TEST8_G.EntryPoint(1) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        TEST8_G_EntryPoint_1__transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST8_S1
    
    // TEST8_S1 behavior
    // uml: 2. EV1 [trace_guard("State TEST8_S1: check behavior `2. EV1 / { count++; /* shouldn't run */ }`.", true)] / { count++; /* shouldn't run */ }
    if (trace_guard("State TEST8_S1: check behavior `2. EV1 / { count++; /* shouldn't run */ }`.", true))
    {
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        
        // Step 1: execute action `count++; /* shouldn't run */`
        self->vars.count++; /* shouldn't run */
        
        // Step 2: determine if ancestor gets to handle event next.
        // No ancestor handles event. Ignore `consume_event` flag.
    } // end of behavior for TEST8_S1
}

static void TEST8_S1_ev3(Spec2Sm* self)
{
    // Setup handler for next ancestor that listens to `EV3` event.
    self->ancestor_event_handler = TEST8_ROOT_ev3;
    
    // TEST8_S1 behavior
    // uml: EV3 [trace_guard("State TEST8_S1: check behavior `EV3 TransitionTo(TEST8_G.EntryPoint(3))`.", true)] / { trace("Transition action `` for TEST8_S1 to TEST8_G.EntryPoint(3)."); } TransitionTo(TEST8_G.EntryPoint(3))
    if (trace_guard("State TEST8_S1: check behavior `EV3 TransitionTo(TEST8_G.EntryPoint(3))`.", true))
    {
        // Step 1: Exit states until we reach `TEST8_ROOT` state (Least Common Ancestor for transition).
        TEST8_S1_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST8_S1 to TEST8_G.EntryPoint(3).");`.
        trace("Transition action `` for TEST8_S1 to TEST8_G.EntryPoint(3).");
        
        // Step 3: Enter/move towards transition target `TEST8_G.EntryPoint(3)`.
        TEST8_G_enter(self);
        // TEST8_G.EntryPoint(3) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        TEST8_G_EntryPoint_3__transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST8_S1
}

static void TEST8_S1_ev6(Spec2Sm* self)
{
    // No ancestor state handles `EV6` event.
    
    // TEST8_S1 behavior
    // uml: EV6 [trace_guard("State TEST8_S1: check behavior `EV6 TransitionTo(TEST8_G.EntryPoint(3))`.", true)] / { trace("Transition action `` for TEST8_S1 to TEST8_G.EntryPoint(3)."); } TransitionTo(TEST8_G.EntryPoint(3))
    if (trace_guard("State TEST8_S1: check behavior `EV6 TransitionTo(TEST8_G.EntryPoint(3))`.", true))
    {
        // Step 1: Exit states until we reach `TEST8_ROOT` state (Least Common Ancestor for transition).
        TEST8_S1_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST8_S1 to TEST8_G.EntryPoint(3).");`.
        trace("Transition action `` for TEST8_S1 to TEST8_G.EntryPoint(3).");
        
        // Step 3: Enter/move towards transition target `TEST8_G.EntryPoint(3)`.
        TEST8_G_enter(self);
        // TEST8_G.EntryPoint(3) is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        TEST8_G_EntryPoint_3__transition(self);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for TEST8_S1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST9_EXIT_CHOICE
////////////////////////////////////////////////////////////////////////////////

static void TEST9_EXIT_CHOICE_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST9_EXIT_CHOICE_exit;
    
    // TEST9_EXIT_CHOICE behavior
    // uml: enter / { trace("Enter TEST9_EXIT_CHOICE."); }
    {
        // Step 1: execute action `trace("Enter TEST9_EXIT_CHOICE.");`
        trace("Enter TEST9_EXIT_CHOICE.");
    } // end of behavior for TEST9_EXIT_CHOICE
}

static void TEST9_EXIT_CHOICE_exit(Spec2Sm* self)
{
    // TEST9_EXIT_CHOICE behavior
    // uml: exit / { trace("Exit TEST9_EXIT_CHOICE."); }
    {
        // Step 1: execute action `trace("Exit TEST9_EXIT_CHOICE.");`
        trace("Exit TEST9_EXIT_CHOICE.");
    } // end of behavior for TEST9_EXIT_CHOICE
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST9_DECIDE
////////////////////////////////////////////////////////////////////////////////

static void TEST9_DECIDE_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST9_DECIDE_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST9_DECIDE_ev1;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST9_DECIDE_ev2;
    
    // TEST9_DECIDE behavior
    // uml: enter / { trace("Enter TEST9_DECIDE."); }
    {
        // Step 1: execute action `trace("Enter TEST9_DECIDE.");`
        trace("Enter TEST9_DECIDE.");
    } // end of behavior for TEST9_DECIDE
}

static void TEST9_DECIDE_exit(Spec2Sm* self)
{
    // TEST9_DECIDE behavior
    // uml: exit / { trace("Exit TEST9_DECIDE."); }
    {
        // Step 1: execute action `trace("Exit TEST9_DECIDE.");`
        trace("Exit TEST9_DECIDE.");
    } // end of behavior for TEST9_DECIDE
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST9_EXIT_CHOICE_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
}

static void TEST9_DECIDE_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST9_DECIDE behavior
    // uml: EV1 [trace_guard("State TEST9_DECIDE: check behavior `EV1 TransitionTo(TEST9_ROOT)`.", true)] / { trace("Transition action `` for TEST9_DECIDE to TEST9_ROOT."); } TransitionTo(TEST9_ROOT)
    if (trace_guard("State TEST9_DECIDE: check behavior `EV1 TransitionTo(TEST9_ROOT)`.", true))
    {
        // Step 1: Exit states until we reach `TEST9_EXIT_CHOICE` state (Least Common Ancestor for transition).
        TEST9_DECIDE_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST9_DECIDE to TEST9_ROOT.");`.
        trace("Transition action `` for TEST9_DECIDE to TEST9_ROOT.");
        
        // Step 3: Enter/move towards transition target `TEST9_ROOT`.
        TEST9_ROOT_enter(self);
        
        // TEST9_ROOT.InitialState behavior
        // uml: / { trace("Transition action `` for TEST9_ROOT.InitialState to TEST9_S1."); } TransitionTo(TEST9_S1)
        {
            // Step 1: Exit states until we reach `TEST9_ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `` for TEST9_ROOT.InitialState to TEST9_S1.");`.
            trace("Transition action `` for TEST9_ROOT.InitialState to TEST9_S1.");
            
            // Step 3: Enter/move towards transition target `TEST9_S1`.
            TEST9_S1_enter(self);
            
            // TEST9_S1.InitialState behavior
            // uml: / { trace("Transition action `` for TEST9_S1.InitialState to TEST9_S1_1."); } TransitionTo(TEST9_S1_1)
            {
                // Step 1: Exit states until we reach `TEST9_S1` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
                
                // Step 2: Transition action: `trace("Transition action `` for TEST9_S1.InitialState to TEST9_S1_1.");`.
                trace("Transition action `` for TEST9_S1.InitialState to TEST9_S1_1.");
                
                // Step 3: Enter/move towards transition target `TEST9_S1_1`.
                TEST9_S1_1_enter(self);
                
                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                self->state_id = Spec2Sm_StateId_TEST9_S1_1;
                // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
                return;
            } // end of behavior for TEST9_S1.InitialState
        } // end of behavior for TEST9_ROOT.InitialState
    } // end of behavior for TEST9_DECIDE
}

static void TEST9_DECIDE_ev2(Spec2Sm* self)
{
    // No ancestor state handles `EV2` event.
    
    // TEST9_DECIDE behavior
    // uml: EV2 [trace_guard("State TEST9_DECIDE: check behavior `EV2 TransitionTo(TEST9A_ROOT)`.", true)] / { trace("Transition action `` for TEST9_DECIDE to TEST9A_ROOT."); } TransitionTo(TEST9A_ROOT)
    if (trace_guard("State TEST9_DECIDE: check behavior `EV2 TransitionTo(TEST9A_ROOT)`.", true))
    {
        // Step 1: Exit states until we reach `TEST9_EXIT_CHOICE` state (Least Common Ancestor for transition).
        TEST9_DECIDE_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST9_DECIDE to TEST9A_ROOT.");`.
        trace("Transition action `` for TEST9_DECIDE to TEST9A_ROOT.");
        
        // Step 3: Enter/move towards transition target `TEST9A_ROOT`.
        TEST9A_ROOT_enter(self);
        
        // TEST9A_ROOT.InitialState behavior
        // uml: / { trace("Transition action `count = 0;` for TEST9A_ROOT.InitialState to TEST9A_S1.");\ncount = 0; } TransitionTo(TEST9A_S1)
        {
            // Step 1: Exit states until we reach `TEST9A_ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: `trace("Transition action `count = 0;` for TEST9A_ROOT.InitialState to TEST9A_S1.");\ncount = 0;`.
            trace("Transition action `count = 0;` for TEST9A_ROOT.InitialState to TEST9A_S1.");
            self->vars.count = 0;
            
            // Step 3: Enter/move towards transition target `TEST9A_S1`.
            TEST9A_S1_enter(self);
            
            // Finish transition by calling pseudo state transition function.
            TEST9A_S1_InitialState_transition(self);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for TEST9A_ROOT.InitialState
    } // end of behavior for TEST9_DECIDE
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST9_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST9_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST9_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV5] = TEST9_ROOT_ev5;
    
    // TEST9_ROOT behavior
    // uml: enter / { trace("Enter TEST9_ROOT."); }
    {
        // Step 1: execute action `trace("Enter TEST9_ROOT.");`
        trace("Enter TEST9_ROOT.");
    } // end of behavior for TEST9_ROOT
}

static void TEST9_ROOT_exit(Spec2Sm* self)
{
    // TEST9_ROOT behavior
    // uml: exit / { trace("Exit TEST9_ROOT."); }
    {
        // Step 1: execute action `trace("Exit TEST9_ROOT.");`
        trace("Exit TEST9_ROOT.");
    } // end of behavior for TEST9_ROOT
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST9_EXIT_CHOICE_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV5] = NULL;  // no ancestor listens to this event
}

static void TEST9_ROOT_ev5(Spec2Sm* self)
{
    // No ancestor state handles `EV5` event.
    
    // TEST9_ROOT behavior
    // uml: EV5 [trace_guard("State TEST9_ROOT: check behavior `EV5 / { count++; }`.", true)] / { count++; }
    if (trace_guard("State TEST9_ROOT: check behavior `EV5 / { count++; }`.", true))
    {
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        
        // Step 1: execute action `count++;`
        self->vars.count++;
        
        // Step 2: determine if ancestor gets to handle event next.
        // No ancestor handles event. Ignore `consume_event` flag.
    } // end of behavior for TEST9_ROOT
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST9_G_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST9_G_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST9_G_S1_exit;
    
    // TEST9_G_S1 behavior
    // uml: enter / { trace("Enter TEST9_G_S1."); }
    {
        // Step 1: execute action `trace("Enter TEST9_G_S1.");`
        trace("Enter TEST9_G_S1.");
    } // end of behavior for TEST9_G_S1
}

static void TEST9_G_S1_exit(Spec2Sm* self)
{
    // TEST9_G_S1 behavior
    // uml: exit / { trace("Exit TEST9_G_S1."); }
    {
        // Step 1: execute action `trace("Exit TEST9_G_S1.");`
        trace("Exit TEST9_G_S1.");
    } // end of behavior for TEST9_G_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST9_ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST9_G_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST9_G_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST9_G_S2_exit;
    
    // TEST9_G_S2 behavior
    // uml: enter / { trace("Enter TEST9_G_S2."); }
    {
        // Step 1: execute action `trace("Enter TEST9_G_S2.");`
        trace("Enter TEST9_G_S2.");
    } // end of behavior for TEST9_G_S2
}

static void TEST9_G_S2_exit(Spec2Sm* self)
{
    // TEST9_G_S2 behavior
    // uml: exit / { trace("Exit TEST9_G_S2."); }
    {
        // Step 1: execute action `trace("Exit TEST9_G_S2.");`
        trace("Exit TEST9_G_S2.");
    } // end of behavior for TEST9_G_S2
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST9_ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST9_G_S3
////////////////////////////////////////////////////////////////////////////////

static void TEST9_G_S3_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST9_G_S3_exit;
    
    // TEST9_G_S3 behavior
    // uml: enter / { trace("Enter TEST9_G_S3."); }
    {
        // Step 1: execute action `trace("Enter TEST9_G_S3.");`
        trace("Enter TEST9_G_S3.");
    } // end of behavior for TEST9_G_S3
}

static void TEST9_G_S3_exit(Spec2Sm* self)
{
    // TEST9_G_S3 behavior
    // uml: exit / { trace("Exit TEST9_G_S3."); }
    {
        // Step 1: execute action `trace("Exit TEST9_G_S3.");`
        trace("Exit TEST9_G_S3.");
    } // end of behavior for TEST9_G_S3
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST9_ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST9_G_S4
////////////////////////////////////////////////////////////////////////////////

static void TEST9_G_S4_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST9_G_S4_exit;
    
    // TEST9_G_S4 behavior
    // uml: enter / { trace("Enter TEST9_G_S4."); }
    {
        // Step 1: execute action `trace("Enter TEST9_G_S4.");`
        trace("Enter TEST9_G_S4.");
    } // end of behavior for TEST9_G_S4
}

static void TEST9_G_S4_exit(Spec2Sm* self)
{
    // TEST9_G_S4 behavior
    // uml: exit / { trace("Exit TEST9_G_S4."); }
    {
        // Step 1: execute action `trace("Exit TEST9_G_S4.");`
        trace("Exit TEST9_G_S4.");
    } // end of behavior for TEST9_G_S4
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST9_ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST9_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST9_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST9_S1_exit;
    
    // TEST9_S1 behavior
    // uml: enter / { trace("Enter TEST9_S1."); }
    {
        // Step 1: execute action `trace("Enter TEST9_S1.");`
        trace("Enter TEST9_S1.");
    } // end of behavior for TEST9_S1
}

static void TEST9_S1_exit(Spec2Sm* self)
{
    // TEST9_S1 behavior
    // uml: exit / { trace("Exit TEST9_S1."); }
    {
        // Step 1: execute action `trace("Exit TEST9_S1.");`
        trace("Exit TEST9_S1.");
    } // end of behavior for TEST9_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST9_ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST9_S1_1
////////////////////////////////////////////////////////////////////////////////

static void TEST9_S1_1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST9_S1_1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST9_S1_1_ev1;
    
    // TEST9_S1_1 behavior
    // uml: enter / { trace("Enter TEST9_S1_1."); }
    {
        // Step 1: execute action `trace("Enter TEST9_S1_1.");`
        trace("Enter TEST9_S1_1.");
    } // end of behavior for TEST9_S1_1
    
    // TEST9_S1_1 behavior
    // uml: enter [trace_guard("State TEST9_S1_1: check behavior `enter / { clear_output(); }`.", true)] / { clear_output(); }
    if (trace_guard("State TEST9_S1_1: check behavior `enter / { clear_output(); }`.", true))
    {
        // Step 1: execute action `clear_output();`
        trace("IGNORE_OUTPUT_BEFORE_THIS");;
    } // end of behavior for TEST9_S1_1
}

static void TEST9_S1_1_exit(Spec2Sm* self)
{
    // TEST9_S1_1 behavior
    // uml: exit / { trace("Exit TEST9_S1_1."); }
    {
        // Step 1: execute action `trace("Exit TEST9_S1_1.");`
        trace("Exit TEST9_S1_1.");
    } // end of behavior for TEST9_S1_1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST9_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST9_S1_1_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST9_S1_1 behavior
    // uml: EV1 [trace_guard("State TEST9_S1_1: check behavior `EV1 TransitionTo(TEST9_S1.ExitPoint(1))`.", true)] / { trace("Transition action `` for TEST9_S1_1 to TEST9_S1.ExitPoint(1)."); } TransitionTo(TEST9_S1.ExitPoint(1))
    if (trace_guard("State TEST9_S1_1: check behavior `EV1 TransitionTo(TEST9_S1.ExitPoint(1))`.", true))
    {
        // Step 1: Exit states until we reach `TEST9_S1` state (Least Common Ancestor for transition).
        TEST9_S1_1_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST9_S1_1 to TEST9_S1.ExitPoint(1).");`.
        trace("Transition action `` for TEST9_S1_1 to TEST9_S1.ExitPoint(1).");
        
        // Step 3: Enter/move towards transition target `TEST9_S1.ExitPoint(1)`.
        // TEST9_S1.ExitPoint(1) is a pseudo state and cannot have an `enter` trigger.
        
        // TEST9_S1.ExitPoint(1) behavior
        // uml: [count == 4] / { trace("Transition action `` for TEST9_S1.ExitPoint(1) to TEST9_G_S4."); } TransitionTo(TEST9_G_S4)
        if (self->vars.count == 4)
        {
            // Step 1: Exit states until we reach `TEST9_ROOT` state (Least Common Ancestor for transition).
            TEST9_S1_exit(self);
            
            // Step 2: Transition action: `trace("Transition action `` for TEST9_S1.ExitPoint(1) to TEST9_G_S4.");`.
            trace("Transition action `` for TEST9_S1.ExitPoint(1) to TEST9_G_S4.");
            
            // Step 3: Enter/move towards transition target `TEST9_G_S4`.
            TEST9_G_S4_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_TEST9_G_S4;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for TEST9_S1.ExitPoint(1)
        
        // TEST9_S1.ExitPoint(1) behavior
        // uml: [count == 1] / { trace("Transition action `` for TEST9_S1.ExitPoint(1) to TEST9_G_S1."); } TransitionTo(TEST9_G_S1)
        if (self->vars.count == 1)
        {
            // Step 1: Exit states until we reach `TEST9_ROOT` state (Least Common Ancestor for transition).
            TEST9_S1_exit(self);
            
            // Step 2: Transition action: `trace("Transition action `` for TEST9_S1.ExitPoint(1) to TEST9_G_S1.");`.
            trace("Transition action `` for TEST9_S1.ExitPoint(1) to TEST9_G_S1.");
            
            // Step 3: Enter/move towards transition target `TEST9_G_S1`.
            TEST9_G_S1_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_TEST9_G_S1;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for TEST9_S1.ExitPoint(1)
        
        // TEST9_S1.ExitPoint(1) behavior
        // uml: [count == 2] / { trace("Transition action `` for TEST9_S1.ExitPoint(1) to TEST9_G_S2."); } TransitionTo(TEST9_G_S2)
        if (self->vars.count == 2)
        {
            // Step 1: Exit states until we reach `TEST9_ROOT` state (Least Common Ancestor for transition).
            TEST9_S1_exit(self);
            
            // Step 2: Transition action: `trace("Transition action `` for TEST9_S1.ExitPoint(1) to TEST9_G_S2.");`.
            trace("Transition action `` for TEST9_S1.ExitPoint(1) to TEST9_G_S2.");
            
            // Step 3: Enter/move towards transition target `TEST9_G_S2`.
            TEST9_G_S2_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_TEST9_G_S2;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for TEST9_S1.ExitPoint(1)
        
        // TEST9_S1.ExitPoint(1) behavior
        // uml: else / { trace("Transition action `` for TEST9_S1.ExitPoint(1) to TEST9_G_S3."); } TransitionTo(TEST9_G_S3)
        {
            // Step 1: Exit states until we reach `TEST9_ROOT` state (Least Common Ancestor for transition).
            TEST9_S1_exit(self);
            
            // Step 2: Transition action: `trace("Transition action `` for TEST9_S1.ExitPoint(1) to TEST9_G_S3.");`.
            trace("Transition action `` for TEST9_S1.ExitPoint(1) to TEST9_G_S3.");
            
            // Step 3: Enter/move towards transition target `TEST9_G_S3`.
            TEST9_G_S3_enter(self);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            self->state_id = Spec2Sm_StateId_TEST9_G_S3;
            // No ancestor handles event. Can skip nulling `self->ancestor_event_handler`.
            return;
        } // end of behavior for TEST9_S1.ExitPoint(1)
    } // end of behavior for TEST9_S1_1
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST9A_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST9A_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST9A_ROOT_exit;
    
    // TEST9A_ROOT behavior
    // uml: enter / { trace("Enter TEST9A_ROOT."); }
    {
        // Step 1: execute action `trace("Enter TEST9A_ROOT.");`
        trace("Enter TEST9A_ROOT.");
    } // end of behavior for TEST9A_ROOT
}

static void TEST9A_ROOT_exit(Spec2Sm* self)
{
    // TEST9A_ROOT behavior
    // uml: exit / { trace("Exit TEST9A_ROOT."); }
    {
        // Step 1: execute action `trace("Exit TEST9A_ROOT.");`
        trace("Exit TEST9A_ROOT.");
    } // end of behavior for TEST9A_ROOT
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST9_EXIT_CHOICE_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST9A_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST9A_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST9A_S1_exit;
    
    // TEST9A_S1 behavior
    // uml: enter / { trace("Enter TEST9A_S1."); }
    {
        // Step 1: execute action `trace("Enter TEST9A_S1.");`
        trace("Enter TEST9A_S1.");
    } // end of behavior for TEST9A_S1
}

static void TEST9A_S1_exit(Spec2Sm* self)
{
    // TEST9A_S1 behavior
    // uml: exit / { trace("Exit TEST9A_S1."); }
    {
        // Step 1: execute action `trace("Exit TEST9A_S1.");`
        trace("Exit TEST9A_S1.");
    } // end of behavior for TEST9A_S1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST9A_ROOT_exit;
}

static void TEST9A_S1_InitialState_transition(Spec2Sm* self)
{
    // TEST9A_S1.InitialState behavior
    // uml: / { trace("Transition action `` for TEST9A_S1.InitialState to TEST9A_S1_1."); } TransitionTo(TEST9A_S1_1)
    {
        // Step 1: Exit states until we reach `TEST9A_S1` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: `trace("Transition action `` for TEST9A_S1.InitialState to TEST9A_S1_1.");`.
        trace("Transition action `` for TEST9A_S1.InitialState to TEST9A_S1_1.");
        
        // Step 3: Enter/move towards transition target `TEST9A_S1_1`.
        TEST9A_S1_1_enter(self);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        self->state_id = Spec2Sm_StateId_TEST9A_S1_1;
        self->ancestor_event_handler = NULL;
        return;
    } // end of behavior for TEST9A_S1.InitialState
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST9A_S1_1
////////////////////////////////////////////////////////////////////////////////

static void TEST9A_S1_1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST9A_S1_1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST9A_S1_1_ev1;
    
    // TEST9A_S1_1 behavior
    // uml: enter / { trace("Enter TEST9A_S1_1."); }
    {
        // Step 1: execute action `trace("Enter TEST9A_S1_1.");`
        trace("Enter TEST9A_S1_1.");
    } // end of behavior for TEST9A_S1_1
    
    // TEST9A_S1_1 behavior
    // uml: enter [trace_guard("State TEST9A_S1_1: check behavior `enter [count == 0] / { clear_output(); }`.", count == 0)] / { clear_output(); }
    if (trace_guard("State TEST9A_S1_1: check behavior `enter [count == 0] / { clear_output(); }`.", self->vars.count == 0))
    {
        // Step 1: execute action `clear_output();`
        trace("IGNORE_OUTPUT_BEFORE_THIS");;
    } // end of behavior for TEST9A_S1_1
}

static void TEST9A_S1_1_exit(Spec2Sm* self)
{
    // TEST9A_S1_1 behavior
    // uml: exit / { trace("Exit TEST9A_S1_1."); }
    {
        // Step 1: execute action `trace("Exit TEST9A_S1_1.");`
        trace("Exit TEST9A_S1_1.");
    } // end of behavior for TEST9A_S1_1
    
    // TEST9A_S1_1 behavior
    // uml: exit [trace_guard("State TEST9A_S1_1: check behavior `exit / { count = 100; }`.", true)] / { count = 100; }
    if (trace_guard("State TEST9A_S1_1: check behavior `exit / { count = 100; }`.", true))
    {
        // Step 1: execute action `count = 100;`
        self->vars.count = 100;
    } // end of behavior for TEST9A_S1_1
    
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST9A_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST9A_S1_1_ev1(Spec2Sm* self)
{
    // No ancestor state handles `EV1` event.
    
    // TEST9A_S1_1 behavior
    // uml: EV1 [trace_guard("State TEST9A_S1_1: check behavior `EV1 TransitionTo(TEST9A_S1.ExitPoint(1))`.", true)] / { trace("Transition action `` for TEST9A_S1_1 to TEST9A_S1.ExitPoint(1)."); } TransitionTo(TEST9A_S1.ExitPoint(1))
    if (trace_guard("State TEST9A_S1_1: check behavior `EV1 TransitionTo(TEST9A_S1.ExitPoint(1))`.", true))
    {
        // Step 1: Exit states until we reach `TEST9A_S1` state (Least Common Ancestor for transition).
        TEST9A_S1_1_exit(self);
        
        // Step 2: Transition action: `trace("Transition action `` for TEST9A_S1_1 to TEST9A_S1.ExitPoint(1).");`.
        trace("Transition action `` for TEST9A_S1_1 to TEST9A_S1.ExitPoint(1).");
        
        // Step 3: Enter/move towards transition target `TEST9A_S1.ExitPoint(1)`.
        // TEST9A_S1.ExitPoint(1) is a pseudo state and cannot have an `enter` trigger.
        
        // TEST9A_S1.ExitPoint(1) behavior
        // uml: [true] / { trace("Transition action `count++;` for TEST9A_S1.ExitPoint(1) to TEST9A_S1.");\ncount++; } TransitionTo(TEST9A_S1)
        if (true)
        {
            // Step 1: Exit states until we reach `TEST9A_S1` state (Least Common Ancestor for transition).
            TEST9A_S1_exit(self);
            
            // Step 2: Transition action: `trace("Transition action `count++;` for TEST9A_S1.ExitPoint(1) to TEST9A_S1.");\ncount++;`.
            trace("Transition action `count++;` for TEST9A_S1.ExitPoint(1) to TEST9A_S1.");
            self->vars.count++;
            
            // Step 3: Enter/move towards transition target `TEST9A_S1`.
            // Already in target. No entering required.
            // Finish transition by calling pseudo state transition function.
            TEST9A_S1_InitialState_transition(self);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for TEST9A_S1.ExitPoint(1)
    } // end of behavior for TEST9A_S1_1
}


