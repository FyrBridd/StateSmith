// Autogenerated with StateSmith
#include "Spec2Sm.h"
#include "../../lang-helpers/c/helper.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

static void ROOT_enter(Spec2Sm* self);
static void ROOT_exit(Spec2Sm* self);

static void DECIDE_enter(Spec2Sm* self);
static void DECIDE_exit(Spec2Sm* self);
static void DECIDE_ev1(Spec2Sm* self);
static void DECIDE_ev2(Spec2Sm* self);
static void DECIDE_ev3(Spec2Sm* self);

static void TEST1_DO_EVENT_TESTING_enter(Spec2Sm* self);
static void TEST1_DO_EVENT_TESTING_exit(Spec2Sm* self);

static void TEST1_ROOT_enter(Spec2Sm* self);
static void TEST1_ROOT_exit(Spec2Sm* self);
static void TEST1_ROOT_do(Spec2Sm* self);

static void TEST1_S1_enter(Spec2Sm* self);
static void TEST1_S1_exit(Spec2Sm* self);

static void TEST1_S1_1_enter(Spec2Sm* self);
static void TEST1_S1_1_exit(Spec2Sm* self);
static void TEST1_S1_1_do(Spec2Sm* self);
static void TEST1_S1_1_ev1(Spec2Sm* self);

static void TEST1_S2_enter(Spec2Sm* self);
static void TEST1_S2_exit(Spec2Sm* self);
static void TEST1_S2_do(Spec2Sm* self);

static void TEST2_REGULAR_EVENT_TESTING_enter(Spec2Sm* self);
static void TEST2_REGULAR_EVENT_TESTING_exit(Spec2Sm* self);

static void TEST2_ROOT_enter(Spec2Sm* self);
static void TEST2_ROOT_exit(Spec2Sm* self);
static void TEST2_ROOT_do(Spec2Sm* self);
static void TEST2_ROOT_ev1(Spec2Sm* self);
static void TEST2_ROOT_ev2(Spec2Sm* self);

static void TEST2_S1_enter(Spec2Sm* self);
static void TEST2_S1_exit(Spec2Sm* self);

static void TEST2_S1_1_enter(Spec2Sm* self);
static void TEST2_S1_1_exit(Spec2Sm* self);
static void TEST2_S1_1_do(Spec2Sm* self);
static void TEST2_S1_1_ev1(Spec2Sm* self);

static void TEST2_S2_enter(Spec2Sm* self);
static void TEST2_S2_exit(Spec2Sm* self);
static void TEST2_S2_ev1(Spec2Sm* self);

static void TEST3_BEHAVIOR_ORDERING_enter(Spec2Sm* self);
static void TEST3_BEHAVIOR_ORDERING_exit(Spec2Sm* self);

static void TEST3_ROOT_enter(Spec2Sm* self);
static void TEST3_ROOT_exit(Spec2Sm* self);
static void TEST3_ROOT_ev1(Spec2Sm* self);

static void TEST3_S1_enter(Spec2Sm* self);
static void TEST3_S1_exit(Spec2Sm* self);
static void TEST3_S1_ev1(Spec2Sm* self);

static void TEST3_S2_enter(Spec2Sm* self);
static void TEST3_S2_exit(Spec2Sm* self);
static void TEST3_S2_ev1(Spec2Sm* self);

static void TEST3_S3_enter(Spec2Sm* self);
static void TEST3_S3_exit(Spec2Sm* self);

void Spec2Sm_ctor(Spec2Sm* self)
{
    memset(self, 0, sizeof(*self));
}

void Spec2Sm_start(Spec2Sm* self)
{
    ROOT_enter(self);
    trace("Transition action `` for Spec2Sm.InitialState to DECIDE.");
    // Transition to target state DECIDE
    {
        // target state DECIDE is a child of this state. No need to exit this state.
        
        // Enter towards target
        DECIDE_enter(self);
        
        // update state_id
        self->state_id = Spec2Sm_StateId_DECIDE;
    } // end of transition code
}

void Spec2Sm_dispatch_event(Spec2Sm* self, enum Spec2Sm_EventId event_id)
{
    Spec2Sm_Func behavior_func = self->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        self->ancestor_event_handler = NULL;
        behavior_func(self);
        behavior_func = self->ancestor_event_handler;
    }
}

const char* Spec2Sm_state_id_to_string(const enum Spec2Sm_StateId id)
{
    switch (id)
    {
        case Spec2Sm_StateId_ROOT: return "ROOT";
        case Spec2Sm_StateId_DECIDE: return "DECIDE";
        case Spec2Sm_StateId_TEST1_DO_EVENT_TESTING: return "TEST1_DO_EVENT_TESTING";
        case Spec2Sm_StateId_TEST1_ROOT: return "TEST1_ROOT";
        case Spec2Sm_StateId_TEST1_S1: return "TEST1_S1";
        case Spec2Sm_StateId_TEST1_S1_1: return "TEST1_S1_1";
        case Spec2Sm_StateId_TEST1_S2: return "TEST1_S2";
        case Spec2Sm_StateId_TEST2_REGULAR_EVENT_TESTING: return "TEST2_REGULAR_EVENT_TESTING";
        case Spec2Sm_StateId_TEST2_ROOT: return "TEST2_ROOT";
        case Spec2Sm_StateId_TEST2_S1: return "TEST2_S1";
        case Spec2Sm_StateId_TEST2_S1_1: return "TEST2_S1_1";
        case Spec2Sm_StateId_TEST2_S2: return "TEST2_S2";
        case Spec2Sm_StateId_TEST3_BEHAVIOR_ORDERING: return "TEST3_BEHAVIOR_ORDERING";
        case Spec2Sm_StateId_TEST3_ROOT: return "TEST3_ROOT";
        case Spec2Sm_StateId_TEST3_S1: return "TEST3_S1";
        case Spec2Sm_StateId_TEST3_S2: return "TEST3_S2";
        case Spec2Sm_StateId_TEST3_S3: return "TEST3_S3";
        default: return "?";
    }
}

////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = ROOT_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter Spec2Sm.");
        trace("Enter Spec2Sm.");
    } // end of behavior code
}

static void ROOT_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit Spec2Sm.");
        trace("Exit Spec2Sm.");
    } // end of behavior code
    // State machine root is a special case. It cannot be exited.
    (void)self;  // nothing to see here compiler. move along!
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state DECIDE
////////////////////////////////////////////////////////////////////////////////

static void DECIDE_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = DECIDE_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = DECIDE_ev1;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = DECIDE_ev2;
    self->current_event_handlers[Spec2Sm_EventId_EV3] = DECIDE_ev3;
    
    // state behavior:
    {
        // uml action: trace("Enter DECIDE.");
        trace("Enter DECIDE.");
    } // end of behavior code
}

static void DECIDE_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit DECIDE.");
        trace("Exit DECIDE.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV3] = NULL;  // no ancestor listens to this event
}

static void DECIDE_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV1` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State DECIDE: check behavior `EV1 TransitionTo(TEST1_DO_EVENT_TESTING)`.", true)
        // uml action: trace("Transition action `` for DECIDE to TEST1_DO_EVENT_TESTING.");trace("Transition action `` for TEST1_DO_EVENT_TESTING.InitialState to TEST1_ROOT.");trace("Transition action `` for TEST1_ROOT.InitialState to TEST1_S1_1.");
        // uml transition target: TEST1_S1_1
        if (trace_guard("State DECIDE: check behavior `EV1 TransitionTo(TEST1_DO_EVENT_TESTING)`.", true))
        {
            trace("Transition action `` for DECIDE to TEST1_DO_EVENT_TESTING.");trace("Transition action `` for TEST1_DO_EVENT_TESTING.InitialState to TEST1_ROOT.");trace("Transition action `` for TEST1_ROOT.InitialState to TEST1_S1_1.");
            
            // Transition to target state TEST1_S1_1
            {
                // First, exit up to Least Common Ancestor ROOT.
                while (self->current_state_exit_handler != ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST1_DO_EVENT_TESTING_enter(self);
                TEST1_ROOT_enter(self);
                TEST1_S1_enter(self);
                TEST1_S1_1_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST1_S1_1;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}

static void DECIDE_ev2(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV2` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV2` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State DECIDE: check behavior `EV2 TransitionTo(TEST2_REGULAR_EVENT_TESTING)`.", true)
        // uml action: trace("Transition action `` for DECIDE to TEST2_REGULAR_EVENT_TESTING.");trace("Transition action `` for TEST2_REGULAR_EVENT_TESTING.InitialState to TEST2_ROOT.");trace("Transition action `` for TEST2_ROOT.InitialState to TEST2_S1_1.");
        // uml transition target: TEST2_S1_1
        if (trace_guard("State DECIDE: check behavior `EV2 TransitionTo(TEST2_REGULAR_EVENT_TESTING)`.", true))
        {
            trace("Transition action `` for DECIDE to TEST2_REGULAR_EVENT_TESTING.");trace("Transition action `` for TEST2_REGULAR_EVENT_TESTING.InitialState to TEST2_ROOT.");trace("Transition action `` for TEST2_ROOT.InitialState to TEST2_S1_1.");
            
            // Transition to target state TEST2_S1_1
            {
                // First, exit up to Least Common Ancestor ROOT.
                while (self->current_state_exit_handler != ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST2_REGULAR_EVENT_TESTING_enter(self);
                TEST2_ROOT_enter(self);
                TEST2_S1_enter(self);
                TEST2_S1_1_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST2_S1_1;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}

static void DECIDE_ev3(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV3` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV3` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State DECIDE: check behavior `EV3 TransitionTo(TEST3_BEHAVIOR_ORDERING)`.", true)
        // uml action: trace("Transition action `` for DECIDE to TEST3_BEHAVIOR_ORDERING.");trace("Transition action `` for TEST3_BEHAVIOR_ORDERING.InitialState to TEST3_ROOT.");trace("Transition action `` for TEST3_ROOT.InitialState to TEST3_S1.");
        // uml transition target: TEST3_S1
        if (trace_guard("State DECIDE: check behavior `EV3 TransitionTo(TEST3_BEHAVIOR_ORDERING)`.", true))
        {
            trace("Transition action `` for DECIDE to TEST3_BEHAVIOR_ORDERING.");trace("Transition action `` for TEST3_BEHAVIOR_ORDERING.InitialState to TEST3_ROOT.");trace("Transition action `` for TEST3_ROOT.InitialState to TEST3_S1.");
            
            // Transition to target state TEST3_S1
            {
                // First, exit up to Least Common Ancestor ROOT.
                while (self->current_state_exit_handler != ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST3_BEHAVIOR_ORDERING_enter(self);
                TEST3_ROOT_enter(self);
                TEST3_S1_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST3_S1;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_DO_EVENT_TESTING
////////////////////////////////////////////////////////////////////////////////

static void TEST1_DO_EVENT_TESTING_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_DO_EVENT_TESTING_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST1_DO_EVENT_TESTING.");
        trace("Enter TEST1_DO_EVENT_TESTING.");
    } // end of behavior code
}

static void TEST1_DO_EVENT_TESTING_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST1_DO_EVENT_TESTING.");
        trace("Exit TEST1_DO_EVENT_TESTING.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST1_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_ROOT_do;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST1_ROOT.");
        trace("Enter TEST1_ROOT.");
    } // end of behavior code
}

static void TEST1_ROOT_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST1_ROOT.");
        trace("Exit TEST1_ROOT.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST1_DO_EVENT_TESTING_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void TEST1_ROOT_do(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `do` event
    
    // state behavior:
    {
        bool consume_event = false; // the `do` event is special in that it normally is not consumed.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        
        // uml guard: trace_guard("State TEST1_ROOT: check behavior `do`.", true)
        if (trace_guard("State TEST1_ROOT: check behavior `do`.", true))
        {
            
            if (consume_event)
            {
                // Mark event as handled.
                // self->ancestor_event_handler = NULL; // already done at top of function
            }
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST1_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_S1_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST1_S1.");
        trace("Enter TEST1_S1.");
    } // end of behavior code
}

static void TEST1_S1_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST1_S1.");
        trace("Exit TEST1_S1.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST1_ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_S1_1
////////////////////////////////////////////////////////////////////////////////

static void TEST1_S1_1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_S1_1_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_S1_1_do;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST1_S1_1_ev1;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST1_S1_1.");
        trace("Enter TEST1_S1_1.");
    } // end of behavior code
    
    // state behavior:
    {
        // uml guard: trace_guard("State TEST1_S1_1: check behavior `enter / { clear_output(); }`.", true)
        // uml action: clear_output();
        if (trace_guard("State TEST1_S1_1: check behavior `enter / { clear_output(); }`.", true))
        {
            trace("IGNORE_OUTPUT_BEFORE_THIS");;
        } // end of guard code
    } // end of behavior code
}

static void TEST1_S1_1_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST1_S1_1.");
        trace("Exit TEST1_S1_1.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST1_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_ROOT_do;  // the next ancestor that handles this event is TEST1_ROOT
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST1_S1_1_do(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = TEST1_ROOT_do;
    
    // state behavior:
    {
        bool consume_event = false; // the `do` event is special in that it normally is not consumed.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        // uml guard: trace_guard("State TEST1_S1_1: check behavior `do`.", true)
        if (trace_guard("State TEST1_S1_1: check behavior `do`.", true))
        {
            
            if (consume_event)
            {
                // Mark event as handled.
                self->ancestor_event_handler = NULL;
            }
        } // end of guard code
    } // end of behavior code
}

static void TEST1_S1_1_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV1` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST1_S1_1: check behavior `EV1 TransitionTo(TEST1_S2)`.", true)
        // uml action: trace("Transition action `` for TEST1_S1_1 to TEST1_S2.");
        // uml transition target: TEST1_S2
        if (trace_guard("State TEST1_S1_1: check behavior `EV1 TransitionTo(TEST1_S2)`.", true))
        {
            trace("Transition action `` for TEST1_S1_1 to TEST1_S2.");
            
            // Transition to target state TEST1_S2
            {
                // First, exit up to Least Common Ancestor TEST1_ROOT.
                while (self->current_state_exit_handler != TEST1_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST1_S2_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST1_S2;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST1_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST1_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST1_S2_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_S2_do;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST1_S2.");
        trace("Enter TEST1_S2.");
    } // end of behavior code
}

static void TEST1_S2_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST1_S2.");
        trace("Exit TEST1_S2.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST1_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST1_ROOT_do;  // the next ancestor that handles this event is TEST1_ROOT
}

static void TEST1_S2_do(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = TEST1_ROOT_do;
    
    // state behavior:
    {
        bool consume_event = false; // the `do` event is special in that it normally is not consumed.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        // uml guard: trace_guard("State TEST1_S2: check behavior `do / { consume_event = true; }`.", true)
        // uml action: consume_event = true;
        if (trace_guard("State TEST1_S2: check behavior `do / { consume_event = true; }`.", true))
        {
            consume_event = true;
            
            if (consume_event)
            {
                // Mark event as handled.
                self->ancestor_event_handler = NULL;
            }
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_REGULAR_EVENT_TESTING
////////////////////////////////////////////////////////////////////////////////

static void TEST2_REGULAR_EVENT_TESTING_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_REGULAR_EVENT_TESTING_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST2_REGULAR_EVENT_TESTING.");
        trace("Enter TEST2_REGULAR_EVENT_TESTING.");
    } // end of behavior code
}

static void TEST2_REGULAR_EVENT_TESTING_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST2_REGULAR_EVENT_TESTING.");
        trace("Exit TEST2_REGULAR_EVENT_TESTING.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST2_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST2_ROOT_do;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_ROOT_ev1;
    self->current_event_handlers[Spec2Sm_EventId_EV2] = TEST2_ROOT_ev2;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST2_ROOT.");
        trace("Enter TEST2_ROOT.");
    } // end of behavior code
}

static void TEST2_ROOT_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST2_ROOT.");
        trace("Exit TEST2_ROOT.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST2_REGULAR_EVENT_TESTING_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[Spec2Sm_EventId_EV2] = NULL;  // no ancestor listens to this event
}

static void TEST2_ROOT_do(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `do` event
    
    // state behavior:
    {
        bool consume_event = false; // the `do` event is special in that it normally is not consumed.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        
        // uml guard: trace_guard("State TEST2_ROOT: check behavior `do`.", true)
        if (trace_guard("State TEST2_ROOT: check behavior `do`.", true))
        {
            
            if (consume_event)
            {
                // Mark event as handled.
                // self->ancestor_event_handler = NULL; // already done at top of function
            }
        } // end of guard code
    } // end of behavior code
}

static void TEST2_ROOT_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV1` event
    
    // state behavior:
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        
        // uml guard: trace_guard("State TEST2_ROOT: check behavior `EV1`.", true)
        if (trace_guard("State TEST2_ROOT: check behavior `EV1`.", true))
        {
            
            if (consume_event)
            {
                // Mark event as handled.
                // self->ancestor_event_handler = NULL; // already done at top of function
            }
        } // end of guard code
    } // end of behavior code
}

static void TEST2_ROOT_ev2(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV2` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV2` event
    
    // state behavior:
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        
        // uml guard: trace_guard("State TEST2_ROOT: check behavior `EV2`.", true)
        if (trace_guard("State TEST2_ROOT: check behavior `EV2`.", true))
        {
            
            if (consume_event)
            {
                // Mark event as handled.
                // self->ancestor_event_handler = NULL; // already done at top of function
            }
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST2_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_S1_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST2_S1.");
        trace("Enter TEST2_S1.");
    } // end of behavior code
}

static void TEST2_S1_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST2_S1.");
        trace("Exit TEST2_S1.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST2_ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_S1_1
////////////////////////////////////////////////////////////////////////////////

static void TEST2_S1_1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_S1_1_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST2_S1_1_do;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_S1_1_ev1;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST2_S1_1.");
        trace("Enter TEST2_S1_1.");
    } // end of behavior code
    
    // state behavior:
    {
        // uml guard: trace_guard("State TEST2_S1_1: check behavior `enter / { clear_output(); }`.", true)
        // uml action: clear_output();
        if (trace_guard("State TEST2_S1_1: check behavior `enter / { clear_output(); }`.", true))
        {
            trace("IGNORE_OUTPUT_BEFORE_THIS");;
        } // end of guard code
    } // end of behavior code
}

static void TEST2_S1_1_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST2_S1_1.");
        trace("Exit TEST2_S1_1.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST2_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_DO] = TEST2_ROOT_do;  // the next ancestor that handles this event is TEST2_ROOT
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_ROOT_ev1;  // the next ancestor that handles this event is TEST2_ROOT
}

static void TEST2_S1_1_do(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = TEST2_ROOT_do;
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST2_S1_1: check behavior `do TransitionTo(TEST2_S2)`.", true)
        // uml action: trace("Transition action `` for TEST2_S1_1 to TEST2_S2.");
        // uml transition target: TEST2_S2
        if (trace_guard("State TEST2_S1_1: check behavior `do TransitionTo(TEST2_S2)`.", true))
        {
            trace("Transition action `` for TEST2_S1_1 to TEST2_S2.");
            
            // Transition to target state TEST2_S2
            {
                // First, exit up to Least Common Ancestor TEST2_ROOT.
                while (self->current_state_exit_handler != TEST2_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST2_S2_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST2_S2;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}

static void TEST2_S1_1_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = TEST2_ROOT_ev1;
    
    // state behavior:
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        // uml guard: trace_guard("State TEST2_S1_1: check behavior `EV1`.", true)
        if (trace_guard("State TEST2_S1_1: check behavior `EV1`.", true))
        {
            
            if (consume_event)
            {
                // Mark event as handled.
                self->ancestor_event_handler = NULL;
            }
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST2_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST2_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST2_S2_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_S2_ev1;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST2_S2.");
        trace("Enter TEST2_S2.");
    } // end of behavior code
}

static void TEST2_S2_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST2_S2.");
        trace("Exit TEST2_S2.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST2_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST2_ROOT_ev1;  // the next ancestor that handles this event is TEST2_ROOT
}

static void TEST2_S2_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = TEST2_ROOT_ev1;
    
    // state behavior:
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        // uml guard: trace_guard("State TEST2_S2: check behavior `EV1 / { consume_event = false; }`.", true)
        // uml action: consume_event = false;
        if (trace_guard("State TEST2_S2: check behavior `EV1 / { consume_event = false; }`.", true))
        {
            consume_event = false;
            
            if (consume_event)
            {
                // Mark event as handled.
                self->ancestor_event_handler = NULL;
            }
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_BEHAVIOR_ORDERING
////////////////////////////////////////////////////////////////////////////////

static void TEST3_BEHAVIOR_ORDERING_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_BEHAVIOR_ORDERING_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST3_BEHAVIOR_ORDERING.");
        trace("Enter TEST3_BEHAVIOR_ORDERING.");
    } // end of behavior code
}

static void TEST3_BEHAVIOR_ORDERING_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST3_BEHAVIOR_ORDERING.");
        trace("Exit TEST3_BEHAVIOR_ORDERING.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_ROOT
////////////////////////////////////////////////////////////////////////////////

static void TEST3_ROOT_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_ROOT_ev1;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST3_ROOT.");
        trace("Enter TEST3_ROOT.");
    } // end of behavior code
}

static void TEST3_ROOT_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST3_ROOT.");
        trace("Exit TEST3_ROOT.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST3_BEHAVIOR_ORDERING_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = NULL;  // no ancestor listens to this event
}

static void TEST3_ROOT_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `EV1` event
    
    // state behavior:
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        // note: no ancestor consumes this event, but we output `bool consume_event` anyway because a user's design might rely on it.
        
        // uml guard: trace_guard("State TEST3_ROOT: check behavior `EV1`.", true)
        if (trace_guard("State TEST3_ROOT: check behavior `EV1`.", true))
        {
            
            if (consume_event)
            {
                // Mark event as handled.
                // self->ancestor_event_handler = NULL; // already done at top of function
            }
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_S1
////////////////////////////////////////////////////////////////////////////////

static void TEST3_S1_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_S1_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_S1_ev1;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST3_S1.");
        trace("Enter TEST3_S1.");
    } // end of behavior code
    
    // state behavior:
    {
        // uml guard: trace_guard("State TEST3_S1: check behavior `enter / { clear_output(); }`.", true)
        // uml action: clear_output();
        if (trace_guard("State TEST3_S1: check behavior `enter / { clear_output(); }`.", true))
        {
            trace("IGNORE_OUTPUT_BEFORE_THIS");;
        } // end of guard code
    } // end of behavior code
}

static void TEST3_S1_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST3_S1.");
        trace("Exit TEST3_S1.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST3_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_ROOT_ev1;  // the next ancestor that handles this event is TEST3_ROOT
}

static void TEST3_S1_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = TEST3_ROOT_ev1;
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST3_S1: check behavior `1. EV1 TransitionTo(TEST3_S2)`.", true)
        // uml action: trace("Transition action `` for TEST3_S1 to TEST3_S2.");
        // uml transition target: TEST3_S2
        if (trace_guard("State TEST3_S1: check behavior `1. EV1 TransitionTo(TEST3_S2)`.", true))
        {
            trace("Transition action `` for TEST3_S1 to TEST3_S2.");
            
            // Transition to target state TEST3_S2
            {
                // First, exit up to Least Common Ancestor TEST3_ROOT.
                while (self->current_state_exit_handler != TEST3_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST3_S2_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST3_S2;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
    
    // state behavior:
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        // uml guard: trace_guard("State TEST3_S1: check behavior `2. EV1 / { trace(\"failed\"); }`.", true)
        // uml action: trace("failed");
        if (trace_guard("State TEST3_S1: check behavior `2. EV1 / { trace(\"failed\"); }`.", true))
        {
            trace("failed");
            
            if (consume_event)
            {
                // Mark event as handled.
                self->ancestor_event_handler = NULL;
            }
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_S2
////////////////////////////////////////////////////////////////////////////////

static void TEST3_S2_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_S2_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_S2_ev1;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST3_S2.");
        trace("Enter TEST3_S2.");
    } // end of behavior code
}

static void TEST3_S2_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST3_S2.");
        trace("Exit TEST3_S2.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST3_ROOT_exit;
    self->current_event_handlers[Spec2Sm_EventId_EV1] = TEST3_ROOT_ev1;  // the next ancestor that handles this event is TEST3_ROOT
}

static void TEST3_S2_ev1(Spec2Sm* self)
{
    // setup handler for next ancestor that listens to `EV1` event
    self->ancestor_event_handler = TEST3_ROOT_ev1;
    
    // state behavior:
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        // uml guard: trace_guard("State TEST3_S2: check behavior `1. EV1 / { trace(\"1 woot!\"); }`.", true)
        // uml action: trace("1 woot!");
        if (trace_guard("State TEST3_S2: check behavior `1. EV1 / { trace(\"1 woot!\"); }`.", true))
        {
            trace("1 woot!");
            
            if (consume_event)
            {
                // Mark event as handled.
                self->ancestor_event_handler = NULL;
            }
        } // end of guard code
    } // end of behavior code
    
    // state behavior:
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        // uml guard: trace_guard("State TEST3_S2: check behavior `1.1. EV1 / { trace(\"2 woot!\"); }`.", true)
        // uml action: trace("2 woot!");
        if (trace_guard("State TEST3_S2: check behavior `1.1. EV1 / { trace(\"2 woot!\"); }`.", true))
        {
            trace("2 woot!");
            
            if (consume_event)
            {
                // Mark event as handled.
                self->ancestor_event_handler = NULL;
            }
        } // end of guard code
    } // end of behavior code
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: trace_guard("State TEST3_S2: check behavior `2. EV1 / { trace(\"3 woot!\"); } TransitionTo(TEST3_S3)`.", true)
        // uml action: trace("Transition action `trace(\"3 woot!\");` for TEST3_S2 to TEST3_S3.");
        //             trace("3 woot!");
        // uml transition target: TEST3_S3
        if (trace_guard("State TEST3_S2: check behavior `2. EV1 / { trace(\"3 woot!\"); } TransitionTo(TEST3_S3)`.", true))
        {
            trace("Transition action `trace(\"3 woot!\");` for TEST3_S2 to TEST3_S3.");
            trace("3 woot!");
            
            // Transition to target state TEST3_S3
            {
                // First, exit up to Least Common Ancestor TEST3_ROOT.
                while (self->current_state_exit_handler != TEST3_ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                TEST3_S3_enter(self);
                
                // update state_id
                self->state_id = Spec2Sm_StateId_TEST3_S3;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state TEST3_S3
////////////////////////////////////////////////////////////////////////////////

static void TEST3_S3_enter(Spec2Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = TEST3_S3_exit;
    
    // state behavior:
    {
        // uml action: trace("Enter TEST3_S3.");
        trace("Enter TEST3_S3.");
    } // end of behavior code
}

static void TEST3_S3_exit(Spec2Sm* self)
{
    
    // state behavior:
    {
        // uml action: trace("Exit TEST3_S3.");
        trace("Exit TEST3_S3.");
    } // end of behavior code
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = TEST3_ROOT_exit;
}


