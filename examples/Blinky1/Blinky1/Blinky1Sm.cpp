// Autogenerated with StateSmith
#include "Blinky1Sm.h"
// this ends up in the generated .cpp file
#include "Arduino.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

static void ROOT_enter(Blinky1Sm* self);
static void ROOT_exit(Blinky1Sm* self);

static void LED_OFF_enter(Blinky1Sm* self);
static void LED_OFF_exit(Blinky1Sm* self);
static void LED_OFF_do(Blinky1Sm* self);

static void LED_ON_enter(Blinky1Sm* self);
static void LED_ON_exit(Blinky1Sm* self);
static void LED_ON_do(Blinky1Sm* self);

void Blinky1Sm_ctor(Blinky1Sm* self)
{
    memset(self, 0, sizeof(*self));
}

void Blinky1Sm_start(Blinky1Sm* self)
{
    ROOT_enter(self);
    // Transition to target state LED_OFF
    {
        // No need exit any states in this handler.
        
        // Enter towards target
        LED_OFF_enter(self);
        
        // update state_id
        self->state_id = Blinky1Sm_StateId_LED_OFF;
    } // end of transition code
}

void Blinky1Sm_dispatch_event(Blinky1Sm* self, enum Blinky1Sm_EventId event_id)
{
    Blinky1Sm_Func behavior_func = self->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        self->ancestor_event_handler = NULL;
        behavior_func(self);
        behavior_func = self->ancestor_event_handler;
    }
}

const char* Blinky1Sm_state_id_to_string(const enum Blinky1Sm_StateId id)
{
    switch (id)
    {
        case Blinky1Sm_StateId_ROOT: return "ROOT";
        case Blinky1Sm_StateId_LED_OFF: return "LED_OFF";
        case Blinky1Sm_StateId_LED_ON: return "LED_ON";
        default: return "?";
    }
}

////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(Blinky1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = ROOT_exit;
}

static void ROOT_exit(Blinky1Sm* self)
{
    // State machine root is a special case. It cannot be exited.
    (void)self;  // nothing to see here compiler. move along!
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state LED_OFF
////////////////////////////////////////////////////////////////////////////////

static void LED_OFF_enter(Blinky1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = LED_OFF_exit;
    self->current_event_handlers[Blinky1Sm_EventId_DO] = LED_OFF_do;
    
    // state behavior:
    {
        // uml action: turn_led_off();
        digitalWrite(LED_BUILTIN, LOW);;
    } // end of behavior code
    
    // state behavior:
    {
        // uml action: reset_timer();
        self->vars.timer_started_at_ms = millis();
    } // end of behavior code
}

static void LED_OFF_exit(Blinky1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[Blinky1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void LED_OFF_do(Blinky1Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `do` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: after_ms(500)
        // uml transition target: LED_ON
        if (( (millis() - self->vars.timer_started_at_ms) >= 500 ))
        {
            // Transition to target state LED_ON
            {
                // First, exit up to Least Common Ancestor ROOT.
                while (self->current_state_exit_handler != ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                LED_ON_enter(self);
                
                // update state_id
                self->state_id = Blinky1Sm_StateId_LED_ON;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state LED_ON
////////////////////////////////////////////////////////////////////////////////

static void LED_ON_enter(Blinky1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = LED_ON_exit;
    self->current_event_handlers[Blinky1Sm_EventId_DO] = LED_ON_do;
    
    // state behavior:
    {
        // uml action: turn_led_on();
        //             reset_timer();
        digitalWrite(LED_BUILTIN, HIGH);;
        self->vars.timer_started_at_ms = millis();
    } // end of behavior code
}

static void LED_ON_exit(Blinky1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[Blinky1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void LED_ON_do(Blinky1Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `do` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: elapsed_ms > 1000
        // uml transition target: LED_OFF
        if ((millis() - self->vars.timer_started_at_ms) > 1000)
        {
            // Transition to target state LED_OFF
            {
                // First, exit up to Least Common Ancestor ROOT.
                while (self->current_state_exit_handler != ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                LED_OFF_enter(self);
                
                // update state_id
                self->state_id = Blinky1Sm_StateId_LED_OFF;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


