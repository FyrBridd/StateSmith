// Autogenerated with StateSmith
#include "ButtonSm1Cpp.h"
#include "Arduino.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

static void ROOT_enter(ButtonSm1Cpp* self);
static void ROOT_exit(ButtonSm1Cpp* self);

static void NOT_PRESSED_enter(ButtonSm1Cpp* self);
static void NOT_PRESSED_exit(ButtonSm1Cpp* self);
static void NOT_PRESSED_do(ButtonSm1Cpp* self);

static void PRESSED_enter(ButtonSm1Cpp* self);
static void PRESSED_exit(ButtonSm1Cpp* self);
static void PRESSED_do(ButtonSm1Cpp* self);

static void CONFIRMING_HELD_enter(ButtonSm1Cpp* self);
static void CONFIRMING_HELD_exit(ButtonSm1Cpp* self);
static void CONFIRMING_HELD_do(ButtonSm1Cpp* self);

static void HELD_enter(ButtonSm1Cpp* self);
static void HELD_exit(ButtonSm1Cpp* self);

void ButtonSm1Cpp_ctor(ButtonSm1Cpp* self)
{
    memset(self, 0, sizeof(*self));
}

void ButtonSm1Cpp_start(ButtonSm1Cpp* self)
{
    ROOT_enter(self);
    // Transition to target state NOT_PRESSED
    {
        // target state NOT_PRESSED is a child of this state. No need to exit this state.
        
        // Enter towards target
        NOT_PRESSED_enter(self);
        
        // update state_id
        self->state_id = ButtonSm1Cpp_StateId_NOT_PRESSED;
    } // end of transition code
}

void ButtonSm1Cpp_dispatch_event(ButtonSm1Cpp* self, enum ButtonSm1Cpp_EventId event_id)
{
    ButtonSm1Cpp_Func behavior_func = self->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        self->ancestor_event_handler = NULL;
        behavior_func(self);
        behavior_func = self->ancestor_event_handler;
    }
}

const char* ButtonSm1Cpp_state_id_to_string(const enum ButtonSm1Cpp_StateId id)
{
    switch (id)
    {
        case ButtonSm1Cpp_StateId_ROOT: return "ROOT";
        case ButtonSm1Cpp_StateId_NOT_PRESSED: return "NOT_PRESSED";
        case ButtonSm1Cpp_StateId_PRESSED: return "PRESSED";
        case ButtonSm1Cpp_StateId_CONFIRMING_HELD: return "CONFIRMING_HELD";
        case ButtonSm1Cpp_StateId_HELD: return "HELD";
        default: return "?";
    }
}

////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(ButtonSm1Cpp* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = ROOT_exit;
}

static void ROOT_exit(ButtonSm1Cpp* self)
{
    // State machine root is a special case. It cannot be exited.
    (void)self;  // nothing to see here compiler. move along!
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state NOT_PRESSED
////////////////////////////////////////////////////////////////////////////////

static void NOT_PRESSED_enter(ButtonSm1Cpp* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = NOT_PRESSED_exit;
    self->current_event_handlers[ButtonSm1Cpp_EventId_DO] = NOT_PRESSED_do;
    
    // state behavior:
    {
        // uml action: reset_debounce_timer();
        self->vars.debounce_started_at_ms = millis();
    } // end of behavior code
}

static void NOT_PRESSED_exit(ButtonSm1Cpp* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[ButtonSm1Cpp_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void NOT_PRESSED_do(ButtonSm1Cpp* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `do` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: is_pressed
        //              && is_debounced
        // uml transition target: CONFIRMING_HELD
        if (self->vars.input_is_pressed
  && (( (millis() - self->vars.debounce_started_at_ms) >= 20 )))
        {
            // Transition to target state CONFIRMING_HELD
            {
                // First, exit up to Least Common Ancestor ROOT.
                while (self->current_state_exit_handler != ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                PRESSED_enter(self);
                CONFIRMING_HELD_enter(self);
                
                // update state_id
                self->state_id = ButtonSm1Cpp_StateId_CONFIRMING_HELD;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state PRESSED
////////////////////////////////////////////////////////////////////////////////

static void PRESSED_enter(ButtonSm1Cpp* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = PRESSED_exit;
    self->current_event_handlers[ButtonSm1Cpp_EventId_DO] = PRESSED_do;
    
    // state behavior:
    {
        // uml action: reset_debounce_timer();
        //             output_event(press);
        self->vars.debounce_started_at_ms = millis();
        self->vars.output_event_press = true;
    } // end of behavior code
}

static void PRESSED_exit(ButtonSm1Cpp* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[ButtonSm1Cpp_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void PRESSED_do(ButtonSm1Cpp* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `do` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: is_released && is_debounced
        // uml action: if (debounce_ms() <= 200) {
        //               output_event(tap);
        //             }
        //             output_event(release);
        // uml transition target: NOT_PRESSED
        if ((!self->vars.input_is_pressed) && (( (millis() - self->vars.debounce_started_at_ms) >= 20 )))
        {
            if ((millis() - self->vars.debounce_started_at_ms) <= 200) {
              self->vars.output_event_tap = true;
            }
            self->vars.output_event_release = true;
            
            // Transition to target state NOT_PRESSED
            {
                // First, exit up to Least Common Ancestor ROOT.
                while (self->current_state_exit_handler != ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                NOT_PRESSED_enter(self);
                
                // update state_id
                self->state_id = ButtonSm1Cpp_StateId_NOT_PRESSED;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state CONFIRMING_HELD
////////////////////////////////////////////////////////////////////////////////

static void CONFIRMING_HELD_enter(ButtonSm1Cpp* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = CONFIRMING_HELD_exit;
    self->current_event_handlers[ButtonSm1Cpp_EventId_DO] = CONFIRMING_HELD_do;
}

static void CONFIRMING_HELD_exit(ButtonSm1Cpp* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = PRESSED_exit;
    self->current_event_handlers[ButtonSm1Cpp_EventId_DO] = PRESSED_do;  // the next ancestor that handles this event is PRESSED
}

static void CONFIRMING_HELD_do(ButtonSm1Cpp* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = PRESSED_do;
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: debounce_ms() > 800
        // uml transition target: HELD
        if ((millis() - self->vars.debounce_started_at_ms) > 800)
        {
            // Transition to target state HELD
            {
                // First, exit up to Least Common Ancestor PRESSED.
                while (self->current_state_exit_handler != PRESSED_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                HELD_enter(self);
                
                // update state_id
                self->state_id = ButtonSm1Cpp_StateId_HELD;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            self->ancestor_event_handler = NULL;
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state HELD
////////////////////////////////////////////////////////////////////////////////

static void HELD_enter(ButtonSm1Cpp* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = HELD_exit;
    
    // state behavior:
    {
        // uml action: output_event(held);
        self->vars.output_event_held = true;
    } // end of behavior code
}

static void HELD_exit(ButtonSm1Cpp* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = PRESSED_exit;
}


