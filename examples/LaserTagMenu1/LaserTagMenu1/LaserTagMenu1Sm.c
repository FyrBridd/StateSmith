// Autogenerated with StateSmith
#include "LaserTagMenu1Sm.h"
#include "App.h"
#include "Display.h"
#include "PortApi.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset

static void ROOT_enter(LaserTagMenu1Sm* self);
static void ROOT_exit(LaserTagMenu1Sm* self);

static void HOME_enter(LaserTagMenu1Sm* self);
static void HOME_exit(LaserTagMenu1Sm* self);
static void HOME_ok_press(LaserTagMenu1Sm* self);

static void HOME1_enter(LaserTagMenu1Sm* self);
static void HOME1_exit(LaserTagMenu1Sm* self);
static void HOME1_down_press(LaserTagMenu1Sm* self);
static void HOME1_up_press(LaserTagMenu1Sm* self);

static void HOME2_enter(LaserTagMenu1Sm* self);
static void HOME2_exit(LaserTagMenu1Sm* self);
static void HOME2_down_press(LaserTagMenu1Sm* self);
static void HOME2_up_press(LaserTagMenu1Sm* self);

static void HOME3_enter(LaserTagMenu1Sm* self);
static void HOME3_exit(LaserTagMenu1Sm* self);
static void HOME3_down_press(LaserTagMenu1Sm* self);
static void HOME3_up_press(LaserTagMenu1Sm* self);

static void MENUS_GROUP_enter(LaserTagMenu1Sm* self);
static void MENUS_GROUP_exit(LaserTagMenu1Sm* self);
static void MENUS_GROUP_back_held(LaserTagMenu1Sm* self);
static void MENUS_GROUP_back_press(LaserTagMenu1Sm* self);

static void CLASS_SAVED_enter(LaserTagMenu1Sm* self);
static void CLASS_SAVED_exit(LaserTagMenu1Sm* self);
static void CLASS_SAVED_do(LaserTagMenu1Sm* self);

static void MAIN_MENU_enter(LaserTagMenu1Sm* self);
static void MAIN_MENU_exit(LaserTagMenu1Sm* self);

static void MM_BACK_PRESS_EATER_OPTION_enter(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_OPTION_exit(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_OPTION_ok_press(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_OPTION_up_press(LaserTagMenu1Sm* self);

static void MM_SELECT_CLASS_OPTION_enter(LaserTagMenu1Sm* self);
static void MM_SELECT_CLASS_OPTION_exit(LaserTagMenu1Sm* self);
static void MM_SELECT_CLASS_OPTION_down_press(LaserTagMenu1Sm* self);
static void MM_SELECT_CLASS_OPTION_ok_press(LaserTagMenu1Sm* self);

static void MM_SHOW_INFO_OPTION_enter(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_OPTION_exit(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_OPTION_down_press(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_OPTION_ok_press(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_OPTION_up_press(LaserTagMenu1Sm* self);

static void MM_BACK_PRESS_EATER_enter(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_exit(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_back_press(LaserTagMenu1Sm* self);

static void MM_BACK_PRESS_EATER_1_enter(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_1_exit(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_1_do(LaserTagMenu1Sm* self);

static void MM_BACK_PRESS_EATER_2_enter(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_2_exit(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_2_do(LaserTagMenu1Sm* self);

static void MM_BACK_PRESS_EATER_3_enter(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_3_exit(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_3_do(LaserTagMenu1Sm* self);

static void MM_BACK_PRESS_EATER_4_enter(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_4_exit(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_4_do(LaserTagMenu1Sm* self);

static void MM_BACK_PRESS_EATER_5_enter(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_5_exit(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_5_back_press(LaserTagMenu1Sm* self);
static void MM_BACK_PRESS_EATER_5_do(LaserTagMenu1Sm* self);

static void MM_SELECT_CLASS_enter(LaserTagMenu1Sm* self);
static void MM_SELECT_CLASS_exit(LaserTagMenu1Sm* self);
static void MM_SELECT_CLASS_back_press(LaserTagMenu1Sm* self);
static void MM_SELECT_CLASS_ok_press(LaserTagMenu1Sm* self);

static void MM_SC_ENGINEER_enter(LaserTagMenu1Sm* self);
static void MM_SC_ENGINEER_exit(LaserTagMenu1Sm* self);
static void MM_SC_ENGINEER_down_press(LaserTagMenu1Sm* self);

static void MM_SC_MID_enter(LaserTagMenu1Sm* self);
static void MM_SC_MID_exit(LaserTagMenu1Sm* self);
static void MM_SC_MID_down_held(LaserTagMenu1Sm* self);
static void MM_SC_MID_up_held(LaserTagMenu1Sm* self);

static void MM_SC_ARCHER_enter(LaserTagMenu1Sm* self);
static void MM_SC_ARCHER_exit(LaserTagMenu1Sm* self);
static void MM_SC_ARCHER_down_press(LaserTagMenu1Sm* self);
static void MM_SC_ARCHER_up_press(LaserTagMenu1Sm* self);

static void MM_SC_HEAVY_enter(LaserTagMenu1Sm* self);
static void MM_SC_HEAVY_exit(LaserTagMenu1Sm* self);
static void MM_SC_HEAVY_down_press(LaserTagMenu1Sm* self);
static void MM_SC_HEAVY_up_press(LaserTagMenu1Sm* self);

static void MM_SC_WIZARD_enter(LaserTagMenu1Sm* self);
static void MM_SC_WIZARD_exit(LaserTagMenu1Sm* self);
static void MM_SC_WIZARD_down_press(LaserTagMenu1Sm* self);
static void MM_SC_WIZARD_up_press(LaserTagMenu1Sm* self);

static void MM_SC_SPY_enter(LaserTagMenu1Sm* self);
static void MM_SC_SPY_exit(LaserTagMenu1Sm* self);
static void MM_SC_SPY_up_press(LaserTagMenu1Sm* self);

static void MM_SHOW_INFO_enter(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_exit(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_back_press(LaserTagMenu1Sm* self);

static void MM_SHOW_INFO_1_enter(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_1_exit(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_1_do(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_1_down_press(LaserTagMenu1Sm* self);

static void MM_SHOW_INFO_2_enter(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_2_exit(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_2_do(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_2_down_press(LaserTagMenu1Sm* self);

static void MM_SHOW_INFO_3_enter(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_3_exit(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_3_do(LaserTagMenu1Sm* self);
static void MM_SHOW_INFO_3_down_press(LaserTagMenu1Sm* self);

static void WELCOME_SCREEN_enter(LaserTagMenu1Sm* self);
static void WELCOME_SCREEN_exit(LaserTagMenu1Sm* self);
static void WELCOME_SCREEN_do(LaserTagMenu1Sm* self);

void LaserTagMenu1Sm_ctor(LaserTagMenu1Sm* self)
{
    memset(self, 0, sizeof(*self));
}

void LaserTagMenu1Sm_start(LaserTagMenu1Sm* self)
{
    ROOT_enter(self);
    // Transition to target state WELCOME_SCREEN
    {
        // target state WELCOME_SCREEN is a child of this state. No need to exit this state.
        
        // Enter towards target
        WELCOME_SCREEN_enter(self);
        
        // update state_id
        self->state_id = LaserTagMenu1Sm_StateId_WELCOME_SCREEN;
    } // end of transition code
}

void LaserTagMenu1Sm_dispatch_event(LaserTagMenu1Sm* self, enum LaserTagMenu1Sm_EventId event_id)
{
    LaserTagMenu1Sm_Func behavior_func = self->current_event_handlers[event_id];
    
    while (behavior_func != NULL)
    {
        self->ancestor_event_handler = NULL;
        behavior_func(self);
        behavior_func = self->ancestor_event_handler;
    }
}

static void ROOT_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = ROOT_exit;
}

static void ROOT_exit(LaserTagMenu1Sm* self)
{
    // State machine root is a special case. It cannot be exited.
    (void)self;  // nothing to see here compiler. move along!
}


static void HOME_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = HOME_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = HOME_ok_press;
}

static void HOME_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void HOME_ok_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `OK_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `OK_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SELECT_CLASS_OPTION
        // Transition to target state MM_SELECT_CLASS_OPTION
        {
            // First, exit up to Least Common Ancestor LaserTagMenu1Sm.
            while (self->current_state_exit_handler != ROOT_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MENUS_GROUP_enter(self);
            MAIN_MENU_enter(self);
            MM_SELECT_CLASS_OPTION_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SELECT_CLASS_OPTION;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}


static void HOME1_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = HOME1_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = HOME1_down_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = HOME1_up_press;
    
    // state behavior:
    {
        // uml action: show_home_screen_1();
        Display_show_home_screen_1();
    } // end of behavior code
}

static void HOME1_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = HOME_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void HOME1_down_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `DOWN_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `DOWN_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: HOME2
        // Transition to target state HOME2
        {
            // First, exit up to Least Common Ancestor HOME.
            while (self->current_state_exit_handler != HOME_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            HOME2_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_HOME2;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}

static void HOME1_up_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `UP_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `UP_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: HOME3
        // Transition to target state HOME3
        {
            // First, exit up to Least Common Ancestor HOME.
            while (self->current_state_exit_handler != HOME_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            HOME3_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_HOME3;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}


static void HOME2_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = HOME2_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = HOME2_down_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = HOME2_up_press;
    
    // state behavior:
    {
        // uml action: show_home_screen_2();
        Display_show_home_screen_2();
    } // end of behavior code
}

static void HOME2_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = HOME_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void HOME2_down_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `DOWN_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `DOWN_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: HOME3
        // Transition to target state HOME3
        {
            // First, exit up to Least Common Ancestor HOME.
            while (self->current_state_exit_handler != HOME_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            HOME3_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_HOME3;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}

static void HOME2_up_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `UP_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `UP_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: HOME1
        // Transition to target state HOME1
        {
            // First, exit up to Least Common Ancestor HOME.
            while (self->current_state_exit_handler != HOME_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            HOME1_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_HOME1;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}


static void HOME3_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = HOME3_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = HOME3_down_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = HOME3_up_press;
    
    // state behavior:
    {
        // uml action: show_home_screen_3();
        Display_show_home_screen_3();
    } // end of behavior code
}

static void HOME3_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = HOME_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void HOME3_down_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `DOWN_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `DOWN_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: HOME1
        // Transition to target state HOME1
        {
            // First, exit up to Least Common Ancestor HOME.
            while (self->current_state_exit_handler != HOME_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            HOME1_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_HOME1;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}

static void HOME3_up_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `UP_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `UP_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: HOME2
        // Transition to target state HOME2
        {
            // First, exit up to Least Common Ancestor HOME.
            while (self->current_state_exit_handler != HOME_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            HOME2_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_HOME2;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}


static void MENUS_GROUP_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MENUS_GROUP_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_HELD] = MENUS_GROUP_back_held;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MENUS_GROUP_back_press;
}

static void MENUS_GROUP_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_HELD] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = NULL;  // no ancestor listens to this event
}

static void MENUS_GROUP_back_held(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `BACK_HELD` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `BACK_HELD` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: HOME1
        // Transition to target state HOME1
        {
            // First, exit up to Least Common Ancestor LaserTagMenu1Sm.
            while (self->current_state_exit_handler != ROOT_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            HOME_enter(self);
            HOME1_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_HOME1;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}

static void MENUS_GROUP_back_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `BACK_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `BACK_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: HOME1
        // Transition to target state HOME1
        {
            // First, exit up to Least Common Ancestor LaserTagMenu1Sm.
            while (self->current_state_exit_handler != ROOT_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            HOME_enter(self);
            HOME1_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_HOME1;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}


static void CLASS_SAVED_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = CLASS_SAVED_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = CLASS_SAVED_do;
    
    // state behavior:
    {
        // uml action: Display_class_saved();
        Display_class_saved();
    } // end of behavior code
    
    // state behavior:
    {
        // uml action: reset_timer1();
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior code
}

static void CLASS_SAVED_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MENUS_GROUP_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void CLASS_SAVED_do(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `do` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: after_timer1_ms(4000)
        // uml transition target: MM_SELECT_CLASS_OPTION
        if (( (PortApi_get_time_ms() - self->vars.timer1_started_at_ms) >= 4000 ))
        {
            // Transition to target state MM_SELECT_CLASS_OPTION
            {
                // First, exit up to Least Common Ancestor MENUS_GROUP.
                while (self->current_state_exit_handler != MENUS_GROUP_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                MAIN_MENU_enter(self);
                MM_SELECT_CLASS_OPTION_enter(self);
                
                // update state_id
                self->state_id = LaserTagMenu1Sm_StateId_MM_SELECT_CLASS_OPTION;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


static void MAIN_MENU_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MAIN_MENU_exit;
    
    // state behavior:
    {
        // uml action: Display_menu_header("MAIN MENU");
        Display_menu_header("MAIN MENU");
    } // end of behavior code
}

static void MAIN_MENU_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MENUS_GROUP_exit;
}


static void MM_BACK_PRESS_EATER_OPTION_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_OPTION_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = MM_BACK_PRESS_EATER_OPTION_ok_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = MM_BACK_PRESS_EATER_OPTION_up_press;
    
    // state behavior:
    {
        // uml action: Display_menu_option("EAT BACK PRESS?");
        Display_menu_option("EAT BACK PRESS?");
    } // end of behavior code
    
    // state behavior:
    {
        // uml action: menu_at_bottom();
        Display_menu_at_bottom();
    } // end of behavior code
}

static void MM_BACK_PRESS_EATER_OPTION_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MAIN_MENU_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_BACK_PRESS_EATER_OPTION_ok_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `OK_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `OK_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_BACK_PRESS_EATER_1
        // Transition to target state MM_BACK_PRESS_EATER_1
        {
            // First, exit up to Least Common Ancestor MENUS_GROUP.
            while (self->current_state_exit_handler != MENUS_GROUP_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_BACK_PRESS_EATER_enter(self);
            MM_BACK_PRESS_EATER_1_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_1;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}

static void MM_BACK_PRESS_EATER_OPTION_up_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `UP_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `UP_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SHOW_INFO_OPTION
        // Transition to target state MM_SHOW_INFO_OPTION
        {
            // First, exit up to Least Common Ancestor MAIN_MENU.
            while (self->current_state_exit_handler != MAIN_MENU_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_SHOW_INFO_OPTION_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_OPTION;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}


static void MM_SELECT_CLASS_OPTION_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SELECT_CLASS_OPTION_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SELECT_CLASS_OPTION_down_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = MM_SELECT_CLASS_OPTION_ok_press;
    
    // state behavior:
    {
        // uml action: Display_menu_option("SELECT CLASS");
        //             menu_at_top();
        Display_menu_option("SELECT CLASS");
        Display_menu_at_top();
    } // end of behavior code
}

static void MM_SELECT_CLASS_OPTION_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MAIN_MENU_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SELECT_CLASS_OPTION_down_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `DOWN_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `DOWN_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SHOW_INFO_OPTION
        // Transition to target state MM_SHOW_INFO_OPTION
        {
            // First, exit up to Least Common Ancestor MAIN_MENU.
            while (self->current_state_exit_handler != MAIN_MENU_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_SHOW_INFO_OPTION_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_OPTION;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}

static void MM_SELECT_CLASS_OPTION_ok_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `OK_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `OK_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SC_ENGINEER
        // Transition to target state MM_SC_ENGINEER
        {
            // First, exit up to Least Common Ancestor MENUS_GROUP.
            while (self->current_state_exit_handler != MENUS_GROUP_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_SELECT_CLASS_enter(self);
            MM_SC_ENGINEER_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SC_ENGINEER;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}


static void MM_SHOW_INFO_OPTION_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SHOW_INFO_OPTION_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SHOW_INFO_OPTION_down_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = MM_SHOW_INFO_OPTION_ok_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = MM_SHOW_INFO_OPTION_up_press;
    
    // state behavior:
    {
        // uml action: Display_menu_option("SHOW INFO");
        Display_menu_option("SHOW INFO");
    } // end of behavior code
    
    // state behavior:
    {
        // uml action: menu_at_mid();
        Display_menu_at_mid();
    } // end of behavior code
}

static void MM_SHOW_INFO_OPTION_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MAIN_MENU_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SHOW_INFO_OPTION_down_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `DOWN_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `DOWN_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_BACK_PRESS_EATER_OPTION
        // Transition to target state MM_BACK_PRESS_EATER_OPTION
        {
            // First, exit up to Least Common Ancestor MAIN_MENU.
            while (self->current_state_exit_handler != MAIN_MENU_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_BACK_PRESS_EATER_OPTION_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_OPTION;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}

static void MM_SHOW_INFO_OPTION_ok_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `OK_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `OK_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SHOW_INFO_1
        // Transition to target state MM_SHOW_INFO_1
        {
            // First, exit up to Least Common Ancestor MENUS_GROUP.
            while (self->current_state_exit_handler != MENUS_GROUP_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_SHOW_INFO_enter(self);
            MM_SHOW_INFO_1_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_1;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}

static void MM_SHOW_INFO_OPTION_up_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `UP_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `UP_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SELECT_CLASS_OPTION
        // Transition to target state MM_SELECT_CLASS_OPTION
        {
            // First, exit up to Least Common Ancestor MAIN_MENU.
            while (self->current_state_exit_handler != MAIN_MENU_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_SELECT_CLASS_OPTION_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SELECT_CLASS_OPTION;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}


static void MM_BACK_PRESS_EATER_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MM_BACK_PRESS_EATER_back_press;
    
    // state behavior:
    {
        // uml action: back_press_eat_count = 0;
        //             show_back_press_count();
        self->vars.back_press_eat_count = 0;
        Display_show_back_press_count(self->vars.back_press_eat_count);
    } // end of behavior code
}

static void MM_BACK_PRESS_EATER_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MENUS_GROUP_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MENUS_GROUP_back_press;  // the next ancestor that handles this event is MENUS_GROUP
}

static void MM_BACK_PRESS_EATER_back_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `BACK_PRESS` event
    self->ancestor_event_handler = MENUS_GROUP_back_press;
    
    // state behavior:
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        // uml action: back_press_eat_count++;
        //             show_back_press_count();
        self->vars.back_press_eat_count++;
        Display_show_back_press_count(self->vars.back_press_eat_count);
        
        if (consume_event)
        {
            // Mark event as handled. Required because of transition.
            self->ancestor_event_handler = NULL;
        }
    } // end of behavior code
}


static void MM_BACK_PRESS_EATER_1_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_1_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_BACK_PRESS_EATER_1_do;
    
    // state behavior:
    {
        // uml action: show_back_press_taunt("GET TO 5?");
        Display_show_back_press_taunt("GET TO 5?");
    } // end of behavior code
}

static void MM_BACK_PRESS_EATER_1_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void MM_BACK_PRESS_EATER_1_do(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `do` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: back_press_eat_count >= 5
        // uml transition target: MM_BACK_PRESS_EATER_2
        if (self->vars.back_press_eat_count >= 5)
        {
            // Transition to target state MM_BACK_PRESS_EATER_2
            {
                // First, exit up to Least Common Ancestor MM_BACK_PRESS_EATER.
                while (self->current_state_exit_handler != MM_BACK_PRESS_EATER_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                MM_BACK_PRESS_EATER_2_enter(self);
                
                // update state_id
                self->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_2;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


static void MM_BACK_PRESS_EATER_2_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_2_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_BACK_PRESS_EATER_2_do;
    
    // state behavior:
    {
        // uml action: show_back_press_taunt("BACKPRESS FUTILE");
        Display_show_back_press_taunt("BACKPRESS FUTILE");
    } // end of behavior code
    
    // state behavior:
    {
        // uml action: reset_timer1();
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior code
}

static void MM_BACK_PRESS_EATER_2_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void MM_BACK_PRESS_EATER_2_do(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `do` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: after_timer1_ms(3000)
        // uml transition target: MM_BACK_PRESS_EATER_3
        if (( (PortApi_get_time_ms() - self->vars.timer1_started_at_ms) >= 3000 ))
        {
            // Transition to target state MM_BACK_PRESS_EATER_3
            {
                // First, exit up to Least Common Ancestor MM_BACK_PRESS_EATER.
                while (self->current_state_exit_handler != MM_BACK_PRESS_EATER_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                MM_BACK_PRESS_EATER_3_enter(self);
                
                // update state_id
                self->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_3;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


static void MM_BACK_PRESS_EATER_3_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_3_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_BACK_PRESS_EATER_3_do;
    
    // state behavior:
    {
        // uml action: show_back_press_taunt("TRY HOLDING BACK");
        Display_show_back_press_taunt("TRY HOLDING BACK");
    } // end of behavior code
    
    // state behavior:
    {
        // uml action: reset_timer1();
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior code
}

static void MM_BACK_PRESS_EATER_3_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void MM_BACK_PRESS_EATER_3_do(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `do` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: back_press_eat_count >= 10 && after_timer1_ms(3000)
        // uml transition target: MM_BACK_PRESS_EATER_4
        if (self->vars.back_press_eat_count >= 10 && ( (PortApi_get_time_ms() - self->vars.timer1_started_at_ms) >= 3000 ))
        {
            // Transition to target state MM_BACK_PRESS_EATER_4
            {
                // First, exit up to Least Common Ancestor MM_BACK_PRESS_EATER.
                while (self->current_state_exit_handler != MM_BACK_PRESS_EATER_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                MM_BACK_PRESS_EATER_4_enter(self);
                
                // update state_id
                self->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_4;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


static void MM_BACK_PRESS_EATER_4_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_4_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_BACK_PRESS_EATER_4_do;
    
    // state behavior:
    {
        // uml action: show_back_press_taunt("I CAN'T EVENT...");
        Display_show_back_press_taunt("I CAN'T EVENT...");
    } // end of behavior code
    
    // state behavior:
    {
        // uml action: reset_timer1();
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior code
}

static void MM_BACK_PRESS_EATER_4_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void MM_BACK_PRESS_EATER_4_do(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `do` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: back_press_eat_count >= 15 && after_timer1_ms(3000)
        // uml transition target: MM_BACK_PRESS_EATER_5
        if (self->vars.back_press_eat_count >= 15 && ( (PortApi_get_time_ms() - self->vars.timer1_started_at_ms) >= 3000 ))
        {
            // Transition to target state MM_BACK_PRESS_EATER_5
            {
                // First, exit up to Least Common Ancestor MM_BACK_PRESS_EATER.
                while (self->current_state_exit_handler != MM_BACK_PRESS_EATER_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                MM_BACK_PRESS_EATER_5_enter(self);
                
                // update state_id
                self->state_id = LaserTagMenu1Sm_StateId_MM_BACK_PRESS_EATER_5;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


static void MM_BACK_PRESS_EATER_5_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_5_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MM_BACK_PRESS_EATER_5_back_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_BACK_PRESS_EATER_5_do;
    
    // state behavior:
    {
        // uml action: reset_timer1();
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior code
    
    // state behavior:
    {
        // uml action: show_random_back_press_taunt();
        Display_show_random_back_press_taunt();
    } // end of behavior code
}

static void MM_BACK_PRESS_EATER_5_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_BACK_PRESS_EATER_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MM_BACK_PRESS_EATER_back_press;  // the next ancestor that handles this event is MM_BACK_PRESS_EATER
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void MM_BACK_PRESS_EATER_5_back_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `BACK_PRESS` event
    self->ancestor_event_handler = MM_BACK_PRESS_EATER_back_press;
    
    // state behavior:
    {
        bool consume_event = true; // events other than `do` are normally consumed by any event handler. Other event handlers in *this* state may still handle the event though.
        (void)consume_event; // avoid un-used variable compiler warning. StateSmith cannot (yet) detect if behavior action code sets `consume_event`.
        
        // uml action: dont_consume_event(); // allow parent inc count
        //             reset_timer1();
        //             show_random_back_press_taunt();
        consume_event = false; // allow parent inc count
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
        Display_show_random_back_press_taunt();
        
        if (consume_event)
        {
            // Mark event as handled. Required because of transition.
            self->ancestor_event_handler = NULL;
        }
    } // end of behavior code
}

static void MM_BACK_PRESS_EATER_5_do(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `do` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: after_timer1_ms(2000)
        // uml transition target: MM_BACK_PRESS_EATER_5
        if (( (PortApi_get_time_ms() - self->vars.timer1_started_at_ms) >= 2000 ))
        {
            // self transition
            MM_BACK_PRESS_EATER_5_exit(self);
            MM_BACK_PRESS_EATER_5_enter(self);
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


static void MM_SELECT_CLASS_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SELECT_CLASS_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MM_SELECT_CLASS_back_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = MM_SELECT_CLASS_ok_press;
    
    // state behavior:
    {
        // uml action: Display_menu_header("SELECT CLASS");
        Display_menu_header("SELECT CLASS");
    } // end of behavior code
}

static void MM_SELECT_CLASS_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MENUS_GROUP_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MENUS_GROUP_back_press;  // the next ancestor that handles this event is MENUS_GROUP
    self->current_event_handlers[LaserTagMenu1Sm_EventId_OK_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SELECT_CLASS_back_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `BACK_PRESS` event
    self->ancestor_event_handler = MENUS_GROUP_back_press;
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SELECT_CLASS_OPTION
        // Transition to target state MM_SELECT_CLASS_OPTION
        {
            // First, exit up to Least Common Ancestor MENUS_GROUP.
            while (self->current_state_exit_handler != MENUS_GROUP_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MAIN_MENU_enter(self);
            MM_SELECT_CLASS_OPTION_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SELECT_CLASS_OPTION;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}

static void MM_SELECT_CLASS_ok_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `OK_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `OK_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml action: save_option_as_class();
        // uml transition target: CLASS_SAVED
        App_save_player_class(self->vars.option_value);
        
        // Transition to target state CLASS_SAVED
        {
            // First, exit up to Least Common Ancestor MENUS_GROUP.
            while (self->current_state_exit_handler != MENUS_GROUP_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            CLASS_SAVED_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_CLASS_SAVED;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}


static void MM_SC_ENGINEER_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SC_ENGINEER_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SC_ENGINEER_down_press;
    
    // state behavior:
    {
        // uml action: Display_menu_option("ENGINEER");
        //             option_value = PlayerClass_ENGINEER;
        //             menu_at_top();
        Display_menu_option("ENGINEER");
        self->vars.option_value = PlayerClass_ENGINEER;
        Display_menu_at_top();
    } // end of behavior code
}

static void MM_SC_ENGINEER_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_SELECT_CLASS_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SC_ENGINEER_down_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `DOWN_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `DOWN_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SC_HEAVY
        // Transition to target state MM_SC_HEAVY
        {
            // First, exit up to Least Common Ancestor MM_SELECT_CLASS.
            while (self->current_state_exit_handler != MM_SELECT_CLASS_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_SC_MID_enter(self);
            MM_SC_HEAVY_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SC_HEAVY;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}


static void MM_SC_MID_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SC_MID_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_HELD] = MM_SC_MID_down_held;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_HELD] = MM_SC_MID_up_held;
    
    // state behavior:
    {
        // uml action: menu_at_mid();
        Display_menu_at_mid();
    } // end of behavior code
}

static void MM_SC_MID_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_SELECT_CLASS_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_HELD] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_HELD] = NULL;  // no ancestor listens to this event
}

static void MM_SC_MID_down_held(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `DOWN_HELD` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `DOWN_HELD` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SC_SPY
        // Transition to target state MM_SC_SPY
        {
            // First, exit up to Least Common Ancestor MM_SELECT_CLASS.
            while (self->current_state_exit_handler != MM_SELECT_CLASS_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_SC_SPY_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SC_SPY;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}

static void MM_SC_MID_up_held(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `UP_HELD` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `UP_HELD` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SC_ENGINEER
        // Transition to target state MM_SC_ENGINEER
        {
            // First, exit up to Least Common Ancestor MM_SELECT_CLASS.
            while (self->current_state_exit_handler != MM_SELECT_CLASS_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_SC_ENGINEER_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SC_ENGINEER;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}


static void MM_SC_ARCHER_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SC_ARCHER_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SC_ARCHER_down_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = MM_SC_ARCHER_up_press;
    
    // state behavior:
    {
        // uml action: set_menu_option_and_class(ARCHER);
        Display_menu_option("ARCHER"); self->vars.option_value = PlayerClass_ARCHER;
    } // end of behavior code
}

static void MM_SC_ARCHER_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_SC_MID_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SC_ARCHER_down_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `DOWN_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `DOWN_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SC_WIZARD
        // Transition to target state MM_SC_WIZARD
        {
            // First, exit up to Least Common Ancestor MM_SC_MID.
            while (self->current_state_exit_handler != MM_SC_MID_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_SC_WIZARD_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SC_WIZARD;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}

static void MM_SC_ARCHER_up_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `UP_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `UP_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SC_HEAVY
        // Transition to target state MM_SC_HEAVY
        {
            // First, exit up to Least Common Ancestor MM_SC_MID.
            while (self->current_state_exit_handler != MM_SC_MID_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_SC_HEAVY_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SC_HEAVY;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}


static void MM_SC_HEAVY_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SC_HEAVY_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SC_HEAVY_down_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = MM_SC_HEAVY_up_press;
    
    // state behavior:
    {
        // uml action: Display_menu_option("HEAVY");
        //             set_option_class(HEAVY);
        Display_menu_option("HEAVY");
        self->vars.option_value = PlayerClass_HEAVY;
    } // end of behavior code
}

static void MM_SC_HEAVY_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_SC_MID_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SC_HEAVY_down_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `DOWN_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `DOWN_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SC_ARCHER
        // Transition to target state MM_SC_ARCHER
        {
            // First, exit up to Least Common Ancestor MM_SC_MID.
            while (self->current_state_exit_handler != MM_SC_MID_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_SC_ARCHER_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SC_ARCHER;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}

static void MM_SC_HEAVY_up_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `UP_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `UP_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SC_ENGINEER
        // Transition to target state MM_SC_ENGINEER
        {
            // First, exit up to Least Common Ancestor MM_SELECT_CLASS.
            while (self->current_state_exit_handler != MM_SELECT_CLASS_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_SC_ENGINEER_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SC_ENGINEER;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}


static void MM_SC_WIZARD_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SC_WIZARD_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SC_WIZARD_down_press;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = MM_SC_WIZARD_up_press;
    
    // state behavior:
    {
        // uml action: set_menu_option_and_class(WIZARD);
        Display_menu_option("WIZARD"); self->vars.option_value = PlayerClass_WIZARD;
    } // end of behavior code
}

static void MM_SC_WIZARD_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_SC_MID_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SC_WIZARD_down_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `DOWN_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `DOWN_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SC_SPY
        // Transition to target state MM_SC_SPY
        {
            // First, exit up to Least Common Ancestor MM_SELECT_CLASS.
            while (self->current_state_exit_handler != MM_SELECT_CLASS_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_SC_SPY_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SC_SPY;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}

static void MM_SC_WIZARD_up_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `UP_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `UP_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SC_ARCHER
        // Transition to target state MM_SC_ARCHER
        {
            // First, exit up to Least Common Ancestor MM_SC_MID.
            while (self->current_state_exit_handler != MM_SC_MID_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_SC_ARCHER_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SC_ARCHER;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}


static void MM_SC_SPY_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SC_SPY_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = MM_SC_SPY_up_press;
    
    // state behavior:
    {
        // uml action: set_menu_option_and_class(SPY);
        //             menu_at_bottom();
        Display_menu_option("SPY"); self->vars.option_value = PlayerClass_SPY;
        Display_menu_at_bottom();
    } // end of behavior code
}

static void MM_SC_SPY_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_SELECT_CLASS_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_UP_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SC_SPY_up_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `UP_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `UP_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SC_WIZARD
        // Transition to target state MM_SC_WIZARD
        {
            // First, exit up to Least Common Ancestor MM_SELECT_CLASS.
            while (self->current_state_exit_handler != MM_SELECT_CLASS_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_SC_MID_enter(self);
            MM_SC_WIZARD_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SC_WIZARD;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}


static void MM_SHOW_INFO_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SHOW_INFO_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MM_SHOW_INFO_back_press;
}

static void MM_SHOW_INFO_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MENUS_GROUP_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_BACK_PRESS] = MENUS_GROUP_back_press;  // the next ancestor that handles this event is MENUS_GROUP
}

static void MM_SHOW_INFO_back_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `BACK_PRESS` event
    self->ancestor_event_handler = MENUS_GROUP_back_press;
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SHOW_INFO_OPTION
        // Transition to target state MM_SHOW_INFO_OPTION
        {
            // First, exit up to Least Common Ancestor MENUS_GROUP.
            while (self->current_state_exit_handler != MENUS_GROUP_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MAIN_MENU_enter(self);
            MM_SHOW_INFO_OPTION_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_OPTION;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        self->ancestor_event_handler = NULL;
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}


static void MM_SHOW_INFO_1_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SHOW_INFO_1_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_SHOW_INFO_1_do;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SHOW_INFO_1_down_press;
    
    // state behavior:
    {
        // uml action: Display_top_line("INFO 1 LINE 1");
        //             Display_bot_line("INFO 1 LINE 2");
        //             reset_timer1();
        Display_top_line("INFO 1 LINE 1");
        Display_bot_line("INFO 1 LINE 2");
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior code
}

static void MM_SHOW_INFO_1_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_SHOW_INFO_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SHOW_INFO_1_do(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `do` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: info_timed_out
        // uml transition target: MM_SHOW_INFO_2
        if ((( (PortApi_get_time_ms() - self->vars.timer1_started_at_ms) >= 3000 )))
        {
            // Transition to target state MM_SHOW_INFO_2
            {
                // First, exit up to Least Common Ancestor MM_SHOW_INFO.
                while (self->current_state_exit_handler != MM_SHOW_INFO_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                MM_SHOW_INFO_2_enter(self);
                
                // update state_id
                self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_2;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}

static void MM_SHOW_INFO_1_down_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `DOWN_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `DOWN_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SHOW_INFO_2
        // Transition to target state MM_SHOW_INFO_2
        {
            // First, exit up to Least Common Ancestor MM_SHOW_INFO.
            while (self->current_state_exit_handler != MM_SHOW_INFO_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_SHOW_INFO_2_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_2;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}


static void MM_SHOW_INFO_2_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SHOW_INFO_2_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_SHOW_INFO_2_do;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SHOW_INFO_2_down_press;
    
    // state behavior:
    {
        // uml action: Display_top_line("INFO 2 LINE 1");
        //             Display_bot_line("INFO 2 LINE 2");
        //             reset_timer1();
        Display_top_line("INFO 2 LINE 1");
        Display_bot_line("INFO 2 LINE 2");
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior code
}

static void MM_SHOW_INFO_2_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_SHOW_INFO_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SHOW_INFO_2_do(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `do` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: info_timed_out
        // uml transition target: MM_SHOW_INFO_3
        if ((( (PortApi_get_time_ms() - self->vars.timer1_started_at_ms) >= 3000 )))
        {
            // Transition to target state MM_SHOW_INFO_3
            {
                // First, exit up to Least Common Ancestor MM_SHOW_INFO.
                while (self->current_state_exit_handler != MM_SHOW_INFO_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                MM_SHOW_INFO_3_enter(self);
                
                // update state_id
                self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_3;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}

static void MM_SHOW_INFO_2_down_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `DOWN_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `DOWN_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SHOW_INFO_3
        // Transition to target state MM_SHOW_INFO_3
        {
            // First, exit up to Least Common Ancestor MM_SHOW_INFO.
            while (self->current_state_exit_handler != MM_SHOW_INFO_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_SHOW_INFO_3_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_3;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}


static void MM_SHOW_INFO_3_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = MM_SHOW_INFO_3_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = MM_SHOW_INFO_3_do;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = MM_SHOW_INFO_3_down_press;
    
    // state behavior:
    {
        // uml action: Display_top_line("INFO 3 LINE 1");
        //             Display_bot_line("INFO 3 LINE 2");
        //             reset_timer1();
        Display_top_line("INFO 3 LINE 1");
        Display_bot_line("INFO 3 LINE 2");
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior code
}

static void MM_SHOW_INFO_3_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = MM_SHOW_INFO_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DOWN_PRESS] = NULL;  // no ancestor listens to this event
}

static void MM_SHOW_INFO_3_do(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `do` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: info_timed_out
        // uml transition target: MM_SHOW_INFO_1
        if ((( (PortApi_get_time_ms() - self->vars.timer1_started_at_ms) >= 3000 )))
        {
            // Transition to target state MM_SHOW_INFO_1
            {
                // First, exit up to Least Common Ancestor MM_SHOW_INFO.
                while (self->current_state_exit_handler != MM_SHOW_INFO_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                MM_SHOW_INFO_1_enter(self);
                
                // update state_id
                self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_1;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}

static void MM_SHOW_INFO_3_down_press(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `DOWN_PRESS` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `DOWN_PRESS` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml transition target: MM_SHOW_INFO_1
        // Transition to target state MM_SHOW_INFO_1
        {
            // First, exit up to Least Common Ancestor MM_SHOW_INFO.
            while (self->current_state_exit_handler != MM_SHOW_INFO_exit)
            {
                self->current_state_exit_handler(self);
            }
            
            // Enter towards target
            MM_SHOW_INFO_1_enter(self);
            
            // update state_id
            self->state_id = LaserTagMenu1Sm_StateId_MM_SHOW_INFO_1;
        } // end of transition code
        
        // Mark event as handled. Required because of transition.
        // self->ancestor_event_handler = NULL; // already done at top of function
        return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
    } // end of behavior code
}


static void WELCOME_SCREEN_enter(LaserTagMenu1Sm* self)
{
    // setup trigger/event handlers
    self->current_state_exit_handler = WELCOME_SCREEN_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = WELCOME_SCREEN_do;
    
    // state behavior:
    {
        // uml action: Display_top_line("WELCOME!");
        Display_top_line("WELCOME!");
    } // end of behavior code
    
    // state behavior:
    {
        // uml action: reset_timer1();
        self->vars.timer1_started_at_ms = PortApi_get_time_ms();
    } // end of behavior code
}

static void WELCOME_SCREEN_exit(LaserTagMenu1Sm* self)
{
    // adjust function pointers for this state's exit
    self->current_state_exit_handler = ROOT_exit;
    self->current_event_handlers[LaserTagMenu1Sm_EventId_DO] = NULL;  // no ancestor listens to this event
}

static void WELCOME_SCREEN_do(LaserTagMenu1Sm* self)
{
    // setup handler for next ancestor that listens to `do` event
    self->ancestor_event_handler = NULL; // no ancestor state handles `do` event
    
    // state behavior:
    {
        // Note: no `consume_event` variable possible here because of state transition. The event must be consumed.
        // uml guard: after_timer1_ms(2500)
        // uml transition target: HOME1
        if (( (PortApi_get_time_ms() - self->vars.timer1_started_at_ms) >= 2500 ))
        {
            // Transition to target state HOME1
            {
                // First, exit up to Least Common Ancestor LaserTagMenu1Sm.
                while (self->current_state_exit_handler != ROOT_exit)
                {
                    self->current_state_exit_handler(self);
                }
                
                // Enter towards target
                HOME_enter(self);
                HOME1_enter(self);
                
                // update state_id
                self->state_id = LaserTagMenu1Sm_StateId_HOME1;
            } // end of transition code
            
            // Mark event as handled. Required because of transition.
            // self->ancestor_event_handler = NULL; // already done at top of function
            return; // event processing immediately stops when a transition occurs. No other behaviors for this state are checked.
        } // end of guard code
    } // end of behavior code
}


